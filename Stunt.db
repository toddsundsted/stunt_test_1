** LambdaMOO Database, Format Version 13 **
2
5
6
0 values pending finalization
0 clocks
0 queued tasks
0 suspended tasks
0 interrupted tasks
0 active connections with listeners
149
#0
System
16
2
1
2
4
0
4
6
1
3
1
12
1
95
1
101
1
105
1
141
4
0
33
_log_error
5
172
-1
do_start_script
5
172
-1
server_started
5
172
-1
do_login_command
5
172
-1
authenticate
2
172
-1
public
2
172
-1
private
5
172
-1
protected
5
172
-1
restrict_to_server
2
172
-1
restrict_to_builtin
2
172
-1
restrict_to_caller
5
172
-1
permit
5
172
-1
check_create_permission
2
172
-1
check_controls
2
172
-1
_unpack_verb_code
2
172
-1
_pack_verb_code
2
172
-1
bf_verb_code verb_code
5
172
-1
bf_set_verb_code set_verb_code
5
172
-1
verb_detail
5
172
-1
_parse_content_type
2
172
-1
_generate_content_type
2
172
-1
verb_commit
5
172
-1
verb_revert
5
172
-1
verb_truncate*_revisions
5
172
-1
lookup*_reference
5
172
-1
_match_external_compiler
2
172
-1
grant
5
172
-1
revoke
5
172
-1
match_permit
5
172
-1
verb_doc
5
172
-1
set_verb_doc
5
172
-1
suspend_if_necessary suspend_if_needed
5
172
-1
validate_doc_format _validate_doc_format
2
172
-1
18
system
server_options
nothing
ambiguous_match
failed_match
passkey_players
disable_passkey_login
external_compilers
last_login_connection
welcome_message
epoch
core
plastic
blink
alt
model
dialog
mustache
35
1
0
2
1
1
1
2
1
1
-1
2
1
1
-2
2
1
1
-3
2
1
4
2
1
5
1
6
5
0
0
0
5
0
10
2
2
application/x-moocode;version=1.0.*
1
46
2
application/x-mustache
1
138
2
1
0
0
2
1
2
Welcome to Stunt!  For information about Stunt, check out http://stunt.io/.  To connect to the server, type "connect <credentials>".
2
1
0
0
2
1
1
28
26
1
1
43
41
1
1
77
75
1
1
88
86
1
1
108
107
1
1
119
117
1
1
137
135
1
5
2
1
5
2
1
5
2
1
5
2
1
5
11
1
5
11
1
5
11
1
5
11
1
5
11
1
5
11
1
5
11
1
5
11
1
5
93
1
5
93
1
5
99
1
5
99
1
5
103
1
#1
Server Options
16
2
1
2
4
0
4
0
4
0
0
25
support_numeric_verbname_strings
protect_verb_code
protect_set_verb_code
max_concat_catchable
max_string_concat
max_list_value_bytes
max_map_value_bytes
fg_seconds
fg_ticks
bg_seconds
bg_ticks
connect_timeout
outbound_connect_timeout
name_lookup_timeout
max_stack_depth
queued_task_limit
default_flush_command
boot_msg
connect_msg
create_msg
recycle_msg
redirect_from_msg
redirect_to_msg
server_full_msg
timeout_msg
25
0
0
2
1
0
1
2
0
0
1
2
0
0
1
2
0
0
64537861
2
0
0
64537861
2
0
0
64537861
2
0
0
5
2
0
0
60000
2
0
0
3
2
0
0
30000
2
0
0
300
2
0
0
5
2
0
0
5
2
0
0
50
2
0
0
-1
2
0
2
.flush
2
0
2
*** Disconnected ***
2
0
2
*** Connected ***
2
0
2
*** Created ***
2
0
2
*** Recycled ***
2
0
2
*** Redirecting connection to new port ***
2
0
2
*** Redirecting old connection to this port ***
2
0
4
2
2
*** Sorry, but the server cannot accept any more connections right now. ***
2
*** Please try again later. ***
2
0
2
*** Timed-out waiting for login. ***
2
0
#2
Kernel Package
16
2
1
-1
4
8
1
0
1
1
1
3
1
10
1
4
1
7
1
8
1
9
4
0
4
0
0
11
identifier
version
manifest
relocate
requires
provides
instructions
description
authors
homepage
license
11
2
kernel
2
1
2
1.1.5
2
1
4
10
4
2
1
2
2
package
4
2
1
0
2
system
4
2
1
1
2
server_options
4
2
1
3
2
dictionary
4
2
1
10
2
changelog
4
2
1
4
2
object
4
2
1
8
2
shapes
4
2
1
9
2
composed
4
2
1
5
2
wizard
4
2
1
6
2
programmer
2
1
4
7
2
system.system
2
system.server_options
2
dictionary.kernel
2
dictionary.object
2
dictionary.shapes
2
dictionary.composed
2
system.passkey_players
2
1
4
0
2
1
4
0
2
1
4
1
2
install-dictionary
2
1
2
The kernel package comprises the minimal set of objects necessary to hack on and/or bootstrap a core.
2
1
4
1
2
Todd Sundsted
2
1
2
http://stunt.io/packages/kernel
2
1
2
FreeBSD License
2
1
#3
Kernel Dictionary
16
2
1
2
4
0
4
0
4
1
1
0
4
handle_uncaught_error
5
172
-1
handle_task_timeout
5
172
-1
server_started
5
172
-1
authenticate
5
172
-1
4
kernel
object
shapes
composed
4
1
3
2
1
1
4
2
1
1
8
2
1
1
9
2
1
#4
Object
144
2
1
2
4
0
1
-1
4
19
1
8
1
9
1
7
1
27
1
40
1
46
1
47
1
90
1
96
1
97
1
106
1
110
1
111
1
120
1
121
1
124
1
132
1
133
1
138
0
1
aliases
1
4
0
2
4
#5
Wizard
7
5
1
7
4
0
4
2
1
92
1
96
4
0
2
@strip-db-and-shutdown
5
8
-1
huh
5
172
-1
1
passkey
5
0
0
5
0
5
5
4
5
5
4
5
5
4
5
5
0
#6
Programmer
3
6
1
7
4
0
4
2
1
91
1
96
4
0
0
1
passkey
5
0
0
5
0
5
6
4
5
6
4
5
6
4
5
5
0
#7
Home
0
6
1
2
4
2
1
5
1
6
1
4
4
0
1
eval*uate
5
88
-2
0
1
5
6
4
#8
Shapes, Serialization/Deserialization Library
0
2
1
2
4
0
1
4
4
0
23
_log
5
172
-1
_suspend_if_necessary
2
172
-1
_controls controls
2
164
-1
_controls_verb
5
164
-1
_controls_property
5
164
-1
objects
5
172
-1
read_object
5
172
-1
write_object
5
172
-1
_parent_property_info
5
172
-1
_values
5
172
-1
values
5
172
-1
read_value
5
172
-1
write_value
5
172
-1
_write_parents
5
172
-1
_write_player
5
172
-1
read_verb
5
172
-1
write_verb
5
172
-1
read_property
5
172
-1
write_property
5
172
-1
bare_object
2
172
-1
add_value
2
172
-1
add_property_definition
2
172
-1
add_verb_definition
2
172
-1
0
1
5
2
4
#9
Composed, Component Library
0
2
1
2
4
0
1
4
4
0
48
_log
5
172
-1
_notify
5
172
-1
_move
5
172
-1
_suspend_if_necessary
2
172
-1
_parse_specifier
2
172
-1
_parse_operation
2
172
-1
_parse_version
2
172
-1
_compare_versions
2
172
-1
_sort_versions
2
172
-1
_match match
2
172
-1
_map_specifier
2
172
-1
_unmap_specifier
2
172
-1
_install
2
172
-1
_uninstall
2
172
-1
_find_requires_provider
2
172
-1
reinitialize
2
172
-1
_check_required_provides
2
172
-1
_check_provided_requires
2
172
-1
_generate_global_mapping_keyed_on_object
5
172
-1
_generate_global_mapping_keyed_on_identifier
5
172
-1
_map
2
172
-1
_lookup
2
164
-1
_lookup_by_object
2
172
-1
_lookup_by_label
2
172
-1
_is_ancestor
2
172
-1
_contents
2
172
-1
install
5
172
-1
uninstall
5
172
-1
delete
5
172
-1
_set_seconds_and_ticks
5
172
-1
_reset_seconds_and_ticks
5
172
-1
import
5
172
-1
export
5
172
-1
_parse_url
2
164
-1
_fetch
5
172
-1
fetch_index
2
172
-1
fetch_package_to_cache
2
172
-1
import_package_from_archive
5
172
-1
import_package_from_cache
5
172
-1
export_package_to_cache
5
172
-1
import_package_from_file
5
172
-1
export_package_to_file
5
172
-1
pretty_print_cached_package
5
172
-1
@install
5
156
0
@uninstall
5
156
0
@list*-packages
5
156
0
_do_instructions
5
172
-1
_undo_instructions
5
172
-1
7
packages
provides_cache
requires_cache
last_fetch_index
archived
cached
archive_sources
8
4
15
1
2
1
11
1
26
1
38
1
41
1
75
1
86
1
93
1
99
1
103
1
107
1
117
1
128
1
135
1
139
2
0
10
15
2
alt
10
1
2
0.0.4
4
1
1
86
2
application
10
1
2
0.0.10
4
1
1
139
2
ask
10
1
2
0.0.2
4
1
1
99
2
blink
10
1
2
0.0.1
4
1
1
75
2
core
10
1
2
0.0.4
4
1
1
26
2
dialog
10
1
2
0.1.2
4
1
1
117
2
dialog_extras
10
1
2
0.0.7
4
1
1
128
2
identity
10
1
2
0.0.3
4
1
1
93
2
kernel
10
1
2
1.1.5
4
1
1
2
2
model
10
1
2
0.0.1
4
1
1
107
2
mustache
10
1
2
1.0.1
4
1
1
135
2
persistent
10
1
2
0.0.2
4
1
1
103
2
plastic
10
1
2
1.0.1
4
1
1
41
2
primitive
10
1
2
0.0.6
4
1
1
11
2
text_tools
10
1
2
0.0.1
4
1
1
38
2
0
10
9
2
ask
10
1
2
0.0.2
4
1
1
107
2
blink
10
1
2
0.0.1
4
1
1
86
2
core
10
1
2
0.0.4
4
5
1
41
1
75
1
86
1
117
1
128
2
dialog
10
1
2
0.1.2
4
2
1
128
1
139
2
dialog_extras
10
1
2
0.0.7
4
1
1
139
2
kernel
10
1
2
1.1.5
4
13
1
11
1
26
1
38
1
41
1
75
1
86
1
93
1
99
1
103
1
107
1
117
1
128
1
135
2
plastic
10
1
2
1.0.1
4
5
1
75
1
86
1
117
1
128
1
139
2
primitive
10
1
2
0.0.6
4
8
1
38
1
41
1
75
1
86
1
99
1
117
1
128
1
135
2
text_tools
10
1
2
0.0.1
4
1
1
86
2
0
0
0
2
0
10
0
2
0
10
0
2
0
4
1
2
http://stunt.io/v2/packages.json
2
0
5
2
4
#10
Changelog
16
2
1
2
4
0
1
-1
4
0
1
log
2
172
-1
86
1311681611
1311705199
1313452513
1315679164
1315956214
1316093967
1316094064
1317297266
1317487599
1317741809
1319025014
1319537884
1320954195
1321316054
1321356258
1321643106
1321643582
1323085326
1323087749
1328836140
1329004700
1329006449
1329757584
1329871032
1329874322
1331122162
1336415098
1336415121
1336415146
1336420618
1337254948
1337555791
1338032579
1338035085
1338035909
1338138322
1338138532
1338169765
1338239921
1338256684
1338511433
1338810704
1338810739
1338986468
1339116074
1339119035
1339159099
1339716849
1341319605
1341918651
1341919633
1352859577
1354716719
1355401890
1356004499
1356004559
1356009919
1356610770
1357132259
1357402056
1357415815
1357446795
1357452296
1357929752
1357994951
1358784518
1358785509
1360437901
1360668144
1360897124
1360897245
1360927587
1361198611
1361713717
1364568728
1364589314
1365859482
1365949160
1368872418
1368872441
1369664500
1373099120
1373099164
1373685265
1375669101
1376234886
86
2
Added code to disable login by passkey players.
2
1
2
Added code to write a warning to the log when passkey authentication is enabled.
2
1
2
Moved passkey_login and passkey_players to the system object (#0) so that they are harder to subvert.
2
1
2
Updated `strip-core-and-shutdown' verb to reflect passkey changes.
2
1
2
Fixed incorrect implementation of specified test for a built-in function entry.
2
1
2
Added kernel support for enhanced verb programming.
2
1
2
Removed all verbs on core wiz/prog location except `map' and `eval'.
2
1
2
Added support for `chunk_length'.
2
1
2
Added support for `content_type'.
2
1
2
Removed `map' verb from core wiz/prog location.
2
1
2
Changed `restrict_to_caller' to check the object on which the verb was defined, instead of used.
2
1
2
Fixed scope bug in `$lookup()'.
2
1
2
Added `$configuration' -- package independent, per-environment, per-server configuration goes/stays here.
2
1
2
`$lookup()' now allows wizards to specify the package to search.
2
1
2
`$composed' no longer assumes the existence of `$sysobj'.
2
1
2
Remove `$configuration' -- replaced it with an app-specific property.
2
1
2
Added `import_package_from_file()' and `export_package_to_file' to `$composed'.
2
1
2
Added a welcome message and cleaned up `do_login_command()' and `authenticate()'.
2
1
2
Shape" is now called "Shapes".
2
1
2
Reset `#0.last_login_connection' on server start.
2
1
2
Tweaks to use the new for loop syntax.
2
1
2
Moved verb `audit' out of $composed.
2
1
2
`$verb_detail()' handles the case where `caller_perms()' is `$nothing'.
2
1
2
Added `fg/bg_seconds', `fg/bg_ticks' and `max_concat_catchable' properties to `$server_options'.
2
1
2
In the `@import' command, set the seconds/ticks to a large number so suspending is not necessary.
2
1
2
Fixed `reinitialize()' so that it was smarter with `args'.
2
1
2
`$composed' defaults to the existing content type if none is specified.
2
1
2
Verb metadata includes the sha1 of the verb source.
2
1
2
`$verb_detail()' returns the verb metadata.
2
1
2
In `$composed', better error messages when `relocate' holds a bad reference.
2
1
2
Promoted `$shapes:_controls()' to public and reduced perms.
2
1
2
Fixed regular expressions that were matching "." instead of "%.".
2
1
2
Made the default behavior of `bf_verb_code()' match the builtin.
2
1
2
Options should be dashed not underscored.
2
1
2
The fourth arg is the content type.
2
1
2
Added `state' and `revision' to verb metadata, and added verb version control verbs.
2
1
2
Added `updated_by' to verb metadata.
2
1
2
Use `read_http()' in `_fetch_from_archive()'.
2
1
2
Moved instruction handling into `install()' and `uninstall()'/`delete()'.
2
1
2
Make sure the player isn't inside of the package he/she/it is about to delete.
2
1
2
Handle options correctly on install with implicit identifier and version.
2
1
2
Added package-scoped lookup (e.g. `$lookup("object|kernel")').
2
1
2
Moved `$lookup_reference()' to `$system'.
2
1
2
Properly check the file handle when importing/exporting from/to a file.
2
1
2
Don't include unnecessary metadata in output from `read_verb()'.
2
1
2
Do not version or stamp verbs on `import()'.
2
1
2
`$verb_revert()' now reverts the raw verb code, too.
2
1
2
Fixed bug in tilde handling in `_fetch_from_archive()'.
2
1
2
Added ticks/seconds checks in `_unpack/_pack_verb_code()'.
2
1
2
Handle errors fetching from the archive better.
2
1
2
Lookup objects in an object's package even if the specified is explicit.
2
1
2
Give `$protected()' and `$private()' wiz-perms so that they can inspect anonymous objects.
2
1
2
Give `$permit()' wiz-perms so that it can inspect anonymous objects.
2
1
2
Changed the requirement for compiler output in `set_verb_code()'.
2
1
2
Created new version: 1.1.2.
2
1
2
Enabled support for versioning external compilers.
2
1
2
The `reinitialize()' verb restores state on failure.
2
1
2
Added support for anonymous objects to `$shapes'.
2
1
2
Don't write clear values.
2
1
2
`_fetch()' follows HTTP redirects.
2
1
2
Added support for multiple archive sources.
2
1
2
Added all known server options to `$server_options'.
2
1
2
Ensure non-local objects belong to the owner of the package.
2
1
2
Added `$grant()', `$revoke()' and permissions.
2
1
2
Better diagnostics for multiple archive sources.
2
1
2
Created new version: 1.1.3.
2
1
2
Added `$epoch' to track restarts.
2
1
2
Give `$restrict_to_caller()' wiz-perms.
2
1
2
Created new version: 1.1.4.
2
1
2
Fixed handling of "~" in archive sources.
2
1
2
Swallow errors raised when moving objects during installation.
2
1
2
Created new version: 1.1.5.
2
1
2
Fixed permissions errors in `verb_commit()', `verb_revert()' and `bf_set_verb_code()'.
2
1
2
Added `$suspend_if_necessary()'/`$suspend_if_needed()'.
2
1
2
Added verbs `$verb_doc()' and `$set_verb_doc()'.
2
1
2
Added verb documentation support to `$shapes'.
2
1
2
Added better archive support to `$composed.'
2
1
2
Fixed lingering issues with `$permit()'.
2
1
2
Added `do_start_script()' handler.
2
1
2
Added support for passkeys from the environment.
2
1
2
Added `$verb_truncate_revisions()'.
2
1
2
Verbs `$composed:_install()' and `$composed:_uninstall() roll back on error.
2
1
2
`$composed:reinitialize()' reorders packages if necessary.
2
1
2
Added suspend to `$composed:fetch_index()'.
2
1
2
`lookup_reference()' can start from where the verb was used instead of defined.
2
1
2
The verbs `read/write_verb()' in `$shapes' handle empty verbs correctly.
2
1
#11
Primitive Package
0
11
1
-1
4
14
1
12
1
13
1
14
1
15
1
16
1
17
1
18
1
19
1
20
1
21
1
22
1
23
1
24
1
25
1
-1
4
0
0
10
identifier
version
manifest
relocate
requires
instructions
description
authors
homepage
license
10
2
primitive
11
1
2
0.0.6
11
1
4
10
4
2
1
11
2
package
4
2
1
12
2
dictionary
4
2
1
13
2
changelog
4
2
1
16
2
int_proto
4
2
1
17
2
float_proto
4
2
1
19
2
str_proto
4
2
1
20
2
err_proto
4
2
1
21
2
list_proto
4
2
1
22
2
map_proto
4
2
1
23
2
lambda_proto
11
1
4
8
2
dictionary.int_proto
2
dictionary.float_proto
2
dictionary.str_proto
2
dictionary.err_proto
2
dictionary.list_proto
2
dictionary.map_proto
2
dictionary.lambda_proto
2
dictionary.frobs
11
1
4
1
4
2
2
kernel
2
>= 1.0.4
11
1
4
1
2
install-dictionary
11
1
2
The primitive package comprises prototype objects for LambdaMOO primitive data-types, utility operations on primitives, and objects for basic functional-style programming.
11
1
4
1
2
Todd Sundsted
11
1
2
http://stunt.io/packages/primitive
11
1
2
FreeBSD License
11
1
#12
Primitive Dictionary
0
11
1
11
4
0
1
-1
4
1
1
0
1
lambda
11
172
-1
8
int_proto
float_proto
str_proto
err_proto
list_proto
map_proto
frobs
lambda_proto
8
1
16
11
1
1
17
11
1
1
19
11
1
1
20
11
1
1
24
11
1
1
25
11
1
4
1
1
23
11
1
1
23
11
1
#13
Changelog
0
11
1
11
4
0
1
-1
4
0
0
20
1321837971
1322305336
1329066914
1356485946
1356524573
1358112743
1358256500
1358256855
1359228791
1359457658
1361647917
1361648801
1361649333
1361658325
1363542041
1363700859
1365812746
1365875645
1367066718
1367066765
20
2
Added support for functional-style programming via string lambdas.
11
1
2
Implemented first-pass primitives (with tests) including basic support for functional-style programming.
11
1
2
Updated verbs to use the new for loop syntax.
11
1
2
Created new version: 0.0.3.
11
1
2
The `split()' verb now splits on empty string as a special case.
11
1
2
Extensive additions to map, list, string and integer prototypes.
11
1
2
Created new version: 0.0.4.
11
1
2
Made `match()'/`rmatch()' their own verbs and appended verb arguments to the result.
11
1
2
Added `first()' and `last()' verbs to the list prototype.
11
1
2
Added `next()' and `previous()' verbs to the string prototype.
11
1
2
Created new version: 0.0.5.
11
1
2
Liberalized arguments for `slice()'.
11
1
2
Ignore missing keys in `slice()'.
11
1
2
Added `is_xyz()' support to base object.
11
1
2
Created new version: 0.0.6.
11
1
2
Added some basic API documentation for strings, maps, lists and integers.
11
1
2
Added `truncate()' to the string prototype.
11
1
2
Added `escape_html()'/`unescape_html()' to the string prototype.
11
1
2
Specialized escaping for elements and attributes.
11
1
2
Added `chr()' to `$int_proto' and `asc()' to `$str_proto'.
11
1
#14
Base Primitive
0
11
1
11
4
0
1
-1
4
6
1
16
1
17
1
19
1
20
1
21
1
22
4
_suspend_if_necessary
11
172
-1
is_int is_float is_obj is_anon is_str is_err is_list is_map
11
172
-1
type_of typeof
11
172
-1
to_json tojson
11
172
-1
0
0
#15
Numeric Primitive
0
11
1
11
4
0
1
-1
4
2
1
16
1
17
1
abs
11
172
-1
0
0
#16
Integer Prototype
0
11
1
11
4
0
4
2
1
14
1
15
4
0
9
up_to upto
5
172
-1
down_to downto
5
172
-1
is_even
11
172
-1
is_odd
11
172
-1
gcd
11
172
-1
lcm
11
172
-1
is_prime
11
172
-1
tostr to_str
11
172
-1
chr
11
172
-1
1
api_prologue
1
4
3
4
6
2
p
2
The int prototype (
4
2
2
var
2
$int_proto
2
) defines verbs that perform operations on the receiver, which will be of type 
4
2
2
var
2
INT
2
. All verbs are of the general form:
4
2
2
pre
4
8
2
code
10
1
2
class
2
language-moocode
4
2
2
em
2
any
2
 
4
2
2
var
2
int
2
:
4
2
2
strong
2
verb
2
(...)
4
4
2
p
2
Where 
4
2
2
var
2
int
2
 may be a integer literal or an expression returning a integer value.
11
1
#17
Float Prototype
0
11
1
11
4
0
4
2
1
14
1
15
4
0
0
0
0
#18
Sequence Primitive
0
11
1
11
4
0
1
-1
4
3
1
19
1
21
1
22
10
_lambdafy
11
172
-1
each
5
172
-1
collect map
5
172
-1
inject reduce fold
5
172
-1
detect find
5
172
-1
select find_all
5
172
-1
reject
5
172
-1
every
5
172
-1
some
5
172
-1
length
11
172
-1
0
0
#19
String Prototype
0
11
1
11
4
0
4
2
1
14
1
18
4
0
33
to_lambda tolambda
11
172
-1
eval
5
172
-1
index rindex
11
172
-1
match rmatch
11
172
-1
split explode
11
172
-1
trim triml trimr
11
172
-1
strsub
11
172
-1
strtr
11
172
-1
repeat
11
172
-1
fill space
11
172
-1
right
11
172
-1
left
11
172
-1
center centre
11
172
-1
to_upper*case
11
172
-1
to_lower*case
11
172
-1
capitalize
11
172
-1
strip*_characters
11
172
-1
is_empty
11
172
-1
is_blank
11
172
-1
partition
11
172
-1
rpartition
11
172
-1
reverse
11
172
-1
squeeze
11
172
-1
next
11
172
-1
previous
11
172
-1
hash
11
172
-1
truncate ellipses
11
172
-1
encode_base64
11
172
-1
decode_base64
11
172
-1
escape_html_element_content
11
172
-1
escape_html_attribute_content
11
172
-1
unescape_html
11
172
-1
asc
11
172
-1
1
api_prologue
1
4
3
4
6
2
p
2
The string prototype (
4
2
2
var
2
$str_proto
2
) defines verbs that perform operations on the receiver, which will be of type 
4
2
2
var
2
STR
2
. All verbs are of the general form:
4
2
2
pre
4
8
2
code
10
1
2
class
2
language-moocode
4
2
2
em
2
any
2
 
4
2
2
var
2
string
2
:
4
2
2
strong
2
verb
2
(...)
4
4
2
p
2
Where 
4
2
2
var
2
str
2
 may be a string literal or an expression returning a string value.
11
1
#20
Error Prototype
0
11
1
11
4
0
4
1
1
14
4
0
0
0
0
#21
List Prototype
0
11
1
11
4
0
4
2
1
14
1
18
4
1
1
24
27
to_lambda tolambda
11
172
-1
eval
5
172
-1
setadd
11
172
-1
setremove
11
172
-1
union
11
172
-1
intersection
11
172
-1
difference
11
172
-1
join
11
172
-1
sort
11
172
-1
reverse
11
172
-1
slice
11
172
-1
flatten
11
172
-1
dedup unique remove_duplicates
11
172
-1
compress
11
172
-1
remove_all
11
172
-1
repeat make
11
172
-1
count
11
172
-1
is_empty is_blank
11
172
-1
combinations
11
172
-1
permutations
11
172
-1
product
11
172
-1
rotate
11
172
-1
shuffle
11
172
-1
sample
11
172
-1
to_map
11
172
-1
first
11
172
-1
last
11
172
-1
1
api_prologue
1
4
3
4
6
2
p
2
The list prototype (
4
2
2
var
2
$list_proto
2
) defines verbs that perform operations on the receiver, which will be of type 
4
2
2
var
2
LIST
2
. All verbs are of the general form:
4
2
2
pre
4
8
2
code
10
1
2
class
2
language-moocode
4
2
2
em
2
any
2
 
4
2
2
var
2
list
2
:
4
2
2
strong
2
verb
2
(...)
4
4
2
p
2
Where 
4
2
2
var
2
list
2
 may be a list literal or an expression returning a list value.
11
1
#22
Map Prototype
0
11
1
11
4
0
4
2
1
14
1
18
4
1
1
25
12
keys
11
172
-1
values
11
172
-1
delete
11
172
-1
value_by_path
11
172
-1
set_value_by_path
11
172
-1
merge update
11
172
-1
is_empty is_blank
11
172
-1
has_key
11
172
-1
has_value
11
172
-1
invert
11
172
-1
slice
11
172
-1
to_list
11
172
-1
1
api_prologue
1
4
3
4
6
2
p
2
The map prototype (
4
2
2
var
2
$map_proto
2
) defines verbs that perform operations on the receiver, which will be of type 
4
2
2
var
2
MAP
2
. All verbs are of the general form:
4
2
2
pre
4
8
2
code
10
1
2
class
2
language-moocode
4
2
2
em
2
any
2
 
4
2
2
var
2
map
2
:
4
2
2
strong
2
verb
2
(...)
4
4
2
p
2
Where 
4
2
2
var
2
map
2
 may be a map literal or an expression returning a map value.
11
1
#23
Lambda Prototype
0
11
1
11
4
0
1
-1
4
0
8
create
11
172
-1
type_of typeof
11
172
-1
to_lambda tolambda
11
172
-1
_params_and_body
11
172
-1
_prepend_assignments
11
172
-1
partial
11
172
-1
bind
11
172
-1
call
5
172
-1
0
0
#24
List-Based Frob Prototype
0
11
1
11
4
0
4
1
1
21
4
0
1
*
5
172
-1
0
1
5
11
1
#25
Map-Based Frob Prototype
0
11
1
11
4
0
4
1
1
22
4
0
1
*
5
172
-1
0
1
5
11
1
#26
Core Package
0
26
1
-1
4
7
1
27
1
28
1
29
1
30
1
35
1
36
1
37
4
1
1
27
4
0
0
0
12
2
core
26
5
2
0.0.4
26
5
4
12
4
2
1
26
2
package
4
2
1
28
2
dictionary
4
2
1
29
2
changelog
4
2
1
30
2
utility
4
2
1
31
2
regexp_utilities
4
2
1
32
2
time_utilities
4
2
1
33
2
file_utilities
4
2
1
34
2
object_utilities
4
2
1
27
2
package_proto
4
2
1
35
2
permit_base_proto
4
2
1
36
2
change_owner_permit_proto
4
2
1
37
2
file_io_proto
26
5
4
12
2
dictionary.utility
2
dictionary.permit_base_proto
2
dictionary.change_owner_permit_proto
2
dictionary.file_io_proto
2
utility.regexp
2
utility.time
2
utility.file
2
utility.object
2
regexp_utilities.core
2
time_utilities.core
2
object_utilities.change_owner_permit_proto
2
file_utilities.file_io_proto
26
5
4
1
4
2
2
kernel
2
>= 1.1.3
26
5
5
26
5
4
1
2
install-namespace
26
5
2
The Core package contains objects that work with and/or extend the Kernel package.
26
5
4
1
2
Todd Sundsted
26
5
5
26
5
2
FreeBSD License
26
5
5
26
4
#27
Package Prototype
144
26
1
26
4
0
4
1
1
4
4
2
1
26
1
75
1
acceptable accept
26
172
-1
11
identifier
version
manifest
relocate
requires
provides
instructions
description
authors
homepage
license
12
2

26
5
2

26
5
4
0
26
5
4
0
26
5
4
0
26
5
4
0
26
5
4
0
26
5
2

26
5
4
0
26
5
2

26
5
2

26
5
5
26
4
#28
Dictionary
16
26
1
26
4
0
1
-1
4
0
0
5
package_proto
permit_base_proto
change_owner_permit_proto
file_io_proto
utility
5
1
21232
26
1
1
35
26
1
1
36
26
1
1
37
26
1
1
30
26
1
#29
Changelog
0
26
1
26
4
0
1
-1
4
0
0
13
1336405818
1336406704
1357929776
1358113390
1358643384
1358712225
1358814995
1361222695
1363704845
1366094073
1375017212
1375229758
1375274377
13
2
Moved package prototype into package.
26
1
2
Raise exceptions like `move()' in the verb `acceptable()'.
26
1
2
Added permissions support.
26
1
2
Created new version: 0.0.2.
26
1
2
Added `$core.utility.time' and verbs.
26
1
2
Added `$core.utility.regexp' and verbs.
26
1
2
Added `$core.utility.file' and verbs.
26
1
2
Created new version: 0.0.3.
26
1
2
Created new version: 0.0.4.
26
1
2
Added UTC time zone.
26
1
2
Added extensive list of time zones and fixed a few internal bugs.
26
1
2
Added `verbs_suspended()' and `properties_suspended()'.
26
1
2
Added `all_contents*_suspended()'.
26
1
#30
Utility Dictionary
16
26
1
26
4
4
1
31
1
32
1
33
1
34
1
-1
4
0
0
4
regexp
time
file
object
4
1
31
26
1
1
32
26
1
1
33
26
1
1
34
26
1
#31
Regular Expression Utilities
0
26
1
30
4
0
1
-1
4
0
9
original*_string
26
172
-1
matched*_string
26
172
-1
regexp*_source
26
172
-1
all_captured*_substrings
26
172
-1
at
26
172
-1
begin end
26
172
-1
offset
26
172
-1
post_match pre_match
26
172
-1
count
26
172
-1
1
core
1
1
28
26
0
#32
Time Utilities
0
26
1
30
4
0
1
-1
4
0
16
make_time
26
172
-1
parse_ctime from_ctime
26
172
-1
parse_w3c_time from_w3c_time
26
172
-1
_pluralize
26
172
-1
english_time
26
172
-1
now
26
172
-1
string_month
26
172
-1
string_day
26
172
-1
year month day hour minute second
26
172
-1
is_am is_pm
26
172
-1
zone
26
172
-1
is_dst
26
172
-1
is_sunday is_monday is_tuesday is_wednesday is_thursday is_friday is_saturday
26
172
-1
format substitute
26
172
-1
rfc1123_time
26
172
-1
w3c_time
26
172
-1
8
core
api_prologue
months
months_short
days
days_short
time_zones
dst_zones
8
1
28
26
0
4
1
4
4
2
p
2
The time utilities object (
4
2
2
var
2
$core.utility.time
2
) defines verbs that manipulate representations of time.
26
1
4
12
2
January
2
February
2
March
2
April
2
May
2
June
2
July
2
August
2
September
2
October
2
November
2
December
26
1
4
12
2
Jan
2
Feb
2
Mar
2
Apr
2
May
2
Jun
2
Jul
2
Aug
2
Sep
2
Oct
2
Nov
2
Dec
26
1
4
7
2
Sunday
2
Monday
2
Tuesday
2
Wednesday
2
Thursday
2
Friday
2
Saturday
26
1
4
7
2
Sun
2
Mon
2
Tue
2
Wed
2
Thu
2
Fri
2
Sat
26
1
10
101
2
ACSST
9
10.5
2
ACST
0
-4
2
ACT
0
-5
2
ADT
0
-3
2
AESST
0
11
2
AEST
0
10
2
AFT
9
4.5
2
AHST
0
-10
2
AKDT
0
-8
2
AKST
0
-9
2
ALMST
0
7
2
ALMT
0
6
2
AST
0
-4
2
AWSST
0
9
2
AWST
0
8
2
AWT
0
-3
2
BDST
0
2
2
BRST
0
-2
2
BRT
0
-3
2
BST
0
1
2
BT
0
3
2
CADT
9
10.5
2
CAST
9
9.5
2
CAT
0
-10
2
CCT
0
8
2
CDT
0
-5
2
CEST
0
2
2
CET
0
1
2
CETDST
0
2
2
CST
0
-6
2
CXT
0
7
2
DNT
0
1
2
EAST
0
4
2
EAT
0
3
2
EDT
0
-4
2
EET
0
2
2
EETDST
0
3
2
EST
0
-5
2
FNST
0
-1
2
FNT
0
-2
2
FST
0
1
2
FWT
0
2
2
GMT
0
0
2
GST
0
10
2
HDT
0
-9
2
HMT
0
3
2
HST
0
-10
2
IDLE
0
12
2
IDLW
0
-12
2
IOT
0
5
2
IRT
9
3.5
2
IST
0
2
2
JST
0
9
2
JT
9
7.5
2
KST
0
9
2
LIGT
0
10
2
MART
9
-9.5
2
MAWT
0
6
2
MDT
0
-6
2
MEST
0
2
2
MET
0
1
2
METDST
0
2
2
MEWT
0
1
2
MEZ
0
1
2
MHT
0
9
2
MMT
9
6.5
2
MST
0
-7
2
MT
9
8.5
2
MUT
0
4
2
MVT
0
5
2
NDT
9
-2.5
2
NFT
9
-3.5
2
NOR
0
1
2
NST
9
-3.5
2
NT
0
-11
2
NZDT
0
13
2
NZST
0
12
2
NZT
0
12
2
PDT
0
-7
2
PST
0
-8
2
RET
0
4
2
SADT
9
10.5
2
SAST
9
9.5
2
SCT
0
4
2
SET
0
1
2
SST
0
2
2
SWT
0
1
2
TFT
0
5
2
UT
0
0
2
UTC
0
0
2
WADT
0
8
2
WAST
0
7
2
WAT
0
-1
2
WDT
0
9
2
WET
0
0
2
WETDST
0
1
2
WST
0
8
2
YDT
0
-8
2
YST
0
-9
2
Z
0
0
2
ZULU
0
0
26
1
4
18
2
NZDT
2
CADT
2
SADT
2
WDT
2
WADT
2
EETDST
2
CETDST
2
METDST
2
WETDST
2
NDT
2
ADT
2
EDT
2
CDT
2
MDT
2
PDT
2
AKDT
2
YDT
2
HDT
26
1
#33
File Utilities
0
26
1
30
4
0
1
-1
4
0
2
_fix_mode
26
172
-1
open
5
172
-1
2
file_io_proto
api_prologue
2
1
37
26
0
4
4
4
8
2
p
2
The file utilities object (
4
2
2
var
2
$core.utility.file
2
) along with the file IO prototype object (
4
2
2
var
2
$core.file_io_proto
2
) define verbs that manipulate files. 
2
Children of the file IO prototype object represent files. File objects are garbage collected (and automatically closed) when no longer used (in other words, you don't have to explicitly worry about management and there's no chance of file handle leakage). 
2
A representative use case looks like this:
4
5
2
pre
2
f = $core.utility.file:open("foobar.txt", "r"); /* open for reading */
2
while ((line = f:readline()) != ".")
2
  ...
2
endwhile
4
2
2
p
2
Note the lack of an explicit operation to close the file.
4
4
2
p
2
See 
4
3
2
a
10
1
2
href
2
../file-io-proto
2
File IO Prototype
2
 for details on the file IO prototype.
26
1
#34
Object Utilities
16
26
1
30
4
0
1
-1
4
0
3
verbs*_suspended properties*_suspended
5
172
-1
change_owner
5
172
-1
all_contents*_suspended
26
172
-1
1
change_owner_permit_proto
1
1
36
26
0
#35
Permit Base Prototype
144
26
1
26
4
0
1
-1
4
1
1
36
2
create_for_subject
5
172
-1
permit
5
172
-1
1
subject
1
0
0
26
4
#36
Change Owner Permit Prototype
272
26
1
26
4
0
4
1
1
35
4
0
0
0
1
5
26
4
#37
File I/O Prototype
0
26
1
26
4
0
1
-1
4
0
10
initialize
5
172
-1
recycle
5
172
-1
_invalidate
26
172
-1
close
5
172
-1
is_open is_closed
26
172
-1
is_text is_binary
26
172
-1
is_readable is_writeable
26
172
-1
readline writeline read write
5
172
-1
tell seek size
5
172
-1
is_eof
5
172
-1
4
api_prologue
file_handle
epoch
mode
4
4
2
4
4
2
p
2
Children of the file IO prototype object (
4
2
2
var
2
$core.file_io_proto
2
) represent files. File objects are garbage collected (and automatically closed) when no longer used (in other words, you don't have to explicitly worry about management and there's no chance of file handle leakage).
4
4
2
p
2
See 
4
3
2
a
10
1
2
href
2
./utility/file
2
File Utilities
2
 for details how to open/read/write files.
26
1
0
-1
26
0
0
0
26
0
2

26
0
#38
Text Tools
0
38
1
-1
4
2
1
39
1
40
1
-1
4
0
0
11
identifier
version
manifest
relocate
requires
provides
instructions
description
authors
homepage
license
11
2
text_tools
38
1
2
0.0.1
38
1
4
3
4
2
1
38
2
package
4
2
1
39
2
changelog
4
2
1
40
2
patience_diff
38
1
4
0
38
1
4
2
4
1
2
kernel
4
2
2
primitive
2
>= 0.0.2
38
1
4
0
38
1
4
0
38
1
2
The Text Tools package provides tools for working with text.  Currently it only provides an implementation of the patience diff algorithm.
38
1
4
1
2
Todd Sundsted
38
1
2

38
1
2
FreeBSD License
38
1
#39
Changelog
0
38
1
38
4
0
1
-1
4
0
0
1
1338760427
1
2
Added patience diff.
38
1
#40
Patience Diff
0
38
1
38
4
0
4
1
1
4
4
0
6
_suspend_if_necessary
38
172
-1
_hash_lines
38
172
-1
_find_common_unique_lines
38
172
-1
_find_lcs
38
172
-1
_generate_diff
38
172
-1
diff
38
172
-1
1
default_hash_algo
2
2
md5
38
1
5
38
4
#41
Plastic, MOOcode Parser Toolkit Package
16
41
1
-1
4
33
1
42
1
43
1
44
1
45
1
46
1
47
1
48
1
49
1
50
1
51
1
52
1
53
1
54
1
55
1
56
1
57
1
58
1
59
1
60
1
61
1
62
1
63
1
64
1
65
1
66
1
67
1
68
1
69
1
70
1
71
1
72
1
73
1
74
1
-1
4
0
2
after_install
5
172
-1
before_uninstall
5
172
-1
11
identifier
version
manifest
relocate
requires
provides
instructions
description
authors
homepage
license
11
2
plastic
41
1
2
1.0.1
41
1
4
34
4
2
1
41
2
package
4
2
1
42
2
changelog
4
2
1
43
2
dictionary
4
2
1
44
2
utilities
4
2
1
45
2
plastic_base_object
4
2
1
46
2
compiler
4
2
1
47
2
printer
4
2
1
48
2
tokenizer_proto
4
2
1
49
2
parser_proto
4
2
1
50
2
symbol_proto
4
2
1
51
2
literal_proto
4
2
1
53
2
statement_proto
4
2
1
54
2
operator_proto
4
2
1
55
2
control_flow_statement_proto
4
2
1
57
2
assignment_operator_proto
4
2
1
58
2
compound_assignment_operator_proto
4
2
1
59
2
prefix_operator_proto
4
2
1
56
2
infix_operator_proto
4
2
1
52
2
name_proto
4
2
1
60
2
bracket_operator_proto
4
2
1
61
2
brace_operator_proto
4
2
1
62
2
if_statement_proto
4
2
1
63
2
invocation_operator_proto
4
2
1
64
2
verb_selector_operator_proto
4
2
1
65
2
property_selector_operator_proto
4
2
1
66
2
error_catching_operator_proto
4
2
1
67
2
traditional_ternary_operator_proto
4
2
1
68
2
for_statement_proto
4
2
1
69
2
loop_statement_proto
4
2
1
70
2
fork_statement_proto
4
2
1
71
2
try_statement_proto
4
2
1
72
2
positional_symbol_proto
4
2
1
73
2
sign_operator_proto
4
2
1
74
2
from_statement_proto
41
1
4
37
2
dictionary.utilities
2
dictionary.compiler
2
dictionary.printer
2
dictionary.tokenizer_proto
2
dictionary.parser_proto
2
dictionary.symbol_proto
2
dictionary.literal_proto
2
dictionary.statement_proto
2
dictionary.operator_proto
2
dictionary.control_flow_statement_proto
2
dictionary.assignment_operator_proto
2
dictionary.compound_assignment_operator_proto
2
dictionary.prefix_operator_proto
2
dictionary.infix_operator_proto
2
dictionary.name_proto
2
dictionary.bracket_operator_proto
2
dictionary.brace_operator_proto
2
dictionary.if_statement_proto
2
dictionary.invocation_operator_proto
2
dictionary.verb_selector_operator_proto
2
dictionary.property_selector_operator_proto
2
dictionary.error_catching_operator_proto
2
dictionary.traditional_ternary_operator_proto
2
dictionary.for_statement_proto
2
dictionary.loop_statement_proto
2
dictionary.fork_statement_proto
2
dictionary.try_statement_proto
2
dictionary.positional_symbol_proto
2
dictionary.sign_operator_proto
2
dictionary.from_statement_proto
2
utilities.plastic
2
compiler.plastic
2
printer.plastic
2
tokenizer_proto.plastic
2
parser_proto.plastic
2
parser_proto.object_utilities
2
symbol_proto.plastic
41
1
4
3
4
2
2
kernel
2
>= 1.1.1
4
2
2
core
2
>= 0.0.1
4
2
2
primitive
2
>= 0.0.6
41
1
4
0
41
1
4
1
2
install-namespace
41
1
2
Plastic is the MOOcode parser toolkit.  It comprises an extended MOOcode language parser and compiler, and is compatible with the Stunt verb language extension mechanism.
41
1
4
1
2
Todd Sundsted
41
1
2
http://stunt.io/packages/plastic
41
1
2
FreeBSD License
41
1
#42
Changelog
16
41
1
41
4
0
1
-1
4
0
0
28
1331063405
1354983225
1355404149
1355712101
1356480216
1357566908
1357566938
1357571633
1357582940
1357593496
1357603194
1357912180
1357918770
1358255777
1360449360
1365597610
1365597616
1372385956
1372597917
1372632764
1372821107
1372902738
1372904110
1373051394
1375100816
1375275924
1375275940
1375276941
28
2
Initial revision.
41
1
2
First-cut at migration from frobs to anonymous objects.
41
1
2
The first-cut is complete.
41
1
2
Added rudimentary traversal support.
41
1
2
Changed up object `r', `f' and `a' flags and added the `parse_all()' verb.
41
1
2
Created new version: 0.0.2.
41
1
2
Moved the code generation -- `:p()' verbs -- into a single verb.
41
1
2
Refactored common code into a base object.
41
1
2
Improved variable name collision avoidance.
41
1
2
Added support for inline comments.
41
1
2
Added support for compound assignment.
41
1
2
Added support for import.
41
1
2
Added support for `->' for loop syntax.
41
1
2
Created new version: 0.0.3.
41
1
2
Fixed the associativity of `&&', `||' and `**' operators.
41
1
2
Created new version: 0.0.4.
41
1
2
Added more suspend.
41
1
2
`!!' has higher precedence than assignment.
41
1
2
Fixed bug with semicolons in statements.
41
1
2
Fixed bug with the eol from empty lines infecting subsequent tokens.
41
1
2
Fixed bug with handling of function invocation.
41
1
2
Added support for importing an object property.
41
1
2
Allow `in' to be used as both a binary operator and keyword.
41
1
2
Created new version: 1.0.0.
41
1
2
Created new version: 1.0.1.
41
1
2
Moved common properties to `$plastic.symbol_proto'.
41
1
2
Made common properties "rwc".
41
1
2
`parse_all()' is now deprecated.
41
1
#43
Dictionary
16
41
1
41
4
0
1
-1
4
0
0
30
utilities
tokenizer_proto
parser_proto
symbol_proto
literal_proto
statement_proto
operator_proto
control_flow_statement_proto
assignment_operator_proto
compound_assignment_operator_proto
prefix_operator_proto
infix_operator_proto
name_proto
bracket_operator_proto
brace_operator_proto
if_statement_proto
invocation_operator_proto
verb_selector_operator_proto
property_selector_operator_proto
error_catching_operator_proto
traditional_ternary_operator_proto
for_statement_proto
loop_statement_proto
positional_symbol_proto
fork_statement_proto
try_statement_proto
sign_operator_proto
from_statement_proto
compiler
printer
30
1
44
41
1
1
48
41
1
1
49
41
1
1
50
41
1
1
51
41
1
1
53
41
1
1
54
41
1
1
55
41
1
1
57
41
1
1
58
41
1
1
59
41
1
1
56
41
1
1
52
41
1
1
60
41
1
1
61
41
1
1
62
41
1
1
63
41
1
1
64
41
1
1
65
41
1
1
66
41
1
1
67
41
1
1
68
41
1
1
69
41
1
1
72
41
1
1
70
41
1
1
71
41
1
1
73
41
1
1
74
41
1
1
46
41
1
1
47
41
1
#44
Plastic Utilities
16
41
1
41
4
0
1
-1
4
0
6
suspend_if_necessary
41
172
-1
parse_map_sequence
41
172
-1
parse_list_sequence
41
172
-1
validate_scattering_pattern
41
172
-1
children
41
172
-1
match
41
172
-1
1
plastic
1
1
43
41
0
#45
Plastic Base Object
0
41
1
41
4
0
1
-1
4
3
1
46
1
48
1
49
2
_ensure_prototype
41
172
-1
_ensure_instance
41
172
-1
0
0
#46
MOOcode Compiler
272
41
1
41
4
0
4
2
1
4
1
45
4
0
4
_lookup*_variable
41
172
-1
_generate*_unique
41
172
-1
compile c
41
172
-1
p
41
172
-1
4
plastic
reserved_names
builtin_names
variable_map
5
1
43
41
0
4
19
2
if
2
else
2
elseif
2
endif
2
for
2
in
2
endfor
2
fork
2
endfork
2
return
2
while
2
endwhile
2
try
2
except
2
finally
2
endtry
2
ANY
2
break
2
continue
41
1
4
20
2
player
2
this
2
caller
2
verb
2
argstr
2
args
2
dobjstr
2
dobj
2
prepstr
2
iobjstr
2
iobj
2
err
2
num
2
int
2
float
2
str
2
obj
2
list
2
map
2
anon
41
1
10
0
41
1
5
41
4
#47
Syntax Tree Pretty Printer
16
41
1
41
4
0
4
1
1
4
4
0
2
_print
41
172
-1
print p
41
172
-1
1
plastic
2
1
43
41
0
5
41
4
#48
Tokenizer Prototype
16
41
1
41
4
0
4
1
1
45
4
0
3
create
41
172
-1
advance
41
172
-1
token
41
172
-1
7
plastic
errors
row
column
source
first
token
7
1
43
41
0
10
19
2
E_ARGS
3
11
2
E_DIV
3
2
2
E_EXEC
3
17
2
E_FILE
3
16
2
E_FLOAT
3
15
2
E_INTRPT
3
18
2
E_INVARG
3
13
2
E_INVIND
3
7
2
E_MAXREC
3
9
2
E_NACC
3
12
2
E_NONE
3
0
2
E_PERM
3
3
2
E_PROPNF
3
4
2
E_QUOTA
3
14
2
E_RANGE
3
10
2
E_RECMOVE
3
8
2
E_TYPE
3
1
2
E_VARNF
3
6
2
E_VERBNF
3
5
41
0
0
1
41
1
0
1
41
1
4
0
41
0
0
1
41
1
10
0
41
0
#49
Parser Prototype
16
41
1
41
4
0
4
1
1
45
4
0
12
create
41
172
-1
symbol
41
172
-1
reserve_statement reserve_keyword
41
172
-1
make_identifier make_variable
41
172
-1
token
41
172
-1
advance
41
172
-1
expression
41
172
-1
statement
41
172
-1
statements
41
172
-1
parse_all
41
172
-1
push
41
172
-1
pop
41
172
-1
8
plastic
object_utilities
tokenizer
symbols
token
loop_variables
loop_depth
imports
8
1
43
41
0
1
34
41
0
1
-1
41
0
10
0
41
1
0
0
41
1
4
0
41
1
0
0
41
1
10
0
41
1
#50
Symbol Prototype
400
41
1
41
4
0
1
-1
4
6
1
51
1
52
1
54
1
60
1
61
1
72
4
create
41
172
-1
clone
41
172
-1
nud
41
172
-1
led
41
172
-1
14
plastic
id
type
bp
value
reserved
not_at_start
sol
eol
row
column
first
second
third
14
1
43
41
0
0
0
41
5
0
0
41
5
0
0
41
5
0
0
41
5
0
0
41
5
0
0
41
5
0
0
41
5
0
0
41
5
0
0
41
5
0
0
41
5
0
0
41
7
0
0
41
7
0
0
41
7
#51
Literal Prototype
272
41
1
41
4
0
4
1
1
50
4
0
1
nud
41
172
-1
0
14
5
41
0
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
7
5
41
7
5
41
7
#52
Name Prototype
272
41
1
41
4
0
4
1
1
50
4
1
1
53
1
nud
41
172
-1
0
14
5
41
0
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
7
5
41
7
5
41
7
#53
Statement Prototype
400
41
1
41
4
0
4
1
1
52
4
7
1
55
1
62
1
68
1
69
1
70
1
71
1
74
1
std
41
172
-1
0
14
5
41
0
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
7
5
41
7
5
41
7
#54
Operator Prototype
400
41
1
41
4
0
4
1
1
50
4
8
1
56
1
59
1
63
1
64
1
65
1
66
1
67
1
73
0
0
14
5
41
0
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
7
5
41
7
5
41
7
#55
Control Flow Statement Prototype
272
41
1
41
4
0
4
1
1
53
4
0
1
std
41
172
-1
0
14
5
41
0
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
7
5
41
7
5
41
7
#56
Infix Operator Prototype
400
41
1
41
4
0
4
1
1
54
4
2
1
57
1
58
1
led
41
172
-1
1
right
15
0
0
41
5
5
41
0
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
7
5
41
7
5
41
7
#57
Assignment Operator Prototype
272
41
1
41
4
0
4
1
1
56
4
0
1
led
41
172
-1
0
15
5
41
5
5
41
0
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
7
5
41
7
5
41
7
#58
Compound Assignment Operator Prototype
0
41
1
41
4
0
4
1
1
56
4
0
1
led
41
172
-1
0
15
5
41
5
5
41
0
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
7
5
41
7
5
41
7
#59
Prefix Operator Prototype
400
41
1
41
4
0
4
1
1
54
4
0
1
nud
41
172
-1
0
14
5
41
0
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
7
5
41
7
5
41
7
#60
Bracket Operator Prototype
272
41
1
41
4
0
4
1
1
50
4
0
2
nud
41
172
-1
led
41
172
-1
0
14
5
41
0
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
7
5
41
7
5
41
7
#61
Brace Operator Prototype
272
41
1
41
4
0
4
1
1
50
4
0
1
nud
41
172
-1
0
14
5
41
0
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
7
5
41
7
5
41
7
#62
If Statement Prototype
272
41
1
41
4
0
4
1
1
53
4
0
1
std
41
172
-1
0
14
5
41
0
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
7
5
41
7
5
41
7
#63
Invocation Operator Prototype
272
41
1
41
4
0
4
1
1
54
4
0
2
nud
41
172
-1
led
41
172
-1
0
14
5
41
0
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
7
5
41
7
5
41
7
#64
Verb Selector Operator Prototype
272
41
1
41
4
0
4
1
1
54
4
0
1
led
41
172
-1
0
14
5
41
0
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
7
5
41
7
5
41
7
#65
Property Selector Operator Prototype
272
41
1
41
4
0
4
1
1
54
4
0
1
led
41
172
-1
0
14
5
41
0
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
7
5
41
7
5
41
7
#66
Error Catching Operator Prototype
272
41
1
41
4
0
4
1
1
54
4
0
2
nud
41
172
-1
led
41
172
-1
0
14
5
41
0
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
7
5
41
7
5
41
7
#67
Traditional Ternary Operator Prototype
0
41
1
41
4
0
4
1
1
54
4
0
1
led
41
172
-1
0
14
5
41
0
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
7
5
41
7
5
41
7
#68
For Statement Prototype
272
41
1
41
4
0
4
1
1
53
4
0
1
std
41
172
-1
1
subtype
15
0
0
41
5
5
41
0
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
7
5
41
7
5
41
7
#69
Loop Statement Prototype
272
41
1
41
4
0
4
1
1
53
4
0
1
std
41
172
-1
0
14
5
41
0
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
7
5
41
7
5
41
7
#70
Fork Statement Prototype
272
41
1
41
4
0
4
1
1
53
4
0
1
std
41
172
-1
0
14
5
41
0
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
7
5
41
7
5
41
7
#71
Try Statement Prototype
272
41
1
41
4
0
4
1
1
53
4
0
1
std
41
172
-1
1
subtype
15
0
0
41
5
5
41
0
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
7
5
41
7
5
41
7
#72
Positional Symbol Prototype
272
41
1
41
4
0
4
1
1
50
4
0
1
nud
41
172
-1
0
14
5
41
0
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
7
5
41
7
5
41
7
#73
Sign Operator Prototype
0
41
1
41
4
0
4
1
1
54
4
0
2
nud
41
172
-1
led
41
172
-1
0
14
5
41
0
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
7
5
41
7
5
41
7
#74
From Statement Prototype
0
41
1
41
4
0
4
1
1
53
4
0
1
std
41
172
-1
0
14
5
41
0
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
5
5
41
7
5
41
7
5
41
7
#75
Blink, Structured Document Package
0
75
1
-1
4
10
1
76
1
77
1
78
1
79
1
80
1
81
1
82
1
83
1
84
1
85
4
1
1
27
4
0
0
2
api_prologue
api_epilogue
14
4
8
4
2
2
p
2
The Blink Package manipulates and formats structured documents.
4
8
2
p
2
The minimal Blink document is a list of items. The items in a Blink document are strings (
4
2
2
em
2
text
2
) and lists (
4
2
2
em
2
elements
2
). 
2
Text is a span of unadorned characters. An element is a complex structure that may contain enclosed text and nested elements. 
2
A full Blink document is a tree describing the attributes of and relationships between spans of text.
4
17
2
p
2
An 
4
2
2
em
2
element
2
 is a 
4
2
2
em
2
list
2
 with a specific structure. 
2
The first item in the list must be a 
4
2
2
em
2
string
2
 called the 
4
2
2
em
2
tag
2
. The tag specifies the type or class of the element. 
2
The second item in the list is optional. If present, it must be a 
4
2
2
em
2
map
2
 of attributes. The attributes are each key/value pairs of 
4
2
2
em
2
strings
2
 that refine the meaning of the tag. 
2
The remainder of the list contains enclosed text and nested elements.
4
7
2
p
2
A 
4
2
2
em
2
tag
2
 may be a simple string (a span of characters excluding the special characters "#" and "."). 
2
The special characters introduce a shorthand for two common attributes: "id" and "class", respectively. 
2
The tag "foo#bar" is shorthand for the tag "foo" with the attribute ["id" -> "bar"]. 
2
The tag "foo.bar" is shorthand for the tag "foo" with the attribute ["class" -> "bar"].
4
2
2
p
2
The first example illustrates a simple document composed entirely of text:
4
2
2
pre.example
4
2
2
code.language-moocode
2
{"this", "is", "a", "simple", "document"}
4
2
2
p
2
The second example illustrates a complex document composed of enclosed text and nested elements:
4
2
2
pre.example
4
2
2
code.language-moocode
2
{{"first#bang.bang", ["foo" -> "bar"], {"a"}, {"b", "1", "2", "3"}, "c"}, {"second", "x", "y", "z"}}
75
1
4
0
75
1
2
blink
75
5
2
0.0.1
75
5
4
11
4
2
1
75
2
package
4
2
1
76
2
changelog
4
2
1
77
2
dictionary
4
2
1
78
2
context_proto
4
2
1
79
2
validator_context_proto
4
2
1
80
2
sanitizer_context_proto
4
2
1
81
2
renderer_context_proto
4
2
1
82
2
render_as_text
4
2
1
83
2
render_as_ansi
4
2
1
84
2
render_as_html
4
2
1
85
2
utilities
75
5
4
8
2
dictionary.utilities
2
dictionary.render_as_text
2
dictionary.render_as_ansi
2
dictionary.render_as_html
2
utilities.context_proto
2
utilities.validator_context_proto
2
utilities.sanitizer_context_proto
2
context_proto.utilities
75
5
4
4
4
2
2
kernel
2
>= 1.1.5
4
2
2
primitive
2
>= 0.0.5
4
2
2
core
2
>= 0.0.2
4
2
2
plastic
2
= 1.0
75
5
5
75
5
4
1
2
install-namespace
75
5
5
75
5
5
75
5
5
75
5
5
75
5
5
75
4
#76
Changelog
0
75
1
75
4
0
1
-1
4
0
0
3
1365561944
1373163737
1373376914
3
2
Initial cut at basic functionality.
75
1
2
Created new version: 0.0.1.
75
1
2
Upgraded verbs to 1.0.0 of plastic syntax.
75
1
#77
Dictionary
16
75
1
75
4
0
1
-1
4
0
0
4
utilities
render_as_text
render_as_html
render_as_ansi
4
1
85
75
1
1
82
75
1
1
84
75
1
1
83
75
1
#78
Context Prototype
0
75
1
75
4
0
1
-1
4
3
1
79
1
80
1
81
3
is_parent_of
75
172
-1
handle_element
75
172
-1
handle_text
75
172
-1
2
utilities
parent
2
1
85
75
0
0
0
75
0
#79
Validator Context Prototype
0
75
1
75
4
0
4
1
1
78
4
0
2
handle_element
75
172
-1
handle_text
75
172
-1
0
2
5
75
0
5
75
0
#80
Sanitizer Context Prototype
0
75
1
75
4
0
4
1
1
78
4
0
2
handle_element
75
172
-1
handle_text
75
172
-1
1
lines
3
4
0
75
0
5
75
0
5
75
0
#81
Renderer Context Prototype
0
75
1
75
4
0
4
1
1
78
4
3
1
82
1
83
1
84
2
clone
75
172
-1
render
75
172
-1
3
style
lines
block_level
5
10
0
75
0
4
0
75
0
0
0
75
0
5
75
0
5
75
0
#82
Render as Text
0
75
1
75
4
0
4
1
1
81
4
0
2
handle_element
75
172
-1
handle_text
75
172
-1
0
5
10
8
2
h1
10
4
2
border
2
=
2
display
2
block
2
margin
2
bottom
2
transform
2
uppercase
2
h2
10
3
2
border
2
=
2
display
2
block
2
margin
2
bottom
2
h3
10
3
2
border
2
-
2
display
2
block
2
margin
2
bottom
2
h4
10
2
2
display
2
block
2
margin
2
bottom
2
h5
10
2
2
display
2
block
2
margin
2
bottom
2
h6
10
2
2
display
2
block
2
margin
2
bottom
2
p
10
2
2
display
2
block
2
margin
2
bottom
2
pre
10
4
2
display
2
block
2
indent
0
2
2
margin
2
bottom
2
whitespace
2
preserve
75
0
5
75
0
5
75
0
5
75
0
5
75
0
#83
Render as ANSI
0
75
1
75
4
0
4
1
1
81
4
0
3
handle_element
75
172
-1
handle_text
75
172
-1
_ansify
75
172
-1
1
style_stack
6
4
0
75
0
10
11
2
em
10
1
2
font-style
2
italic
2
h1
10
4
2
display
2
block
2
font-weight
2
bold
2
margin
2
bottom
2
transform
2
uppercase
2
h2
10
3
2
display
2
block
2
font-weight
2
bold
2
margin
2
bottom
2
h3
10
3
2
display
2
block
2
font-weight
2
bold
2
margin
2
bottom
2
h4
10
3
2
display
2
block
2
font-weight
2
bold
2
margin
2
bottom
2
h5
10
3
2
display
2
block
2
font-weight
2
bold
2
margin
2
bottom
2
h6
10
3
2
display
2
block
2
font-weight
2
bold
2
margin
2
bottom
2
p
10
2
2
display
2
block
2
margin
2
bottom
2
pre
10
4
2
display
2
block
2
indent
0
2
2
margin
2
bottom
2
whitespace
2
preserve
2
strong
10
1
2
font-weight
2
bold
2
var
10
1
2
font-style
2
italic
75
0
5
75
0
5
75
0
5
75
0
5
75
0
#84
Render as HTML
0
75
1
75
4
0
4
1
1
81
4
0
2
handle_element
75
172
-1
handle_text
75
172
-1
0
5
10
8
2
h1
10
1
2
display
2
block
2
h2
10
1
2
display
2
block
2
h3
10
1
2
display
2
block
2
h4
10
1
2
display
2
block
2
h5
10
1
2
display
2
block
2
h6
10
1
2
display
2
block
2
p
10
1
2
display
2
block
2
pre
10
2
2
display
2
block
2
whitespace
2
preserve
75
0
5
75
0
5
75
0
5
75
0
5
75
0
#85
Blink Utilities
0
75
1
75
4
0
1
-1
4
0
7
_context_and_schema
75
172
-1
parse_element
75
172
-1
lookup_element
75
172
-1
traverse
75
172
-1
validate
75
172
-1
sanitize
75
172
-1
strip
75
172
-1
4
context_proto
default_schema
validator_context_proto
sanitizer_context_proto
4
1
78
75
0
10
17
2
a
10
2
2
attributes
4
3
2
href
2
rel
2
class
2
tags
4
5
2
var
2
em
2
strong
2
span
2
code
2
article
10
2
2
attributes
4
1
2
class
2
tags
4
17
2
div
2
section
2
article
2
h1
2
h2
2
h3
2
h4
2
h5
2
h6
2
p
2
pre
2
a
2
var
2
em
2
strong
2
span
2
code
2
code
10
2
2
attributes
4
1
2
class
2
tags
4
6
2
a
2
var
2
em
2
strong
2
span
2
code
2
div
10
2
2
attributes
4
1
2
class
2
tags
4
17
2
div
2
section
2
article
2
h1
2
h2
2
h3
2
h4
2
h5
2
h6
2
p
2
pre
2
a
2
var
2
em
2
strong
2
span
2
code
2
em
10
2
2
attributes
4
1
2
class
2
tags
4
6
2
a
2
var
2
em
2
strong
2
span
2
code
2
h1
10
2
2
attributes
4
1
2
class
2
tags
4
6
2
a
2
var
2
em
2
strong
2
span
2
code
2
h2
10
2
2
attributes
4
1
2
class
2
tags
4
6
2
a
2
var
2
em
2
strong
2
span
2
code
2
h3
10
2
2
attributes
4
1
2
class
2
tags
4
6
2
a
2
var
2
em
2
strong
2
span
2
code
2
h4
10
2
2
attributes
4
1
2
class
2
tags
4
6
2
a
2
var
2
em
2
strong
2
span
2
code
2
h5
10
2
2
attributes
4
1
2
class
2
tags
4
6
2
a
2
var
2
em
2
strong
2
span
2
code
2
h6
10
2
2
attributes
4
1
2
class
2
tags
4
6
2
a
2
var
2
em
2
strong
2
span
2
code
2
p
10
2
2
attributes
4
1
2
class
2
tags
4
6
2
a
2
var
2
em
2
strong
2
span
2
code
2
pre
10
2
2
attributes
4
1
2
class
2
tags
4
6
2
a
2
var
2
em
2
strong
2
span
2
code
2
section
10
2
2
attributes
4
1
2
class
2
tags
4
17
2
div
2
section
2
article
2
h1
2
h2
2
h3
2
h4
2
h5
2
h6
2
p
2
pre
2
a
2
var
2
em
2
strong
2
span
2
code
2
span
10
2
2
attributes
4
1
2
class
2
tags
4
6
2
a
2
var
2
em
2
strong
2
span
2
code
2
strong
10
2
2
attributes
4
1
2
class
2
tags
4
6
2
a
2
var
2
em
2
strong
2
span
2
code
2
var
10
2
2
attributes
4
1
2
class
2
tags
4
5
2
a
2
em
2
strong
2
span
2
code
75
1
1
79
75
0
1
80
75
0
#86
Alt, Player Package
0
86
1
-1
4
6
1
87
1
88
1
89
1
90
1
91
1
92
1
-1
4
0
0
11
identifier
version
manifest
relocate
requires
provides
instructions
description
authors
homepage
license
11
2
alt
86
1
2
0.0.4
86
1
4
7
4
2
1
86
2
package
4
2
1
87
2
changelog
4
2
1
88
2
dictionary
4
2
1
89
2
player_utilities
4
2
1
90
2
player_proto
4
2
1
91
2
programmer_proto
4
2
1
92
2
wizard_proto
86
1
4
3
2
dictionary.player_proto
2
dictionary.programmer_proto
2
dictionary.wizard_proto
86
1
4
6
4
2
2
kernel
2
>= 1.0.4
4
2
2
primitive
2
>= 0.0.2
4
2
2
core
2
>= 0.0.1
4
2
2
text_tools
2
>= 0.0.1
4
2
2
blink
2
>= 0.0.0
4
2
2
plastic
2
= 1.0
86
1
4
0
86
1
4
1
2
install-namespace
86
1
2
The Alt Package contains the basic player hierarchy and defines a basic set of VR verbs.
86
1
4
1
2
Todd Sundsted
86
1
2
http://stunt.io/packages/alt
86
1
2
FreeBSD License
86
1
#87
Changelog
0
86
1
86
4
0
1
-1
4
0
0
22
1333837145
1333839422
1338036321
1338208126
1338895941
1341148790
1341149402
1341174341
1341176019
1341179018
1341187815
1343595533
1351446849
1354988315
1355922371
1356876578
1358258161
1358258653
1365860307
1373099765
1375276836
1375359567
22
2
`match_verb()'/`match_property()' now match on "me" and "here".
86
1
2
Removed `utilities' property from `$player_proto'; using `$lookup()' instead.
86
1
2
In `set_verb_code()', the fourth arg is the content type.
86
1
2
Don't program verb if nothing changed.
86
1
2
Added `@diff/@difference' command verb.
86
1
2
Added argstr tail processing.
86
1
2
Made `@inspect' output much more attractive.
86
1
2
Improved property handling in `@list'/`@edit' and `@program'.
86
1
2
Fixed the verb-not-found case in `@diff'.
86
1
2
Added  `@commit' and `@revert'.
86
1
2
`@program' snarfs lines early to avoid accidental commands.
86
1
2
Fixed many usability problems with the `@inspect' command verb.
86
1
2
A few tweaks to make `@inspect' et al work better with anonymous objects.
86
1
2
Major revamp of `evaluate'.
86
1
2
Added `@shutdown' command verb.
86
1
2
Added support for object matching on bindings.
86
1
2
Created new version: 0.0.4.
86
1
2
Include the last result as underscore ("_").
86
1
2
Added `notify()' verb and support for rich output.
86
1
2
Upgraded verbs to 1.0.0 of plastic syntax.
86
1
2
Call `statements()' instead of (deprecated) `parse_all()'.
86
1
2
Removed permit.
86
1
#88
Dictionary
0
86
1
86
4
0
1
-1
4
0
0
3
player_proto
programmer_proto
wizard_proto
3
1
90
86
1
1
91
86
1
1
92
86
1
#89
Player Utilities
0
86
1
86
4
0
1
-1
4
0
5
match_verb match_property
5
172
-1
match_object
5
172
-1
_player_controls_verb _player_controls_property
5
172
-1
_player_controls_object
5
172
-1
extract_tail
86
172
-1
0
0
#90
Player Prototype
144
86
1
86
4
0
4
1
1
4
4
1
1
91
3
huh
5
172
-1
notify tell
5
172
-1
@quit
5
8
-1
1
alt_display_options
2
10
0
86
4
5
86
4
#91
Programmer Prototype
16
86
1
86
4
0
4
1
1
90
4
2
1
92
1
6
7
_parse
5
172
-1
eval*uate
5
88
-2
@list @edit
5
24
-1
@program
5
88
-2
@in*spect
5
24
-1
@diff*erence
5
24
-1
@commit @revert
5
24
-1
1
alt_bindings
3
10
0
86
4
5
86
4
5
86
4
#92
Wizard Prototype
0
86
1
86
4
0
4
1
1
91
4
1
1
5
1
@shutdown
5
8
-1
0
3
5
86
4
5
86
4
5
86
4
#93
Identity Package
0
93
1
-1
4
5
1
94
1
95
1
96
1
97
1
98
1
-1
4
0
0
11
identifier
version
manifest
relocate
requires
provides
instructions
description
authors
homepage
license
11
2
identity
93
1
2
0.0.3
93
1
4
6
4
2
1
93
2
package
4
2
1
94
2
changelog
4
2
1
95
2
dictionary
4
2
1
96
2
authenticatable
4
2
1
97
2
utilities
4
2
1
98
2
namespace
93
1
4
3
2
dictionary.authenticatable
2
dictionary.identity
2
namespace.utilities
93
1
4
1
4
2
2
kernel
2
>= 1.0.4
93
1
4
0
93
1
4
1
2
install-dictionary
93
1
2
The identity package provides mechanisms for establishing player/user identity.
93
1
4
1
2
Todd Sundsted
93
1
2
http://stunt.io/packages/identity
93
1
2
FreeBSD License
93
1
#94
Changelog
0
93
1
93
4
0
1
-1
4
0
0
6
1311598736
1336418462
1336419186
1339591932
1360581412
1360581442
6
2
Improved the fixed-time hash comparison in $authenticatable.
93
1
2
Moved utility verbs from the `$authenticatable' prototype mixin.
93
1
2
Updated `$authenticate()' to use the new utility verbs.
93
1
2
Added the `@password' command verb.
93
1
2
Created new version: 0.0.3.
93
1
2
Fixed bug in identifying descendants.
93
1
#95
Dictionary
0
93
1
93
4
0
1
-1
4
1
1
0
1
authenticate
5
172
-1
2
authenticatable
identity
2
1
96
93
1
1
98
93
1
#96
Authenticatable
0
93
1
93
4
0
4
1
1
4
4
2
1
5
1
6
1
@password
5
8
-1
1
hashed_password
2
10
0
5
0
5
93
4
#97
Identity Utilities
0
93
1
93
4
0
4
1
1
4
4
0
2
verify_hashed_password
93
172
-1
hash_password
93
172
-1
0
1
5
93
4
#98
Identity Namespace
0
93
1
93
4
0
1
-1
4
0
0
1
utilities
1
1
97
93
1
#99
Ask, Query Package
0
99
1
-1
4
3
1
100
1
101
1
102
1
-1
4
0
0
11
identifier
version
manifest
relocate
requires
provides
instructions
description
authors
homepage
license
11
2
ask
99
1
2
0.0.2
99
1
4
5
4
2
1
99
2
package
4
2
1
100
2
changelog
4
2
1
101
2
dictionary
4
2
1
102
2
ask_proto
4
2
12
149
2
query_utilities
99
1
4
4
2
dictionary.ask_proto
2
dictionary.ask
2
ask_proto.query_utilities
2
query_utilities.ask_proto
99
1
4
2
4
1
2
kernel
4
2
2
primitive
2
>= 0.0.2
99
1
4
0
99
1
4
1
2
install-dictionary
99
1
2
Ask implements queries based on relational algebra.
99
1
4
1
2
Todd Sundsted
99
1
2

99
1
2
FreeBSD License
99
1
#100
Changelog
0
99
1
99
4
0
1
-1
4
0
0
9
1338507037
1339588745
1341490029
1341492308
1341572860
1341574954
1341628401
1351463659
1360331541
9
2
First cut at `$ask'.
99
1
2
Replaced magic string "#" with `$ask:id()'/`$ask_proto.id'.
99
1
2
Instead of failing, return information about low-level (E_PERM, etc.) errors.
99
1
2
Added support for predicates with objects numbers.
99
1
2
Added support for predicates "is true"/"is false".
99
1
2
Added support for more logical operators.
99
1
2
Added support for the string matching operator.
99
1
2
Migrated from frob to anonymous object.
99
1
2
Fixed bug with underscores in identifier matching.
99
1
#101
Dictionary
0
99
1
99
4
0
1
-1
4
1
1
0
0
2
ask_proto
ask
2
1
102
99
1
1
102
99
1
#102
Ask Prototype
16
99
1
99
4
0
1
-1
4
0
9
_match_literal_or_identifier
99
172
-1
_match_operator
99
172
-1
_parse_predicate
99
172
-1
from
99
172
-1
select
99
172
-1
where
99
172
-1
count
99
172
-1
all
99
172
-1
one
99
172
-1
5
query_utilities
from
operations
ID
ERRORS
5
12
149
99
0
0
0
99
0
0
0
99
0
1
-7
99
1
1
-11
99
1
#103
Persistent Package
0
103
1
-1
4
3
1
104
1
105
1
106
1
-1
4
0
0
10
identifier
version
manifest
relocate
requires
instructions
description
authors
homepage
license
10
2
persistent
103
1
2
0.0.2
103
1
4
4
4
2
1
103
2
package
4
2
1
104
2
changelog
4
2
1
105
2
dictionary
4
2
1
106
2
attachable
103
1
4
1
2
dictionary.attachable
103
1
4
1
4
2
2
kernel
2
>= 1.0.6
103
1
4
1
2
install-dictionary
103
1
2
Persistent creates and manages the associated Stunt filesystem.  The package includes the $attachable mixin.
103
1
4
1
2
Todd Sundsted
103
1
2
http://stunt.io/packages/persistent
103
1
2
FreeBSD License
103
1
#104
Changelog
0
103
1
103
4
0
1
-1
4
0
0
5
1312670738
1313453111
1321630702
1329737917
1343820926
5
2
Added $attachable/Attachable.
103
1
2
Create directory structure under files/ on startup.
103
1
2
Cleanup in $attachable.  Removed use of `call_function()'.  Deal with missing helper executables better.
103
1
2
Updated code to use new `for' loop functionality.
103
1
2
Massive rework on `$attachable'.
103
1
#105
Dictionary
0
103
1
103
4
0
1
-1
4
1
1
0
1
server_started
5
172
-1
1
attachable
1
1
106
103
1
#106
Attachable
128
103
1
103
4
0
4
1
1
4
4
0
11
attachments
103
172
-1
attachment
5
172
-1
check_attachment
5
172
-1
recycle
5
172
-1
_path_for
5
172
-1
add_attachment
5
172
-1
add_attachment_from_tmp_file
5
172
-1
delete_attachment
5
172
-1
_identify
5
172
-1
_thumbnail
5
172
-1
_check_limit
103
172
-1
3
attachment_pools
attachments
attachment_limit
4
10
2
2
private
2
private/app
2
public
2
public/app
103
0
10
0
103
0
0
4
103
1
5
103
4
#107
Model Package
0
107
1
-1
4
9
1
108
1
109
1
110
1
111
1
112
1
113
1
114
1
115
1
116
1
-1
4
0
0
11
identifier
version
manifest
relocate
requires
provides
instructions
description
authors
homepage
license
11
2
model
107
1
2
0.0.1
107
1
4
10
4
2
1
107
2
package
4
2
1
108
2
dictionary
4
2
1
109
2
changelog
4
2
1
110
2
model_proto
4
2
1
111
2
constraint
4
2
1
112
2
validates_presence_of
4
2
1
113
2
validates_uniqueness_of
4
2
1
114
2
validates_immutability_of
4
2
1
115
2
validates_format_of
4
2
1
116
2
validates_revision_of
107
1
4
7
2
dictionary.model_proto
2
dictionary.constraint
2
dictionary.validates_presence_of
2
dictionary.validates_uniqueness_of
2
dictionary.validates_immutability_of
2
dictionary.validates_format_of
2
dictionary.validates_revision_of
107
1
4
2
4
1
2
kernel
4
2
2
ask
2
>= 0.0.1
107
1
4
0
107
1
4
1
2
install-namespace
107
1
2

107
1
4
0
107
1
2

107
1
2

107
1
#108
Dictionary
0
107
1
107
4
0
1
-1
4
0
6
validate
5
172
-1
create
5
172
-1
update
5
172
-1
read
5
172
-1
_before_* _after_*
5
172
-1
find find_by_*
107
172
-1
9
model_proto
constraint
id
errors
validates_presence_of
validates_uniqueness_of
validates_immutability_of
validates_format_of
validates_revision_of
9
1
110
107
1
1
111
107
1
1
-7
107
1
1
-11
107
1
1
112
107
1
1
113
107
1
1
114
107
1
1
115
107
1
1
116
107
1
#109
Changelog
0
107
1
107
4
0
1
-1
4
0
0
19
1316329109
1316332819
1317981980
1318420551
1320746708
1321644116
1321732614
1321750566
1339414278
1339498645
1339498974
1339505506
1339505587
1339507058
1339581632
1339581896
1339589892
1341418035
1343621398
19
2
Added package installation instructions.
107
1
2
Fixed validation breakage related to map operation changes.
107
1
2
Model create/update now uses $shape to write values -- normalizes `location' et al.
107
1
2
Verb `find_by_*' now uses $ask.
107
1
2
Updated package information.
107
1
2
Loosened the coupling between model actions and the model prototype object.  Added custom `respond_to()' verb.  Format validation now takes "pattern" instead of "regex".
107
1
2
Renamed model verb `show()' to `read()'.
107
1
2
Return the canonical representation on create/update.  Handle a few errors better.
107
1
2
Major rewrite.  Fixed magic markers for errors and object number/id.  Removed custom `respond_to()' verb.
107
1
2
Moved verbs from `$model.model' to `$model'.
107
1
2
Renamed `$model.model' to `$model.model_proto'.
107
1
2
Cleaned up `find()'.
107
1
2
Added prototype and instance delegation.
107
1
2
`update()' and `read()' now work with descendants and children.
107
1
2
`$model.validates_presence_of' is now forgiving if the property is set.
107
1
2
Added `$model.validates_revision_of'.
107
1
2
`$model:find()' and `$model:find_by_*()' automatically select accessible properties.
107
1
2
`validates_format_of()' handles the empty string correctly.
107
1
2
Validations improvements/fixes.
107
1
#110
Model Prototype
128
107
1
107
4
0
4
1
1
4
4
0
2
create find find_by_*
5
172
-1
validate update read
5
172
-1
2
accessible
constraints
3
4
0
107
5
10
0
107
5
5
107
4
#111
Constraint Prototype
0
107
1
107
4
0
4
1
1
4
4
5
1
112
1
113
1
114
1
115
1
116
3
validate
107
172
-1
add_error
107
172
-1
is_blank is_present
5
172
-1
0
1
5
107
4
#112
Validates Presence Of
0
107
1
107
4
0
4
1
1
111
4
0
1
validate
5
172
-1
0
1
5
107
4
#113
Validates Uniqueness Of
0
107
1
107
4
0
4
1
1
111
4
0
1
validate
5
172
-1
0
1
5
107
4
#114
Validates Immutability Of
0
107
1
107
4
0
4
1
1
111
4
0
1
validate
5
172
-1
0
1
5
107
4
#115
Validates Format Of
0
107
1
107
4
0
4
1
1
111
4
0
1
validate
107
172
-1
0
1
5
107
4
#116
Validates Revision Of
0
107
1
107
4
0
4
1
1
111
4
0
1
validate
5
172
-1
0
1
5
107
4
#117
Dialog, Web Server Package
0
117
1
-1
4
9
1
118
1
119
1
120
1
121
1
122
1
123
1
124
1
125
1
126
1
-1
4
0
2
after_install
5
172
-1
before_uninstall
5
172
-1
10
identifier
version
manifest
relocate
requires
instructions
description
authors
homepage
license
10
2
dialog
117
1
2
0.1.2
117
1
4
10
4
2
1
117
2
package
4
2
1
118
2
changelog
4
2
1
119
2
dictionary
4
2
1
120
2
utilities
4
2
1
121
2
server
4
2
1
122
2
request_proto
4
2
1
123
2
response_proto
4
2
1
124
2
route_proto
4
2
1
125
2
handler_proto
4
2
1
126
2
player_in_session
117
1
4
12
2
dictionary.utilities
2
dictionary.server
2
dictionary.request_proto
2
dictionary.response_proto
2
dictionary.route_proto
2
dictionary.handler_proto
2
dictionary.player_in_session
2
server.utilities
2
server.request_proto
2
server.response_proto
2
server.route_proto
2
utilities.time
117
1
4
4
4
2
2
kernel
2
>= 1.0.6
4
2
2
primitive
2
>= 0.0.4
4
2
2
core
2
>= 0.0.2
4
2
2
plastic
2
= 1.0
117
1
4
1
2
install-namespace
117
1
2
Dialog is the Stunt HTTP server.
117
1
4
1
2
Todd Sundsted
117
1
2
http://stunt.io/packages/dialog
117
1
2
FreeBSD License
117
1
#118
Changelog
0
117
1
117
4
0
1
-1
4
0
0
56
1316094194
1316358449
1318324724
1318324757
1318346368
1319025413
1319025667
1319388751
1319388831
1329657368
1329684677
1331257920
1331258266
1331905594
1331908171
1332104162
1332104693
1332106296
1332244717
1335621656
1336318579
1336480647
1336702845
1336991408
1337168940
1337216616
1337248289
1337250774
1337429755
1337431122
1337449915
1337453002
1341097958
1341100432
1341103044
1341232003
1341314273
1341320216
1343504254
1343580292
1343586836
1343591641
1354983271
1358819301
1358861187
1358861512
1359226185
1359377595
1359645935
1359910125
1359911101
1359985161
1369576436
1373400695
1373400726
1373400731
56
2
Added HTTP server framework (basic) including external file serving, routing to object/verb handlers and a database example.
117
1
2
Unescape URL encoded POST data.
117
1
2
Modified HTTP server `session()' verb to get session from task local value.
117
1
2
Modified HTTP server `internal()' verb to properly set `player' and perms.
117
1
2
Removed player()/set_player() from request; moved authenticated player persistence into task local storage.
117
1
2
Refactored HTTP server chaining; support external chain steps; removed upgrade from default chain; added external log and upgrade steps.
117
1
2
Removed internal dependency on storing the player in the HTTP session.
117
1
2
The HTTP server `external()' verb looks up mime type by extension and by exec'ing `identify'.
117
1
2
`_do_chain()' tries to be smarter about cleanup on error.
117
1
2
Moved HTTP status codes into a property.
117
1
2
Removed `external()' and renamed `internal()' to `serve()'.
117
1
2
Added a configurable session cookie name.
117
1
2
Fixed the ownership and perms of `key'.
117
1
2
Handle too-large bodies in cleanup.
117
1
2
Added better diagnostics in session validation.
117
1
2
Added support for flash socket policy file requests.
117
1
2
Fixed the handling of upgrade requests.
117
1
2
Renamed "route" to "route_proto" in all the right places.
117
1
2
Moved the flash socket policy logic back into `do_login_command()'.
117
1
2
Explicitly send a content length of zero (0) when the body is empty.  Safari seems to want this on redirects.
117
1
2
Package dictionary now has no parents.
117
1
2
Limit parameters map to 1000 items to foil DOS attacks.
117
1
2
Removed redundant code from `parse_query_string()'.
117
1
2
Added support for a synchronizer-style authenticity token.  Refactored the session code.  Fixed tests.
117
1
2
Roll the player step in the chain into the session step.
117
1
2
More useful error messages when chaining fails.
117
1
2
Broadened the 404/500 verb to handle (almost) any status.
117
1
2
Added authenticity token and player information as convenience parameters.
117
1
2
Handle bad requests more gracefully.
117
1
2
Added Server header to response.
117
1
2
Strip out query/body parameters that begin with "__".
117
1
2
Added Date header.
117
1
2
Force peeked-at input on the _front_ of the queue.
117
1
2
Surround system/convenience parameters with double-underscores.
117
1
2
Add `__xhr__' and `__url_base__' system/convenience parameters.
117
1
2
Strip parameters that begin with double-underscores.
117
1
2
Handle form data parameters more securely.
117
1
2
Handle request media type parameters
117
1
2
The session cookie must be http only.
117
1
2
Add `__ssh__' and `__remote_client__' system/convenience parameters.
117
1
2
Added timezone adjustments.
117
1
2
Fixed error properly closing files.
117
1
2
First-cut at migration from frobs to anonymous objects.
117
1
2
Created new version: 0.1.1.
117
1
2
Fixed the It Works! page.
117
1
2
Added basic response helpers.
117
1
2
Fixed handling of unescaping unprintable characters.
117
1
2
Added `forbidden()' response helper.
117
1
2
Added `not_acceptable()' response helper.
117
1
2
Added `request_entity_too_large()' response helper.
117
1
2
Added `bad_request()' response helper.
117
1
2
Fixed a naming bug with authenticity token.
117
1
2
Got rid of the stacktrace on timeout.
117
1
2
Created new version: 0.1.2.
117
1
2
Fixed a bug in parameter processing during tests.
117
1
2
Upgraded verbs to 1.0.0 of plastic syntax.
117
1
#119
Dialog Dictionary
0
117
1
117
4
0
1
-1
4
0
0
7
server
request_proto
response_proto
route_proto
handler_proto
utilities
player_in_session
7
1
121
117
1
1
122
117
1
1
123
117
1
1
124
117
1
1
125
117
1
1
120
117
1
1
126
117
1
#120
Dialog Utilities
0
117
1
117
4
0
4
1
1
4
4
0
4
generate_query_string
117
172
-1
parse_query_string
117
172
-1
escape
117
172
-1
unescape
117
172
-1
3
time
reserved
escaped
4
1
32
117
0
4
19
2
!
2
*
2
'
2
(
2
)
2
;
2
:
2
@
2
&
2
=
2
+
2
$
2
,
2
/
2
?
2
#
2
[
2
]
2
 
117
1
4
19
2
%21
2
%2A
2
%27
2
%28
2
%29
2
%3B
2
%3A
2
%40
2
%26
2
%3D
2
%2B
2
%24
2
%2C
2
%2F
2
%3F
2
%23
2
%5B
2
%5D
2
+
117
1
5
117
4
#121
HTTP Server
0
117
1
117
4
1
1
127
4
1
1
4
4
1
1
142
22
_log
5
172
-1
_key
117
172
-1
start
5
172
-1
stop
5
172
-1
_read_http
5
172
-1
_notify
5
172
-1
_session_cookie_name _flash_socket_policy
5
172
-1
_read_from_connection
117
172
-1
_write_to_connection
117
172
-1
_do_request
117
172
-1
do_login_command
5
172
-1
session
5
172
-1
route
117
172
-1
parameters
5
172
-1
protect_from_forgery
5
172
-1
serve
5
172
-1
cleanup
5
172
-1
2* 3* 4* 5*
117
172
-1
traceback
117
172
-1
trampoline
5
172
-1
_drop_perms_and_call_verb
5
172
-1
_do_chain
5
172
-1
10
port
key
default_chain
utilities
request_proto
response_proto
route_proto
status_codes
session_cookie_name
flash_socket_policy
11
0
8888
117
1
0
0
117
0
4
7
2
session
2
parameters
2
protect_from_forgery
2
route
2
serve
2
cleanup
2
404
117
4
1
120
117
0
1
122
117
1
1
123
117
1
1
124
117
1
10
13
0
200
2
Ok
0
201
2
Created
0
204
2
No Content
0
302
2
Moved
0
304
2
Not Modified
0
400
2
Bad Request
0
403
2
Forbidden
0
404
2
Not Found
0
406
2
Not Acceptable
0
413
2
Request Entity Too Large
0
415
2
Unsupported Media Type
0
422
2
Unprocessable Entity
0
500
2
Server Error
117
1
2
_stunt_session
117
4
0
0
117
4
5
117
4
#122
HTTP Request Prototype
272
117
1
117
4
0
1
-1
4
0
9
method uri headers body upgrade parameters handler exception
117
172
-1
set_method set_uri set_headers set_body set_upgrade set_parameters set_handler set_exception
117
172
-1
cookies
117
172
-1
path
117
172
-1
query
117
172
-1
type
117
172
-1
set_type
117
172
-1
length
117
172
-1
set_length
117
172
-1
8
method
uri
headers
body
upgrade
parameters
handler
exception
8
0
0
117
0
0
0
117
0
10
0
117
0
0
0
117
0
0
0
117
0
10
0
117
0
4
0
117
0
0
0
117
0
#123
HTTP Response Prototype
272
117
1
117
4
0
1
-1
4
0
6
status headers body
117
172
-1
set_status set_headers set_body
117
172
-1
type
117
172
-1
set_type
117
172
-1
length location
117
172
-1
set_length set_location
117
172
-1
3
status
headers
body
3
0
0
117
0
10
0
117
0
0
0
117
0
#124
HTTP Route Prototype
0
117
1
117
4
0
4
1
1
4
4
4
1
127
1
130
1
131
1
148
1
match
117
172
-1
0
1
5
117
4
#125
Base Handler Prototype
0
117
1
117
4
0
1
-1
4
0
11
_request
5
172
-1
_response
5
172
-1
_ensure_once
117
172
-1
200 ok
117
172
-1
400 bad_request
117
172
-1
403 forbidden
117
172
-1
404 not_found
117
172
-1
406 not_acceptable
117
172
-1
413 request_entity_too_large
117
172
-1
500 server_error
117
172
-1
302 moved
117
172
-1
4
_ensure_once
session
request
response
4
0
0
117
0
10
0
117
0
0
0
117
4
0
0
117
4
#126
Player in Session Capability
0
117
1
117
4
0
1
-1
4
0
2
set_player
5
172
-1
player
5
172
-1
1
prototypes
1
4
0
5
0
#127
It Works!
0
117
1
121
4
0
4
1
1
124
4
0
2
match
117
172
-1
it_works!
117
172
-1
0
1
5
117
4
#128
Dialog, Extras
0
128
1
-1
4
6
1
129
1
130
1
131
1
132
1
133
1
134
1
-1
4
0
0
10
identifier
version
manifest
relocate
requires
instructions
description
authors
homepage
license
10
2
dialog_extras
128
1
2
0.0.7
128
1
4
7
4
2
1
128
2
package
4
2
1
129
2
changelog
4
2
1
130
2
file_server
4
2
1
131
2
database_server
4
2
1
132
2
streaming_handler
4
2
1
133
2
logger
4
2
1
134
2
view_helpers
128
1
4
4
2
file_server.database_server
2
database_server.file_server
2
view_helpers.file_server
2
view_helpers.database_server
128
1
4
5
4
2
2
kernel
2
>= 1.0.7
4
2
2
primitive
2
>= 0.0.6
4
2
2
core
2
>= 0.0.2
4
2
2
dialog
2
>= 0.0.2
4
2
2
plastic
2
= 1.0
128
1
4
0
128
1
2
The Dialog Extras package contains objects that extend Dialog: file server, db object server, upgrade protocol handler, and logger.
128
1
4
1
2
Todd Sundsted
128
1
2
http://stunt.io/packages/dialog_extras
128
1
2
FreeBSD License
128
1
#129
Changelog
0
128
1
128
4
0
1
-1
4
0
0
17
1335730720
1337172128
1337341716
1337342502
1337441502
1337453415
1341098950
1341100432
1343584453
1343591641
1358988229
1360243978
1369817724
1369819857
1369916044
1373400631
1373400666
17
2
Deal with a few more errors in static file routing.
128
1
2
Deal with unparseable object numbers.
128
1
2
Smartened up the database POST, PUT and DELETE verbs.
128
1
2
Don't let invalid players create objects.
128
1
2
Prevent `index.html' file serving from shadowing `///' (the database handler path prefix).
128
1
2
Added last-modified and if-modified-since support.
128
1
2
Support "swf" and "htm" extensions.
128
1
2
Surround system/convenience parameters with double-underscores.
128
1
2
Log the correct client IP address.
128
1
2
Fixed error properly closing files.
128
1
2
Log request duration.
128
1
2
Added helpers for the authenticity token.
128
1
2
Created new version: 0.0.6.
128
1
2
Depends on escaping in `$str_proto' now.
128
1
2
Added helpers for the service url.
128
1
2
Created new version: 0.0.7.
128
1
2
Upgraded verbs to 1.0.0 of plastic syntax.
128
1
#130
HTTP File Server
0
128
1
128
4
0
4
1
1
124
4
1
1
143
2
match
5
172
-1
get
5
172
-1
1
database_server
2
1
131
128
0
5
128
4
#131
HTTP Database Server
0
128
1
128
4
0
4
1
1
124
4
1
1
144
7
match
128
172
-1
_match_uri
128
172
-1
_toobj
128
172
-1
get
5
172
-1
put
5
172
-1
post
5
172
-1
delete
5
172
-1
2
file_server
prefix
3
1
130
128
0
2
/:/
128
1
5
128
4
#132
HTTP Streaming Handler
0
128
1
128
4
0
4
1
1
4
4
1
1
142
2
do_socket
5
172
-1
do_long_poll
5
172
-1
1
description
2
2
HTTP streaming handlers for player interaction.  Currently socket based and long-polling.
128
1
5
128
4
#133
HTTP Logger
0
128
1
128
4
0
4
1
1
4
4
1
1
142
1
log
5
172
-1
0
1
5
128
4
#134
View Helpers
0
128
1
128
4
0
1
-1
4
1
1
146
5
authenticity_token
134
172
-1
authenticity_token_meta_tag
134
172
-1
authenticity_token_form_input
134
172
-1
service_url
128
172
-1
service_url_meta_tag
128
172
-1
2
file_server
database_server
2
1
130
128
0
1
131
128
0
#135
Mustache Templating Language Package
0
135
1
-1
4
3
1
136
1
137
1
138
1
-1
4
0
2
after_install
5
172
-1
before_uninstall
5
172
-1
11
identifier
version
manifest
relocate
requires
provides
instructions
description
authors
homepage
license
11
2
mustache
135
1
2
1.0.1
135
1
4
4
4
2
1
135
2
package
4
2
1
136
2
changelog
4
2
1
137
2
dictionary
4
2
1
138
2
compiler
135
1
4
1
2
dictionary.compiler
135
1
4
2
4
2
2
kernel
2
>= 1.1.1
4
2
2
primitive
2
>= 0.0.2
135
1
4
0
135
1
4
1
2
install-namespace
135
1
2
A MOO/Stunt port of the popular Mustache templating language (http://mustache.github.com/).
135
1
4
1
2
Todd Sundsted
135
1
2
http://stunt.io/packages/mustache
135
1
2
FreeBSD License
135
1
#136
Changelog
0
135
1
135
4
0
1
-1
4
0
0
9
1317769370
1317897840
1319399411
1337466158
1337553578
1341406402
1341407065
1355362911
1355403901
9
2
Initial release candidate.
135
1
2
Fixed a bug in pushing/popping context frames.
135
1
2
Fixed a bug in handling dotted notation.
135
1
2
Emit syntax errors for invalid mustache.
135
1
2
Improved the quality of the generated code.
135
1
2
Emit a syntax error for an empty tag.
135
1
2
Ensure `compile()' takes a list.
135
1
2
Created new version: 1.0.1.
135
1
2
Compiler output is now compatible.
135
1
#137
Dictionary
0
135
1
135
4
0
1
-1
4
0
0
1
compiler
1
1
138
135
1
#138
Mustache Compiler
0
135
1
135
4
0
4
1
1
4
4
0
2
_log
5
172
-1
compile
135
172
-1
0
1
5
135
4
#139
Application Package
0
139
1
-1
4
3
1
140
1
141
1
142
1
-1
4
0
1
after_install
5
172
-1
11
identifier
version
manifest
requires
relocate
provides
instructions
description
authors
homepage
license
11
2
application
139
1
2
0.0.10
139
1
4
10
4
2
1
139
2
package
4
2
1
140
2
changelog
4
2
1
141
2
dictionary
4
2
1
142
2
server
4
2
1
143
2
file_server
4
2
1
144
2
database_server
4
2
1
145
2
home_controller
4
2
1
146
2
home_views
4
2
1
147
2
session_controller
4
2
1
148
2
routes
139
1
4
3
4
2
2
dialog
2
>= 0.1.1
4
2
2
dialog_extras
2
>= 0.0.5
4
2
2
plastic
2
= 1.0
139
1
4
2
2
routes.home_controller
2
routes.session_controller
139
1
4
0
139
1
4
1
2
install-dictionary
139
1
2

139
1
4
0
139
1
2

139
1
2

139
1
#140
Changelog
0
139
1
139
4
0
1
-1
4
0
0
15
1335958995
1335960351
1335961601
1336184517
1336230042
1355917473
1355919225
1359114126
1359114154
1359115220
1368873734
1369601627
1369937655
1373410228
1373410677
15
2
Major refactoring.
139
1
2
Updated the authentication.
139
1
2
Autostart the web server.
139
1
2
Use jquery.console.
139
1
2
Handle multiline output correctly/better in the view.
139
1
2
Created new version: 0.0.8.
139
1
2
Long polling is now the default.  `socket_or_long_poll' changes this behavior.
139
1
2
Created new version: 0.0.9.
139
1
2
Updated session verbs `create()' and `destroy()' to new session mechanism.
139
1
2
Updated home verbs `_common()', `home()' and `browse()'.
139
1
2
Startup now uses configured port.
139
1
2
Port may be pulled from environment.
139
1
2
Use helpers to get service url.
139
1
2
Created new version: 0.0.10.
139
1
2
Upgraded verbs to 1.0.0 of plastic syntax.
139
1
#141
Dictionary
0
139
1
139
4
0
1
-1
4
1
1
0
1
server_started
5
172
-1
0
0
#142
HTTP Server
0
139
1
139
4
5
1
143
1
144
1
145
1
147
1
148
4
3
1
121
1
132
1
133
4
0
0
0
12
0
8888
117
1
2
T~14%G~F37~8A~B3$~E3~B5~E6G~7EJq98>E~AE~CC~CBm~C9~CD~BB~1C~04~FC~09~89~B7~91~A1/w~B7~F7~91~C8x4f~99~DD~1E~FB~17~1F~A8~12ng2.~B7sM~D3rh$x~A5~07P~9BHD~FA*~A4~AD~08~B6~89f~D0~C7G~A4]~D1~DE~DB~F7+~E9`~E6w~80o~97zI~CEz~CF~F20~11~1D~BE~E5U~E0~C3~A1~FA~D6~C1~A7~07%~19~FD~BC~8A~EE~AB~E1~7F~F0~05
117
0
4
10
2
session
2
parameters
2
protect_from_forgery
2
do_socket
2
do_long_poll
2
route
2
serve
2
cleanup
2
404
2
log
139
4
5
117
0
5
117
1
5
117
1
5
117
1
5
117
1
5
139
4
2
<?xml version="1.0"?><cross-domain-policy><allow-access-from domain="localhost" to-ports="*"/></cross-domain-policy>
139
4
5
139
4
5
128
1
#143
File Server
0
139
1
142
4
0
4
1
1
130
4
0
0
0
2
5
128
0
5
139
4
#144
Database Server
0
139
1
142
4
0
4
1
1
131
4
0
0
0
3
5
128
0
5
128
1
5
139
4
#145
Home Controller
0
139
1
142
4
1
1
146
1
-1
4
0
3
_common*_parameters
139
172
-1
home
139
172
-1
browse
139
172
-1
2
home_views
socket_or_long_poll
2
1
38158
139
0
2
long_poll
139
0
#146
Home Views
0
139
1
145
4
0
4
1
1
134
4
0
6
_head
139
172
-1
_foot
139
172
-1
_nav
139
172
-1
public
139
172
-1
home
139
172
-1
browse
139
172
-1
0
2
5
128
0
5
128
0
#147
Session Controller
0
139
1
142
4
0
1
-1
4
0
2
create
5
172
-1
destroy
5
172
-1
0
0
#148
Routes
0
139
1
142
4
0
4
1
1
124
4
0
1
match
139
172
-1
2
home_controller
session_controller
3
1
145
139
0
1
147
139
0
5
139
4
1
#149
Query Utilities
0
99
1
-1
4
0
1
-1
4
0
2
query
5
172
-1
lookup
5
172
-1
1
ask_proto
1
1
102
99
0
0
506
#0:0
$private();
{e} = args;
desc = e[2];
{line, @lines} = e[4];
server_log(tostr(line[4], ":", line[2], (line[4] != line[1]) ? tostr(" (this == ", line[1], ")") | "", ", line ", line[6], ":  ", desc));
for line in (lines)
server_log(tostr("... called from ", line[4], ":", line[2], (line[4] != line[1]) ? tostr(" (this == ", line[1], ")") | "", ", line ", line[6]));
endfor
server_log("(End of traceback)");
.
#0:1
$restrict_to_server();
START = "%/%*";
END = "%*%/";
MATCH = "%([^ :]+%) *: *%(%( *[^ *]+%)+%)";
content_type = 0;
if (match(args[1], START))
i = 1;
while (i <= length(args))
if (r = match(args[i], MATCH))
key = r[4][r[3][1][1]..r[3][1][2]];
value = r[4][r[3][2][1]..r[3][2][2]];
if (key == "content-type")
content_type = value;
endif
endif
if (match(args[i], END))
break;
endif
i = i + 1;
endwhile
endif
if (content_type)
if (content_type = this:_parse_content_type(content_type))
if (valid(compiler = this:_match_external_compiler(@content_type)))
if ((code = compiler:compile(args))[1])
return eval(@code[2]);
else
return code;
endif
endif
endif
endif
return eval(@args);
return;
"$restrict_to_server();";
"";
"START = \"%/%*\";";
"END   = \"%*%/\";";
"MATCH = \"%([^ :]+%) *: *%(%( *[^ *]+%)+%)\";";
"";
"content_type = 0;";
"";
"if (match(args[1], START))";
"  i = 1;";
"  while (i <= length(args))";
"    if ((r = match(args[i], MATCH)))";
"      key = r[4][r[3][1][1]..r[3][1][2]];";
"      value = r[4][r[3][2][1]..r[3][2][2]];";
"      if (key == \"content-type\")";
"	content_type = value;";
"      endif";
"    endif";
"    if (match(args[i], END))";
"      break;";
"    endif";
"    i = i + 1;";
"  endwhile";
"endif";
"";
"if (content_type)";
"   if ((content_type = this:_parse_content_type(content_type)))";
"     if (valid(compiler = this:_match_external_compiler(@content_type)))";
"       if ((code = compiler:compile(args))[1])";
"	 return eval(@code[2]);";
"       else";
"	 return code;";
"       endif";
"     endif";
"   endif";
"endif";
"";
"return eval(@args);";
"";
"chunk_length:38";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:DB88515CD84ABBE033C74262D69887ED5204F967";
"state:clean";
"updated_at:Sat May 18 05:19:01 2013 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#0:2
$restrict_to_server();
for parent in (parents(this))
if (respond_to(parent, "server_started"))
try
parent:server_started(@args);
except e (ANY)
this:_log_error(e);
endtry
endif
endfor
.
#0:3
$restrict_to_server();
try
subject = $nothing;
set_connection_option(player, "hold-input", 1);
if (!args)
if ((player < this.last_login_connection) && this.welcome_message)
this.last_login_connection = player;
notify(player, this.welcome_message);
endif
return;
elseif (args[1] != "connect")
notify(player, "*** Invalid ***");
return;
endif
try
subject = $authenticate(@args[2..$]);
except e (ANY)
this:_log_error(e);
notify(player, "*** Failed ***");
subject = $nothing;
return;
endtry
if ((!valid(subject)) || (!is_player(subject)))
suspend(2);
notify(player, "*** Failed ***");
subject = $nothing;
return;
endif
finally
set_connection_option(player, "hold-input", 0);
return subject;
endtry
.
#0:4
$permit("wizard");
valid = 1;
for arg in (args)
if (typeof(arg) != STR)
valid = 0;
endif
endfor
valid || raise(E_INVARG);
for parent in (parents(this))
if (respond_to(parent, "authenticate") && `valid(subject = parent:authenticate(@args)) ! ANY')
return subject;
endif
endfor
return $failed_match;
.
#0:5
return;
"/* verbs are public by default */";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:B9AE90C9AD4B4E8A1BCFAFDDB1A1FB19560CE835";
"state:clean";
"updated_at:Sat Apr 13 14:16:06 2013 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"[\"pre.usage\",[\"code.language-moocode\",[\"em\",\"none\"],\" \",[\"strong\",\"$public\"],\"()\"]]";
"[\"p\",\"Indicates that the verb has \",[\"em\",\"public\"],\" visibility. Provided the \",[\"em\",\"x\"],\"-flag is also set, the verb may be called from any other verb in the database.\"]";
"";
"chunk_length:2";
"chunk_type:documentation";
"content_type:application/json";
"sha1:158482922489F53B0DDBB5176968AF83DBAF0448";
"-=-=-mxyzptlk-=-=-";
.
#0:6
clients = args;
callers = callers();
(length(callers) > 1) || raise(E_PERM, "Private verb");
((((callers[1][4] == callers[2][4]) && valid(callers[1][4])) && (callers[1][1] == callers[2][1])) && valid(callers[1][1])) || raise(E_PERM, "Private verb");
((!clients) || (callers[2][2] in clients)) || raise(E_PERM, tostr("Private verb:  \"", callers[2][2], "\" not in verb list ", toliteral(clients)));
return;
"clients = args;";
"callers = callers();";
"length(callers) > 1 || raise(E_PERM, \"Private verb\");";
"callers[1][4] == callers[2][4] && valid(callers[1][4]) && callers[1][1] == callers[2][1] && valid(callers[1][1]) || raise(E_PERM, \"Private verb\");";
"!clients || callers[2][2] in clients || raise(E_PERM, tostr(\"Private verb:  \\\"\", callers[2][2], \"\\\" not in verb list \", toliteral(clients)));";
"/*";
"Only allow the call if the caller and the callee were both defined";
"on the same object and the call between caller and callee was";
"performed on the same instance.";
"*/";
"/* security audit on Tue Jul 26 15:51:17 2011 EDT */";
"";
"content_type:application/x-moocode";
"updated_at:Tue Sep 13 19:26:52 2011 EDT";
"-=-=-mxyzptlk-=-=-";
"[\"pre.usage\",[\"code.language-moocode\",[\"em\",\"none\"],\" \",[\"strong\",\"$private\"],\"()\"]]";
"[\"p\",\"Indicates that the verb has \",[\"em\",\"private\"],\" visibility. Provided the \",[\"em\",\"x\"],\"-flag is also set, the verb may \",[\"strong\",\"only\"],\" be called from verbs defined on the same object.\"]";
"";
"chunk_length:2";
"chunk_type:documentation";
"content_type:application/json";
"sha1:53E0F1E965133441CD23B88A28273C5F3F481D89";
"-=-=-mxyzptlk-=-=-";
.
#0:7
clients = args;
callers = callers();
(length(callers) > 1) || raise(E_PERM, "Protected verb");
((callers[1][1] == callers[2][1]) && valid(callers[1][1])) || raise(E_PERM, "Protected verb");
((!clients) || (callers[2][2] in clients)) || raise(E_PERM, tostr("Protected verb:  \"", callers[2][2], "\" not in verb list ", toliteral(clients)));
return;
"clients = args;";
"callers = callers();";
"length(callers) > 1 || raise(E_PERM, \"Protected verb\");";
"callers[1][1] == callers[2][1] && valid(callers[1][1]) || raise(E_PERM, \"Protected verb\");";
"!clients || callers[2][2] in clients || raise(E_PERM, tostr(\"Protected verb:  \\\"\", callers[2][2], \"\\\" not in verb list \", toliteral(clients)));";
"/*";
"Only allow the call if the call between caller and the callee was";
"performed on the same instance.";
"*/";
"/* security audit on Tue Jul 26 15:51:17 2011 EDT */";
"";
"content_type:application/x-moocode";
"updated_at:Tue Sep 13 19:26:52 2011 EDT";
"-=-=-mxyzptlk-=-=-";
"[\"pre.usage\",[\"code.language-moocode\",[\"em\",\"none\"],\" \",[\"strong\",\"$protected\"],\"()\"]]";
"[\"p\",\"Indicates that the verb has \",[\"em\",\"protected\"],\" visibility. Provided the \",[\"em\",\"x\"],\"-flag is also set, the verb may \",[\"strong\",\"only\"],\" be called from verbs defined on the same object, its ancestors or its descendants.\"]";
"";
"chunk_length:2";
"chunk_type:documentation";
"content_type:application/json";
"sha1:ACE9F2DCF1F8CE34CBC422CEAF40908283C3E9F0";
"-=-=-mxyzptlk-=-=-";
.
#0:8
args && raise(E_ARGS);
{dummy, @callers} = callers();
callers && raise(E_PERM, "Server-only verb");
return;
"args && raise(E_ARGS);";
"{dummy, @callers} = callers();";
"callers && raise(E_PERM, \"Server-only verb\");";
"/*";
"Only allow the call if the caller is the server.";
"*/";
"/* security audit on Tue Jul 26 15:51:17 2011 EDT */";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"updated_at:Tue Oct 18 07:27:43 2011 EDT";
"-=-=-mxyzptlk-=-=-";
"[\"pre.usage\",[\"code.language-moocode\",[\"em\",\"none\"],\" \",[\"strong\",\"$restrict_to_server\"],\"()\"]]";
"[\"p\",\"Indicates that the verb call may only be initiated by the server. This is true for command verbs and for special verbs like \",[\"strong\",\"server_started()\"],\" and \",[\"strong\",\"do_login_command()\"],\", among others. \"]";
"";
"chunk_length:2";
"chunk_type:documentation";
"content_type:application/json";
"sha1:4BEB9921C26935A4490E3A76994635F936B3D8FE";
"-=-=-mxyzptlk-=-=-";
.
#0:9
clients = args;
{dummy, @callers} = callers();
callers || raise(E_PERM, "Builtin-only verb");
(((callers[1][4] == $nothing) && (callers[1][3] == $nothing)) && (callers[1][2] != "")) || raise(E_PERM, "Builtin-only verb");
((!clients) || (callers[1][2] in clients)) || raise(E_PERM, tostr("Builtin-only verb:  \"", callers[1][2], "\" not in verb list ", toliteral(clients)));
return;
"clients = args;";
"{dummy, @callers} = callers();";
"callers || raise(E_PERM, \"Builtin-only verb\");";
"callers[1][4] == $nothing && callers[1][3] == $nothing && callers[1][2] != \"\" || raise(E_PERM, \"Builtin-only verb\");";
"!clients || callers[1][2] in clients || raise(E_PERM, tostr(\"Builtin-only verb:  \\\"\", callers[1][2], \"\\\" not in verb list \", toliteral(clients)));";
"/*";
"Only allow the call if the caller is a built-in function.";
"*/";
"/* fixed incorrect implementation of specified test Sat Sep 10 15:39:39 2011 EDT*/";
"/* security audit on Tue Jul 26 15:51:17 2011 EDT */";
"";
"chunk_length:10";
"chunk_type:source";
"content_type:application/x-moocode";
"updated_at:Tue Oct 18 07:27:43 2011 EDT";
"-=-=-mxyzptlk-=-=-";
"[\"pre.usage\",[\"code.language-moocode\",[\"em\",\"none\"],\" \",[\"strong\",\"$restrict_to_builtin\"],\"([\",[\"var\",\"STR builtin\"],\", \",[\"var\",\"...\"],\"])\"]]";
"[\"p\",\"Indicates that the verb may only be called by the the server in the course of executing a builtin function. This is true for special verbs like \",[\"strong\",\"initialize()\"],\" (called from \",[\"strong\",\"create()\"],\"), \",[\"strong\",\"recycle()\"],\" (called from \",[\"strong\",\"recycle()\"],\") and \",[\"strong\",\"accept()\"],\" (called from \",[\"strong\",\"move()\"],\"), among others. \",\"If one or more optional \",[\"var\",\"builtins\"],\" are specified, the call is further permitted for only those specified.\"]";
"";
"chunk_length:2";
"chunk_type:documentation";
"content_type:application/json";
"sha1:3F74B2990C937C046C55420A9C29D399C8921608";
"-=-=-mxyzptlk-=-=-";
.
#0:10
{caller, @clients} = args;
{dummy, @callers} = callers();
callers || raise(E_PERM, "Restricted verb");
((callers[1][4] == caller) && valid(callers[1][1])) || raise(E_PERM, "Restricted verb");
((!clients) || (callers[1][2] in clients)) || raise(E_PERM, tostr("Restricted verb:  \"", callers[1][2], "\" not in verb list ", toliteral(clients)));
return;
"{caller, @clients} = args;";
"{dummy, @callers} = callers();";
"callers || raise(E_PERM, \"Restricted verb\");";
"callers[1][4] == caller && valid(callers[1][1]) || raise(E_PERM, \"Restricted verb\");";
"!clients || callers[1][2] in clients || raise(E_PERM, tostr(\"Restricted verb:  \\\"\", callers[1][2], \"\\\" not in verb list \", toliteral(clients)));";
"/*";
"Only allow the call if the specified caller matches the actual";
"caller.";
"*/";
"/* changed to check the object on which the verb was defined, instead of used Tue Oct 18 07:26:02 2011 EDT */";
"/* security audit on Tue Jul 26 15:51:17 2011 EDT */";
"";
"chunk_length:11";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:FEF23962D234E26788A076D199C73A1853BC6B80";
"state:clean";
"updated_at:Sat Apr 13 15:58:10 2013 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"[\"pre.usage\",[\"code.language-moocode\",[\"em\",\"none\"],\" \",[\"strong\",\"$restrict_to_caller\"],\"(\",[\"var\",\"OBJ caller\"],\" [, \",[\"var\",\"STR verb\"],\", \",[\"var\",\"...\"],\"])\"]]";
"[\"p\",\"Indicates that the verb may only be called by a verb defined on the specified \",[\"var\",\"caller\"],\". \",\"If one or more optional \",[\"var\",\"verbs\"],\" are specified, the call is further permitted for only those specified.\"]";
"";
"chunk_length:2";
"chunk_type:documentation";
"content_type:application/json";
"sha1:6C48BDD2FB2B6765AD6DCBD034ABD4BFF9F601F1";
"-=-=-mxyzptlk-=-=-";
.
#0:11
subjects = args;
callers = callers();
(length(callers) > 1) || raise(E_PERM);
(valid(callers[2][3]) && valid(callers[1][1])) || raise(E_PERM);
if (("wizard" in subjects) && callers[2][3].wizard)
return;
endif
if (("owner" in subjects) && (callers[2][3] == callers[1][1].owner))
return;
endif
if (("same" in subjects) && (callers[2][3] == callers[1][3]))
return;
endif
if (callers[2][3] in subjects)
return;
endif
raise(E_PERM, "Not permitted");
return;
"subjects = args;";
"callers = callers();";
"length(callers) > 1 || raise(E_PERM);";
"valid(callers[2][3]) && valid(callers[1][1]) || raise(E_PERM);";
"if (\"wizard\" in subjects && callers[2][3].wizard)";
"  return;";
"endif";
"if (\"owner\" in subjects && callers[2][3] == callers[1][1].owner)";
"  return;";
"endif";
"if (\"same\" in subjects && callers[2][3] == callers[1][3])";
"  return;";
"endif";
"if (callers[2][3] in subjects)";
"  return;";
"endif";
"raise(E_PERM, \"Not permitted\");";
"/*";
"Only allow the call if the caller is a wizard (if the subject";
"\"wizard\" is specified) or the owner of the object the verb was";
"called on (AKA this) (if the subject \"owner\" is specified) or has";
"the same task perms (if the subject \"same\" is specified).";
"*/";
"/* security audit on Tue Jul 26 15:51:17 2011 EDT */";
"";
"chunk_length:24";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:8A60627547E573EB31B4069A8A48E4B11A130445";
"state:clean";
"updated_at:Sun Apr 14 09:49:23 2013 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"[\"pre.usage\",[\"code.language-moocode\",[\"em\",\"none\"],\" \",[\"strong\",\"$permit\"],\"(\",[\"var\",\"STR|OBJ caller\"],\", \",[\"var\",\"...\"],\")\"]]";
"[\"p\",\"Indicates that the verb may only be called by a verb running with the permissions specified by \",[\"var\",\"caller\"],\". \",\"If the \",[\"var\",\"caller\"],\" \\\"wizard\\\" is specified, only allow the call if the calling permissions are wizardly. \",\"If the \",[\"var\",\"caller\"],\" \\\"owner\\\" is specified, only allow the call if the calling permissions match the owner of the object on which the verb is defined. \",\"If the \",[\"var\",\"caller\"],\" \\\"same\\\" is specified, only allow the call if the calling permissions match the current task permissions. \",\"Otherwise, the calling permissions must match the explicit \",[\"var\",\"caller\"],\" specified.\"]";
"[\"pre.example\",[\"code.language-moocode\",\"$permit(\\\"wizard\\\", \\\"owner\\\")\"],[\"code.language-moocode\",\"$permit($foo.bar.owner)\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:A051EDD497D47D86FF4C8E40B270D8C7EC51DDBD";
"-=-=-mxyzptlk-=-=-";
.
#0:12
{owner, object} = args;
(caller_perms().wizard || (caller_perms() == owner)) || raise(E_PERM);
if (LIST == typeof(object))
for object in (object)
(((object == $nothing) || (valid(object) && object.f)) || (valid(object) && (owner.wizard || (owner == object.owner)))) || raise(E_PERM);
endfor
else
(((object == $nothing) || (valid(object) && object.f)) || (valid(object) && (owner.wizard || (owner == object.owner)))) || raise(E_PERM);
endif
return;
"{owner, object} = args;";
"caller_perms().wizard || caller_perms() == owner || raise(E_PERM);";
"/* `object' can be $nothing, an object number, or a list of object numbers */";
"if (LIST == typeof(object))";
"  for object in (object)";
"    object == $nothing || (valid(object) && object.f) || (valid(object) && (owner.wizard || owner == object.owner)) || raise(E_PERM);";
"  endfor";
"else";
"  object == $nothing || (valid(object) && object.f) || (valid(object) && (owner.wizard || owner == object.owner)) || raise(E_PERM);";
"endif";
"/* security audit on Tue Jul 26 15:51:17 2011 EDT */";
"";
"content_type:application/x-moocode";
"updated_at:Tue Sep 13 19:26:52 2011 EDT";
"-=-=-mxyzptlk-=-=-";
.
#0:13
{owner, object} = args;
(caller_perms().wizard || (caller_perms() == owner)) || raise(E_PERM);
(valid(object) && (owner.wizard || (owner == object.owner))) || raise(E_PERM);
return;
"{owner, object} = args;";
"caller_perms().wizard || caller_perms() == owner || raise(E_PERM);";
"valid(object) && (owner.wizard || owner == object.owner) || raise(E_PERM);";
"/* security audit on Tue Jul 26 15:51:17 2011 EDT */";
"";
"content_type:application/x-moocode";
"updated_at:Tue Sep 13 19:26:52 2011 EDT";
"-=-=-mxyzptlk-=-=-";
.
#0:14
{code} = args;
(typeof(code) == LIST) || raise(E_INVARG);
state = 1;
chunks = {};
chunk = [];
chunk_length = 0;
i = length(code);
while (state && i)
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
line = code[i];
i = i - 1;
if ((state == 1) && (line == "\"-=-=-mxyzptlk-=-=-\";"))
chunk = ["metadata" -> []];
chunk_length = 0;
state = 2;
elseif (state == 1)
i = i + 1;
state = 0;
elseif ((state == 2) && (r = match(line, "^\"%([-_a-z0-9]+%)%:%(.+%)\";$")))
key = r[4][r[3][1][1]..r[3][1][2]];
value = r[4][r[3][2][1]..r[3][2][2]];
chunk_length = (key == "chunk_length") ? toint(value) | 0;
chunk["metadata"][key] = value;
elseif ((state == 2) && (line == "\"\";"))
chunk["source"] = {};
for line in (code[(i - chunk_length) + 1..i])
chunk["source"] = {@chunk["source"], strsub(strsub(line[2..$ - 2], "\\\"", "\""), "\\\\", "\\")};
endfor
i = i - chunk_length;
state = 3;
elseif ((state == 3) && (line == "return;"))
chunks = {chunk, @chunks};
state = 0;
elseif ((state == 3) && (line == "\"-=-=-mxyzptlk-=-=-\";"))
chunks = {chunk, @chunks};
chunk = ["metadata" -> []];
chunk_length = 0;
state = 2;
elseif ((state == 3) && (r = match(line, ((((("^\"%(%(" + "[^\\\"]+") + "%|") + "\\\\") + "%|") + "\\\"") + "%)*%)\";$")))
line = strsub(strsub(r[4][r[3][1][1]..r[3][1][2]], "\\\"", "\""), "\\\\", "\\");
chunk["source"] = {line, @chunk["source"]};
elseif (state == 2)
raise(E_INVARG, tostr("Bad metadata:  ", line));
elseif (state == 3)
raise(E_INVARG, tostr("Missing return:  ", line));
else
raise(E_INVARG);
endif
endwhile
if (state > 1)
raise(E_INVARG, "Corrupt source");
endif
chunks = {["code" -> code[1..i]], @chunks};
return chunks;
return;
"{code} = args;";
"";
"/* Not $private() but maybe should be.  The existance and interface";
" * are subject to change.  No obvious security problems, though.";
" */";
"";
"typeof(code) == LIST || raise(E_INVARG);";
"";
"/* State:";
" *   0 = done";
" *   1 = looking for a boundary";
" *   2 = reading metadata";
" *   3 = reading source";
" */";
"state = 1;";
"";
"/* Strinctly speaking, \"chunk_length\" is optional.  If it's present,";
" * use the value to skip past lines of source.  Otherwise, use the";
" * more error-prone search-for-the-boundary method.";
" */";
"chunks = {};";
"chunk = [];";
"chunk_length = 0;";
"";
"i = length(code);";
"while (state && i)";
"  (ticks_left() < 10000 || seconds_left() < 2) &&";
"    suspend(0);";
"  line = code[i];";
"  i = i - 1;";
"  if (state == 1 && line == \"\\\"-=-=-mxyzptlk-=-=-\\\";\")";
"    chunk = [\"metadata\" -> []];";
"    chunk_length = 0;";
"    state = 2;";
"  elseif (state == 1)";
"    i = i + 1;";
"    state = 0;";
"  elseif (state == 2 && (r = match(line, \"^\\\"%([-_a-z0-9]+%)%:%(.+%)\\\";$\")))";
"    key = r[4][r[3][1][1]..r[3][1][2]];";
"    value = r[4][r[3][2][1]..r[3][2][2]];";
"    chunk_length = (key == \"chunk_length\" ) ? toint(value) | 0;";
"    chunk[\"metadata\"][key] = value;";
"  elseif (state == 2 && line == \"\\\"\\\";\")";
"    chunk[\"source\"] = {};";
"    for line in (code[i - chunk_length + 1..i])";
"      chunk[\"source\"] = {@chunk[\"source\"], strsub(strsub(line[2..$ - 2], \"\\\\\\\"\", \"\\\"\"), \"\\\\\\\\\", \"\\\\\")};";
"    endfor";
"    i = i - chunk_length;";
"    state = 3;";
"  elseif (state == 3 && line == \"return;\")";
"    chunks = {chunk, @chunks};";
"    state = 0;";
"  elseif (state == 3 && line == \"\\\"-=-=-mxyzptlk-=-=-\\\";\")";
"    chunks = {chunk, @chunks};";
"    chunk = [\"metadata\" -> []];";
"    chunk_length = 0;";
"    state = 2;";
"  elseif (state == 3 && (r = match(line, \"^\\\"%(%(\" + \"[^\\\\\\\"]+\" +  \"%|\" + \"\\\\\\\\\" +  \"%|\" + \"\\\\\\\"\" + \"%)*%)\\\";$\")))";
"    line = strsub(strsub(r[4][r[3][1][1]..r[3][1][2]], \"\\\\\\\"\", \"\\\"\"), \"\\\\\\\\\", \"\\\\\");";
"    chunk[\"source\"] = {line, @chunk[\"source\"]};";
"  elseif (state == 2)";
"    raise(E_INVARG, tostr(\"Bad metadata:  \", line));";
"  elseif (state == 3)";
"    raise(E_INVARG, tostr(\"Missing return:  \", line));";
"  else";
"    raise(E_INVARG);";
"  endif";
"endwhile";
"if (state > 1)";
"  raise(E_INVARG, \"Corrupt source\");";
"endif";
"chunks = {[\"code\" -> code[1..i]], @chunks};";
"";
"return chunks;";
"";
"/* security audit on Tue Sep 13 18:59:04 2011 EDT */";
"/* security audit on Sat Oct  1 18:04:47 2011 EDT */";
"";
"chunk_length:77";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:92A11D466C5630A29FF7229853670F7554C38A4E";
"state:clean";
"updated_at:Tue Jul  3 08:43:38 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#0:15
{chunks} = args;
(typeof(chunks) == LIST) || raise(E_INVARG);
state = 1;
code = {};
for chunk in (chunks)
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
if (state > 1)
source = {};
if (state == 2)
source = {"return;"};
state = 3;
endif
for line in (chunk["source"])
source = {@source, toliteral(line) + ";"};
endfor
metadata = {};
for value, key in (chunk["metadata"])
metadata = {@metadata, toliteral(tostr(key, ":", value)) + ";"};
endfor
code = {@code, @source, "\"\";", @metadata, "\"-=-=-mxyzptlk-=-=-\";"};
else
code = chunk["code"];
state = 2;
endif
endfor
return code;
return;
"{chunks} = args;";
"";
"/* Not $private() but maybe should be.  The existance and interface";
" * are subject to change.  No obvious security problems, though.";
" */";
"";
"typeof(chunks) == LIST || raise(E_INVARG);";
"";
"/* State:";
" *   1 = adding code chunk";
" *   2 = adding first source chunk";
" *   3 = adding source chunk";
" */";
"state = 1;";
"";
"code = {};";
"";
"for chunk in (chunks)";
"  (ticks_left() < 10000 || seconds_left() < 2) &&";
"    suspend(0);";
"  if (state > 1)";
"    source = {};";
"    if (state == 2)";
"      source = {\"return;\"};";
"      state = 3;";
"    endif";
"    for line in (chunk[\"source\"])";
"      source = {@source, toliteral(line) + \";\"};";
"    endfor";
"    metadata = {};";
"    for value, key in (chunk[\"metadata\"])";
"      metadata = {@metadata, toliteral(tostr(key, \":\", value)) + \";\"};";
"    endfor";
"    code = {@code, @source, \"\\\"\\\";\", @metadata, \"\\\"-=-=-mxyzptlk-=-=-\\\";\"};";
"  else";
"    code = chunk[\"code\"];";
"    state = 2;";
"  endif";
"endfor";
"";
"return code;";
"";
"/* security audit on Tue Sep 13 18:59:04 2011 EDT */";
"/* security audit on Sat Oct  1 18:04:47 2011 EDT */";
"";
"chunk_length:44";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:9CAE265C4C667DE8BFFE28FE6856683DA259F29B";
"state:clean";
"updated_at:Tue Jul  3 08:42:40 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#0:16
{object, verb, @options} = args;
valid(object) || raise(E_INVARG);
`{owner, flags, name} = verb_info(object, verb) ! ANY' || raise(E_VERBNF);
perms = caller_perms();
((perms.wizard || (perms == owner)) || index(flags, "r")) || raise(E_PERM);
perms.programmer || raise(E_PERM);
set_task_perms(perms);
raw = 0;
fully_parenthesize = 0;
indent = 1;
if (options)
if (typeof(options[1]) == MAP)
`raw = options[1]["raw"] ! E_RANGE';
`fully_parenthesize = options[1]["fully_parenthesize"] || options[1]["fully-parenthesize"] ! E_RANGE';
`indent = options[1]["indent"] ! E_RANGE';
`revision = options[1]["revision"] ! E_RANGE';
elseif (typeof(options[1]) == STR)
raw = "raw" in options;
fully_parenthesize = ("fully_parenthesize" in options) || ("fully-parenthesize" in options);
indent = "indent" in options;
elseif (typeof(options[1]) == INT)
`fully_parenthesize = options[1] ! E_RANGE';
`indent = options[2] ! E_RANGE';
endif
endif
code = verb_code(object, verb, fully_parenthesize, indent);
chunks = this:_unpack_verb_code(code);
if (`revision ! ANY' != E_VARNF)
n = 0;
for chunk, i in (chunks)
if ((`toint(chunk["metadata"]["revision"]) ! E_RANGE, E_TYPE' == revision) && revision)
n = i;
break;
endif
endfor
(!n) && raise(E_INVARG, "No such revision");
else
n = 2;
endif
return ((!raw) && (length(chunks) > 1)) ? chunks[n]["source"] | chunks[1]["code"];
return;
"{object, verb, @options} = args;";
"";
"/* check arguments and permissions */";
"valid(object) || raise(E_INVARG);";
"`{owner, flags, name} = verb_info(object, verb) ! ANY' || raise(E_VERBNF);";
"perms = caller_perms();";
"perms.wizard || (perms == owner) || index(flags, \"r\") || raise(E_PERM);";
"perms.programmer || raise(E_PERM);";
"";
"/* drop wiz-perms */";
"set_task_perms(perms);";
"";
"/* interpret optional arguments */";
"raw = 0;";
"fully_parenthesize = 0;";
"indent = 1;";
"if (options)";
"  if (typeof(options[1]) == MAP)";
"    `raw = options[1][\"raw\"] ! E_RANGE';";
"    `fully_parenthesize = options[1][\"fully_parenthesize\"] || options[1][\"fully-parenthesize\"] ! E_RANGE';";
"    `indent = options[1][\"indent\"] ! E_RANGE';";
"    `revision = options[1][\"revision\"] ! E_RANGE';";
"  elseif (typeof(options[1]) == STR)";
"    raw = (\"raw\" in options);";
"    fully_parenthesize = (\"fully_parenthesize\" in options) || (\"fully-parenthesize\" in options) ;";
"    indent = (\"indent\" in options);";
"  elseif (typeof(options[1]) == INT)";
"    `fully_parenthesize = options[1] ! E_RANGE';";
"    `indent = options[2] ! E_RANGE';";
"  endif";
"endif";
"";
"code = verb_code(object, verb, fully_parenthesize, indent);";
"chunks = this:_unpack_verb_code(code);";
"";
"if (`revision ! ANY' != E_VARNF)";
"  n = 0;";
"  for chunk, i in (chunks)";
"    if (`toint(chunk[\"metadata\"][\"revision\"]) ! E_RANGE, E_TYPE' == revision && revision)";
"      n = i;";
"      break;";
"    endif";
"  endfor";
"  !n && raise(E_INVARG, \"No such revision\");";
"else";
"  n = 2;";
"endif";
"";
"return (!raw && length(chunks) > 1) ? chunks[n][\"source\"] | chunks[1][\"code\"];";
"";
"/* security audit on Tue Sep 13 18:59:04 2011 EDT */";
"/* security audit on Sat Oct  1 18:04:47 2011 EDT */";
"";
"chunk_length:52";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:93F4856A7AF92AD16B1806C1421B76C27C8E24A6";
"state:clean";
"updated_at:Sun May 27 12:50:21 2012 EDT";
"-=-=-mxyzptlk-=-=-";
.
#0:17
{object, verb, code, @options} = args;
valid(object) || raise(E_INVARG);
`{owner, flags, name} = verb_info(object, verb) ! ANY' || raise(E_VERBNF);
perms = caller_perms();
((perms.wizard || (perms == owner)) || index(flags, "w")) || raise(E_PERM);
perms.programmer || raise(E_PERM);
verb_code = verb_code(object, verb);
set_task_perms(perms);
raw = 1;
content_type = 0;
do_not_version = 0;
do_not_stamp = 0;
if (options)
if (typeof(options[1]) == MAP)
raw = `options[1]["raw"] ! E_RANGE';
content_type = `options[1]["content_type"] ! E_RANGE' || `options[1]["content-type"] ! E_RANGE';
do_not_version = `options[1]["do_not_version"] ! E_RANGE' || `options[1]["do-not-version"] ! E_RANGE';
do_not_stamp = `options[1]["do_not_stamp"] ! E_RANGE' || `options[1]["do-not-stamp"] ! E_RANGE';
elseif ((typeof(options[1]) == STR) && (options[1] == "raw"))
raw = "raw";
elseif (typeof(options[1]) == STR)
raw = 0;
content_type = options[1];
endif
if (raw && content_type)
raise(E_INVARG);
endif
endif
chunks = {};
if (verb_code)
chunks = this:_unpack_verb_code(verb_code);
endif
if ((!options) && (!content_type))
if (`content_type = chunks[2]["metadata"]["content_type"] ! E_RANGE')
raw = 0;
endif
endif
(do_not_version && chunks) && raise(E_INVARG);
(do_not_stamp && chunks) && raise(E_INVARG);
if ((raw && code) && (code[$] == "\"-=-=-mxyzptlk-=-=-\";"))
return {"Illegal use of marker"};
elseif (content_type)
source = code;
{type, attributes} = this:_parse_content_type(content_type);
content_type = this:_generate_content_type({type, attributes});
if ((type == "application/x-moocode") && (!attributes))
elseif (`valid(compiler = this:_match_external_compiler(type, attributes)) ! ANY')
{status, code} = compiler:compile(code, attributes);
if (!status)
return code;
endif
else
return {tostr("Unknown content type:  ", content_type)};
endif
if (length(chunks) > 1)
if (`chunks[2]["metadata"]["state"] ! E_RANGE' == "clean")
revision = `toint(chunks[2]["metadata"]["revision"]) + 1 ! E_RANGE => 1';
keep = chunks[2..$];
else
revision = `toint(chunks[2]["metadata"]["revision"]) ! E_RANGE => 1';
keep = chunks[3..$];
endif
else
revision = 1;
keep = {};
endif
metadata = ["chunk_type" -> "source", "chunk_length" -> length(source), "content_type" -> content_type, "sha1" -> value_hash(source, "sha1")];
if ((!do_not_version) || chunks)
metadata["state"] = "dirty";
metadata["revision"] = revision;
endif
if ((!do_not_stamp) || chunks)
metadata["updated_at"] = ctime(time());
metadata["updated_by"] = perms;
endif
code = this:_pack_verb_code({["code" -> code], ["metadata" -> metadata, "source" -> source], @keep});
endif
return set_verb_code(object, verb, code);
return;
"{object, verb, code, @options} = args;";
"";
"/* check arguments and permissions */";
"valid(object) || raise(E_INVARG);";
"`{owner, flags, name} = verb_info(object, verb) ! ANY' || raise(E_VERBNF);";
"perms = caller_perms();";
"perms.wizard || (perms == owner) || index(flags, \"w\") || raise(E_PERM);";
"perms.programmer || raise(E_PERM);";
"";
"/* grab verb code before dropping perms */";
"verb_code = verb_code(object, verb);";
"";
"/* drop wiz-perms */";
"set_task_perms(perms);";
"";
"/* interpret optional arguments */";
"raw = 1;";
"content_type = 0;";
"do_not_version = 0;";
"do_not_stamp = 0;";
"if (options)";
"  if (typeof(options[1]) == MAP)";
"    raw = `options[1][\"raw\"] ! E_RANGE';";
"    content_type = `options[1][\"content_type\"] ! E_RANGE' || `options[1][\"content-type\"] ! E_RANGE';";
"    do_not_version = `options[1][\"do_not_version\"] ! E_RANGE' || `options[1][\"do-not-version\"] ! E_RANGE';";
"    do_not_stamp = `options[1][\"do_not_stamp\"] ! E_RANGE' || `options[1][\"do-not-stamp\"] ! E_RANGE';";
"  elseif (typeof(options[1]) == STR && options[1] == \"raw\")";
"    raw = \"raw\";";
"  elseif (typeof(options[1]) == STR)";
"    raw = 0;";
"    content_type = options[1];";
"  endif";
"  if (raw && content_type)";
"    raise(E_INVARG);";
"  endif";
"endif";
"";
"chunks = {};";
"if (verb_code)";
"  chunks = this:_unpack_verb_code(verb_code);";
"endif";
"";
"/* Iff no options are specified, use the content type of the verb";
" * source as the content type.  This alternative exists only to support";
" * legacy editors/tools.  It may be removed.";
" */";
"if (!options && !content_type)";
"  if (`content_type = chunks[2][\"metadata\"][\"content_type\"] ! E_RANGE')";
"    raw = 0;";
"  endif";
"endif";
"";
"/* Programmers can disable versioning (writing \"state\" and \"revision\")";
" * and stamping (writing \"updated_at\" and \"updated_by\"), however this";
" * only works the first time the verb code is set (the purpose of this";
" * functionality is to support package loading and other kinds of";
" * object migration).";
" */";
"do_not_version && chunks && raise(E_INVARG);";
"do_not_stamp && chunks && raise(E_INVARG);";
"";
"if (raw && code && code[$] == \"\\\"-=-=-mxyzptlk-=-=-\\\";\")";
"  return {\"Illegal use of marker\"};";
"";
"elseif (content_type)";
"  source = code;";
"";
"  /* parse the content type to validate it, then generate it in canonical form */";
"  {type, attributes} = this:_parse_content_type(content_type);";
"  content_type = this:_generate_content_type({type, attributes});";
"";
"  /* natively supported... no external compilation necessary */";
"  if (type == \"application/x-moocode\" && !attributes)";
"    ;";
"";
"  /* find an external compiler and compile */";
"  elseif (`valid(compiler = this:_match_external_compiler(type, attributes)) ! ANY')";
"    {status, code} = compiler:compile(code, attributes);";
"    if (!status)";
"      return code;";
"    endif";
"";
"  /* fail */";
"  else";
"    return {tostr(\"Unknown content type:  \", content_type)};";
"  endif";
"";
"  /* If the most recent revision is clean, increment the revision and";
"   * keep all prior revisions.  Else, replace the revision.";
"   */";
"  if (length(chunks) > 1)";
"    if (`chunks[2][\"metadata\"][\"state\"] ! E_RANGE' == \"clean\")";
"      revision = `toint(chunks[2][\"metadata\"][\"revision\"]) + 1 ! E_RANGE => 1';";
"      keep = chunks[2..$];";
"    else";
"      revision = `toint(chunks[2][\"metadata\"][\"revision\"]) ! E_RANGE => 1';";
"      keep = chunks[3..$];";
"    endif";
"  else";
"    revision = 1;";
"    keep = {};";
"  endif";
"";
"  metadata = [";
"    \"chunk_type\" -> \"source\",";
"    \"chunk_length\" -> length(source),";
"    \"content_type\" -> content_type,";
"    \"sha1\" -> value_hash(source, \"sha1\")";
"  ];";
"  if (!do_not_version || chunks)";
"    metadata[\"state\"] = \"dirty\";";
"    metadata[\"revision\"] = revision;";
"  endif";
"  if (!do_not_stamp || chunks)";
"    metadata[\"updated_at\"] = ctime(time());";
"    metadata[\"updated_by\"] = perms;";
"  endif";
"";
"  code = this:_pack_verb_code({[\"code\" -> code], [\"metadata\" -> metadata, \"source\" -> source], @keep});";
"";
"endif";
"";
"return set_verb_code(object, verb, code);";
"";
"/* security audit on Tue Sep 13 18:59:04 2011 EDT */";
"/* security audit on Sat Oct  1 18:04:47 2011 EDT */";
"";
"chunk_length:126";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:010DAED58C923371A9D262895A52F6A7982F2FE4";
"state:clean";
"updated_at:Mon Feb 18 09:09:42 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#0:18
{object, verb, @options} = args;
valid(object) || raise(E_INVARG);
`{owner, perms, name} = verb_info(object, verb) ! ANY' || raise(E_VERBNF);
callerp = caller_perms();
((`callerp.wizard ! E_INVIND' || (valid(callerp) && (callerp == owner))) || index(perms, "r")) || raise(E_PERM);
`callerp.programmer ! E_INVIND' || raise(E_PERM);
set_task_perms(callerp);
{dobj, prep, iobj} = verb_args(object, verb);
ret = ["owner" -> owner, "perms" -> perms, "names" -> name, "dobj" -> dobj, "prep" -> prep, "iobj" -> iobj];
code = verb_code(object, verb);
chunks = this:_unpack_verb_code(code);
`ret["updated_at"] = chunks[2]["metadata"]["updated_at"] ! E_RANGE';
`ret["updated_by"] = toobj(chunks[2]["metadata"]["updated_by"]) ! E_RANGE';
`ret["content_type"] = chunks[2]["metadata"]["content_type"] ! E_RANGE';
`ret["sha1"] = chunks[2]["metadata"]["sha1"] ! E_RANGE';
`ret["state"] = chunks[2]["metadata"]["state"] ! E_RANGE';
`ret["revision"] = toint(chunks[2]["metadata"]["revision"]) ! E_RANGE';
return ret;
return;
"{object, verb, @options} = args;";
"";
"/* check arguments */";
"valid(object) || raise(E_INVARG);";
"`{owner, perms, name} = verb_info(object, verb) ! ANY' || raise(E_VERBNF);";
"";
"/* check permissions */";
"callerp = caller_perms();";
"`callerp.wizard ! E_INVIND' || (valid(callerp) && callerp == owner) || index(perms, \"r\") || raise(E_PERM);";
"`callerp.programmer ! E_INVIND' || raise(E_PERM);";
"";
"/* drop wiz-perms */";
"set_task_perms(callerp);";
"";
"{dobj, prep, iobj} = verb_args(object, verb);";
"";
"ret = [\"owner\" -> owner, \"perms\" -> perms, \"names\" -> name, \"dobj\" -> dobj, \"prep\" -> prep, \"iobj\" -> iobj];";
"";
"code = verb_code(object, verb);";
"chunks = this:_unpack_verb_code(code);";
"";
"`ret[\"updated_at\"] = chunks[2][\"metadata\"][\"updated_at\"] ! E_RANGE';";
"`ret[\"updated_by\"] = toobj(chunks[2][\"metadata\"][\"updated_by\"]) ! E_RANGE';";
"`ret[\"content_type\"] = chunks[2][\"metadata\"][\"content_type\"] ! E_RANGE';";
"`ret[\"sha1\"] = chunks[2][\"metadata\"][\"sha1\"] ! E_RANGE';";
"`ret[\"state\"] = chunks[2][\"metadata\"][\"state\"] ! E_RANGE';";
"`ret[\"revision\"] = toint(chunks[2][\"metadata\"][\"revision\"]) ! E_RANGE';";
"";
"return ret;";
"";
"/* security audit on Sat Oct  1 18:04:47 2011 EDT */";
"";
"chunk_length:31";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:172E3B6EFAB13F7D5C64774D3E6BBB8592442EF5";
"state:clean";
"updated_at:Sun May 27 13:06:44 2012 EDT";
"updated_by:#5";
"-=-=-mxyzptlk-=-=-";
"[\"pre.usage\",[\"code.language-moocode\",[\"em\",\"MAP\"],\" \",[\"strong\",\"$verb_detail\"],\"(\",[\"var\",\"OBJ object\"],\", \",[\"var\",\"STR verb\"],\")\"]]";
"[\"p\",\"Returns verb info, args and other metadata in one convenient package.\"]";
"[\"pre.example\",[\"code.language-moocode\",\"$verb_detail(#100, \\\"foobar\\\")    => [\\\"content_type\\\" -> \\\"application/x-moocode\\\", \\\"dobj\\\" -> \\\"this\\\", \\\"iobj\\\" -> \\\"this\\\", \\\"names\\\" -> \\\"foobar\\\", ... ]\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:6A42158F001B7A6799FFDE9B6A4916987914D517";
"-=-=-mxyzptlk-=-=-";
.
#0:19
{content_type} = args;
parts = {};
while (content_type && (i = index(content_type, ";")))
parts = {@parts, content_type[1..i - 1]};
content_type = content_type[i + 1..$];
endwhile
parts = {@parts, content_type};
if (parts)
{type, @parts} = parts;
r = match(type, "^ *%([^ ]+%) *$");
type = type[r[3][1][1]..r[3][1][2]];
attributes = [];
for part in (parts)
if (r = match(part, "^ *%([^ ]+%) *%= *%([^ ]+%) *$"))
key = part[r[3][1][1]..r[3][1][2]];
value = part[r[3][2][1]..r[3][2][2]];
attributes[key] = value;
endif
endfor
return {type, attributes};
endif
return {};
return;
"{content_type} = args;";
"";
"/* Not $private() but maybe should be.  The existance and interface";
" * are subject to change.  No obvious security problems, though.";
" */";
"";
"parts = {};";
"while (content_type && (i = index(content_type, \";\")))";
"  parts = {@parts, content_type[1..i - 1]};";
"  content_type = content_type[i + 1..$];";
"endwhile";
"parts = {@parts, content_type};";
"if (parts)";
"  {type, @parts} = parts;";
"  r = match(type, \"^ *%([^ ]+%) *$\");";
"  type = type[r[3][1][1]..r[3][1][2]];";
"  attributes = [];";
"  for part in (parts)";
"    if ((r = match(part, \"^ *%([^ ]+%) *%= *%([^ ]+%) *$\")))";
"      key = part[r[3][1][1]..r[3][1][2]];";
"      value = part[r[3][2][1]..r[3][2][2]];";
"      attributes[key] = value;";
"    endif";
"  endfor";
"  return {type, attributes};";
"endif";
"";
"return {};";
"";
"/* security audit on Sat Oct  1 18:04:47 2011 EDT */";
"";
"chunk_length:30";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:CBB97DA582802179E6077D82FA4918CD37B542F2";
"state:clean";
"updated_at:Wed May 15 08:43:28 2013 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#0:20
{content_type} = args;
{type, attributes} = content_type;
for attribute in (mapkeys(attributes))
type = tostr(type, ";", attribute, "=", attributes[attribute]);
endfor
return type;
return;
"{content_type} = args;";
"";
"/* Not $private() but maybe should be.  The existance and interface";
" * are subject to change.  No obvious security problems, though.";
" */";
"";
"{type, attributes} = content_type;";
"";
"for attribute in (mapkeys(attributes))";
"  type = tostr(type, \";\", attribute, \"=\", attributes[attribute]);";
"endfor";
"";
"return type;";
"";
"/* security audit on Sat Oct  1 18:04:47 2011 EDT */";
"";
"chunk_length:15";
"chunk_type:source";
"content_type:application/x-moocode";
"updated_at:Sat Oct  1 18:22:18 2011 EDT";
"-=-=-mxyzptlk-=-=-";
.
#0:21
{object, verb} = args;
valid(object) || raise(E_INVARG);
`{owner, perms, name} = verb_info(object, verb) ! ANY' || raise(E_VERBNF);
callerp = caller_perms();
((`callerp.wizard ! ANY' || (valid(callerp) && (callerp == owner))) || index(perms, "w")) || raise(E_PERM);
`callerp.programmer ! ANY' || raise(E_PERM);
code = verb_code(object, verb);
set_task_perms(callerp);
chunks = this:_unpack_verb_code(code);
if (length(chunks) == 1)
raise(E_INVARG, "Nothing to commit: legacy verb");
endif
if (`chunks[2]["metadata"]["state"] ! E_RANGE' != "dirty")
raise(E_INVARG, "Nothing to commit: not dirty");
endif
chunks[2]["metadata"]["state"] = "clean";
code = this:_pack_verb_code(chunks);
return set_verb_code(object, verb, code);
return;
"{object, verb} = args;";
"";
"/* check arguments */";
"valid(object) || raise(E_INVARG);";
"`{owner, perms, name} = verb_info(object, verb) ! ANY' || raise(E_VERBNF);";
"";
"/* check permissions */";
"callerp = caller_perms();";
"`callerp.wizard ! ANY' || (valid(callerp) && callerp == owner) || index(perms, \"w\") || raise(E_PERM);";
"`callerp.programmer ! ANY' || raise(E_PERM);";
"";
"/* grab verb code before dropping perms */";
"code = verb_code(object, verb);";
"";
"/* drop wiz-perms */";
"set_task_perms(callerp);";
"";
"chunks = this:_unpack_verb_code(code);";
"";
"if (length(chunks) == 1)";
"  raise(E_INVARG, \"Nothing to commit: legacy verb\");";
"endif";
"";
"if (`chunks[2][\"metadata\"][\"state\"] ! E_RANGE' != \"dirty\")";
"  raise(E_INVARG, \"Nothing to commit: not dirty\");";
"endif";
"";
"chunks[2][\"metadata\"][\"state\"] = \"clean\";";
"";
"code = this:_pack_verb_code(chunks);";
"";
"return set_verb_code(object, verb, code);";
"";
"chunk_length:32";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:3F24BA2FF18F536629EDF45CD7714056CA68E10F";
"state:clean";
"updated_at:Mon May 27 10:24:42 2013 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"[\"pre.usage\",[\"code.language-moocode\",[\"em\",\"LIST\"],\" \",[\"strong\",\"$verb_commit\"],\"(\",[\"var\",\"OBJ object\"],\", \",[\"var\",\"STR verb\"],\")\"]]";
"[\"p\",\"Commits the changes to \",[\"var\",\"verb\"],\" on \",[\"var\",\"object\"],\". If successful, it returns the empty list. Otherwise, it returns a list of error messages.\"]";
"[\"p\",\"If \",[\"var\",\"object\"],\" is not valid, then \",[\"em\",\"E_INVARG\"],\" is raised. \",\"If \",[\"var\",\"object\"],\" does not define \",[\"var\",\"verb\"],\", then \",[\"em\",\"E_VERBNF\"],\" is raised. \",\"If \",[\"var\",\"verb\"],\" is not changed, then \",[\"em\",\"E_INVARG\"],\" is raised. \",\"If the programmer does not have write permission \",[\"var\",\"verb\"],\", then \",[\"em\",\"E_PERM\"],\" is raised. \",\"If the programmer is not, in fact, a programmer, then \",[\"em\",\"E_PERM\"],\" is raised.\"]";
"[\"pre.example\",[\"code.language-moocode\",\"$verb_commit(#100, \\\"foobar\\\")    => {}\"]]";
"";
"chunk_length:4";
"chunk_type:documentation";
"content_type:application/json";
"sha1:A542FB275A9D972774B2D0410AC9449A4B35C226";
"-=-=-mxyzptlk-=-=-";
.
#0:22
{object, verb} = args;
valid(object) || raise(E_INVARG);
`{owner, perms, name} = verb_info(object, verb) ! ANY' || raise(E_VERBNF);
callerp = caller_perms();
((`callerp.wizard ! ANY' || (valid(callerp) && (callerp == owner))) || index(perms, "w")) || raise(E_PERM);
`callerp.programmer ! ANY' || raise(E_PERM);
code = verb_code(object, verb);
set_task_perms(callerp);
chunks = this:_unpack_verb_code(code);
if (length(chunks) == 1)
raise(E_INVARG, "Nothing to revert: legacy verb");
endif
if (`chunks[2]["metadata"]["state"] ! E_RANGE' != "dirty")
raise(E_INVARG, "Nothing to revert: not dirty");
endif
if (length(chunks) < 3)
raise(E_INVARG, "Nothing to revert");
endif
keep = chunks[3..$];
chunk = keep[1];
content_type = chunk["metadata"]["content_type"];
{type, attributes} = this:_parse_content_type(content_type);
content_type = this:_generate_content_type({type, attributes});
if ((type == "application/x-moocode") && (!attributes))
code = chunk["source"];
elseif (`valid(compiler = this:_match_external_compiler(type, attributes)) ! ANY')
{status, code} = compiler:compile(chunk["source"], attributes);
if (!status)
return {tostr("Compilation failed:  ", code)};
endif
else
return {tostr("Invalid content type:  ", type)};
endif
code = this:_pack_verb_code({["code" -> code], @keep});
return set_verb_code(object, verb, code);
return;
"{object, verb} = args;";
"";
"/* check arguments */";
"valid(object) || raise(E_INVARG);";
"`{owner, perms, name} = verb_info(object, verb) ! ANY' || raise(E_VERBNF);";
"";
"/* check permissions */";
"callerp = caller_perms();";
"`callerp.wizard ! ANY' || (valid(callerp) && callerp == owner) || index(perms, \"w\") || raise(E_PERM);";
"`callerp.programmer ! ANY' || raise(E_PERM);";
"";
"/* grab verb code before dropping perms */";
"code = verb_code(object, verb);";
"";
"/* drop wiz-perms */";
"set_task_perms(callerp);";
"";
"chunks = this:_unpack_verb_code(code);";
"";
"if (length(chunks) == 1)";
"  raise(E_INVARG, \"Nothing to revert: legacy verb\");";
"endif";
"";
"if (`chunks[2][\"metadata\"][\"state\"] ! E_RANGE' != \"dirty\")";
"  raise(E_INVARG, \"Nothing to revert: not dirty\");";
"endif";
"";
"if (length(chunks) < 3)";
"  raise(E_INVARG, \"Nothing to revert\");";
"endif";
"";
"/* discard the raw code and the dirty revision */";
"keep = chunks[3..$];";
"chunk = keep[1];";
"";
"/* a revision should _always_ have a content type */";
"content_type = chunk[\"metadata\"][\"content_type\"];";
"";
"/* parse the content type to validate it, then generate it in canonical form */";
"{type, attributes} = this:_parse_content_type(content_type);";
"content_type = this:_generate_content_type({type, attributes});";
"";
"/* natively supported... no external compilation necessary */";
"if (type == \"application/x-moocode\" && !attributes)";
"  code = chunk[\"source\"];";
"";
"/* find an external compiler and compile */";
"elseif (`valid(compiler = this:_match_external_compiler(type, attributes)) ! ANY')";
"  {status, code} = compiler:compile(chunk[\"source\"], attributes);";
"  if (!status)";
"    return {tostr(\"Compilation failed:  \", code)};";
"  endif";
"";
"/* fail */";
"else";
"  return {tostr(\"Invalid content type:  \", type)};";
"endif";
"";
"code = this:_pack_verb_code({[\"code\" -> code], @keep});";
"";
"return set_verb_code(object, verb, code);";
"";
"chunk_length:61";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:8901DE6C4C326C8BF21B05EF6F2131018E9A854C";
"state:clean";
"updated_at:Mon May 27 10:25:18 2013 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"[\"pre.usage\",[\"code.language-moocode\",[\"em\",\"LIST\"],\" \",[\"strong\",\"$verb_revert\"],\"(\",[\"var\",\"OBJ object\"],\", \",[\"var\",\"STR verb\"],\")\"]]";
"[\"p\",\"Reverts the changes to \",[\"var\",\"verb\"],\" on \",[\"var\",\"object\"],\". If successful, it returns the empty list. Otherwise, it returns a list of error messages.\"]";
"[\"p\",\"If \",[\"var\",\"object\"],\" is not valid, then \",[\"em\",\"E_INVARG\"],\" is raised. \",\"If \",[\"var\",\"object\"],\" does not define \",[\"var\",\"verb\"],\", then \",[\"em\",\"E_VERBNF\"],\" is raised. \",\"If \",[\"var\",\"verb\"],\" is not changed, then \",[\"em\",\"E_INVARG\"],\" is raised. \",\"If the programmer does not have write permission \",[\"var\",\"verb\"],\", then \",[\"em\",\"E_PERM\"],\" is raised. \",\"If the programmer is not, in fact, a programmer, then \",[\"em\",\"E_PERM\"],\" is raised.\"]";
"[\"pre.example\",[\"code.language-moocode\",\"$verb_revert(#100, \\\"foobar\\\")    => {}\"]]";
"";
"chunk_length:4";
"chunk_type:documentation";
"content_type:application/json";
"sha1:96FC8FBCE8A3BC9B21A72359EF91D633054470E1";
"-=-=-mxyzptlk-=-=-";
.
#0:23
{object, verb} = args;
valid(object) || raise(E_INVARG);
`{owner, perms, name} = verb_info(object, verb) ! ANY' || raise(E_VERBNF);
callerp = caller_perms();
((`callerp.wizard ! ANY' || (valid(callerp) && (callerp == owner))) || index(perms, "w")) || raise(E_PERM);
`callerp.programmer ! ANY' || raise(E_PERM);
code = verb_code(object, verb);
set_task_perms(callerp);
chunks = this:_unpack_verb_code(code);
if (length(chunks) == 1)
raise(E_INVARG, "Nothing to truncate: legacy verb");
endif
revisions = toint(chunks[2]["metadata"]["revision"]);
chunks[3..revisions + 1] = {};
chunks[2]["metadata"]["revision"] = 1;
code = this:_pack_verb_code(chunks);
return set_verb_code(object, verb, code);
return;
"{object, verb} = args;";
"";
"/* check arguments */";
"valid(object) || raise(E_INVARG);";
"`{owner, perms, name} = verb_info(object, verb) ! ANY' || raise(E_VERBNF);";
"";
"/* check permissions */";
"callerp = caller_perms();";
"`callerp.wizard ! ANY' || (valid(callerp) && callerp == owner) || index(perms, \"w\") || raise(E_PERM);";
"`callerp.programmer ! ANY' || raise(E_PERM);";
"";
"/* grab verb code before dropping perms */";
"code = verb_code(object, verb);";
"";
"/* drop wiz-perms */";
"set_task_perms(callerp);";
"";
"chunks = this:_unpack_verb_code(code);";
"";
"if (length(chunks) == 1)";
"  raise(E_INVARG, \"Nothing to truncate: legacy verb\");";
"endif";
"";
"revisions = toint(chunks[2][\"metadata\"][\"revision\"]);";
"";
"chunks[3..(revisions + 1)] = {};";
"";
"chunks[2][\"metadata\"][\"revision\"] = 1;";
"";
"code = this:_pack_verb_code(chunks);";
"";
"return set_verb_code(object, verb, code);";
"";
"chunk_length:32";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:A2D886B13B30F6D6AE3B286BD18D3895F7C5A1A9";
"state:clean";
"updated_at:Mon May 27 08:51:19 2013 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"[\"pre.usage\",[\"code.language-moocode\",[\"em\",\"LIST\"],\" \",[\"strong\",\"$verb_truncate*_revisions\"],\"(\",[\"var\",\"OBJ object\"],\", \",[\"var\",\"STR verb\"],\")\"]]";
"[\"p\",\"Truncates the history of changes to \",[\"var\",\"verb\"],\" on \",[\"var\",\"object\"],\", leaving only the most recent revision as the first revision. If successful, it returns the empty list. Otherwise, it returns a list of error messages.\"]";
"[\"p\",\"If \",[\"var\",\"object\"],\" is not valid, then \",[\"em\",\"E_INVARG\"],\" is raised. \",\"If \",[\"var\",\"object\"],\" does not define \",[\"var\",\"verb\"],\", then \",[\"em\",\"E_VERBNF\"],\" is raised. \",\"If \",[\"var\",\"verb\"],\" is a legacy verb (does not have revision metadata), then \",[\"em\",\"E_INVARG\"],\" is raised. \",\"If the programmer does not have write permission \",[\"var\",\"verb\"],\", then \",[\"em\",\"E_PERM\"],\" is raised. \",\"If the programmer is not, in fact, a programmer, then \",[\"em\",\"E_PERM\"],\" is raised.\"]";
"[\"pre.example\",[\"code.language-moocode\",\"$verb_truncate_revisions(#100, \\\"foobar\\\")    => {}\"]]";
"";
"chunk_length:4";
"chunk_type:documentation";
"content_type:application/json";
"sha1:9F7FAF9FFCD7B906E8BD4B93A303D9C0AF3E625C";
"-=-=-mxyzptlk-=-=-";
.
#0:24
{reference, ?options = []} = args;
packages = $composed.packages;
provides_cache = $composed.provides_cache;
requires_cache = $composed.requires_cache;
set_task_perms(perms = caller_perms());
enclosing_package = `options["package"] ! E_RANGE';
dynamic_scope = `options["dynamic"] ! E_RANGE';
if ((typeof(enclosing_package) != ERR) && (typeof(dynamic_scope) != ERR))
raise(E_INVARG);
elseif (typeof(enclosing_package) != ERR)
if ((perms.wizard && valid(enclosing_package)) && (enclosing_package in packages))
elseif (perms.wizard)
raise(E_INVARG);
else
raise(E_PERM);
endif
else
if (dynamic_scope)
enclosing_package = callers()[1][1];
else
enclosing_package = callers()[1][4];
endif
while (valid(enclosing_package) && (!(enclosing_package in packages)))
enclosing_package = enclosing_package.location;
endwhile
endif
if (typeof(enclosing_package) != OBJ)
raise(E_TYPE, "Type mismatch", enclosing_package);
elseif (!valid(enclosing_package))
raise(E_INVIND, "No enclosing package", enclosing_package);
endif
if (reference == "__package__")
return enclosing_package;
elseif (reference == "__owner__")
return enclosing_package.owner;
elseif (r = match(reference, "^%([a-z_][a-z0-9_]*%)%(|%([a-z][a-z0-9_]*%)%)?$"))
reference = r[4][r[3][1][1]..r[3][1][2]];
package = `r[4][r[3][3][1]..r[3][3][2]] ! E_RANGE';
if ((!package) || (package == enclosing_package.identifier))
package = enclosing_package;
else
if (`versions = requires_cache[package] ! E_RANGE')
for packages, version in (versions)
if (enclosing_package in packages)
package = provides_cache[package][version][1];
break;
endif
endfor
else
package = $nothing;
endif
endif
for entry in (`package.manifest ! ANY => {}')
{object, label} = entry;
if (reference == label)
return object;
endif
endfor
endif
return $failed_match;
return;
"{reference, ?options = []} = args;";
"";
"/* get package info... */";
"packages = $composed.packages;";
"provides_cache = $composed.provides_cache;";
"requires_cache = $composed.requires_cache;";
"";
"/* ...then drop perms... */";
"set_task_perms(perms = caller_perms());";
"";
"enclosing_package = `options[\"package\"] ! E_RANGE';";
"dynamic_scope = `options[\"dynamic\"] ! E_RANGE';";
"";
"if (typeof(enclosing_package) != ERR && typeof(dynamic_scope) != ERR)";
"   raise(E_INVARG);";
"";
"/* If the caller has wiz-perms, it can set the enclosing package";
" * explicitly.  The enclosing package is the point-of-view from";
" * which we look up references.";
" */";
"elseif (typeof(enclosing_package) != ERR)";
"  if (perms.wizard && valid(enclosing_package) && (enclosing_package in packages))";
"    ;";
"  elseif (perms.wizard)";
"    raise(E_INVARG);";
"  else";
"    raise(E_PERM);";
"  endif";
"";
"else";
"  /* If `dynamic_scope' is true, set the scope of the search to";
"   * the point of use rather than the point of definition.";
"   */";
"  if (dynamic_scope)";
"    enclosing_package = callers()[1][1];";
"  else";
"    enclosing_package = callers()[1][4];";
"  endif";
"";
"  while (valid(enclosing_package) && !(enclosing_package in packages))";
"    enclosing_package = enclosing_package.location;";
"  endwhile";
"";
"endif";
"";
"/* Raise an error if we make it to the top without finding an";
" * enclosing package -- this typically means that `$lookup()' has been";
" * called from a verb on an object that is in a package that has not";
" * yet been _installed_.";
" */";
"if (typeof(enclosing_package) != OBJ)";
"  raise(E_TYPE, \"Type mismatch\", enclosing_package);";
"elseif (!valid(enclosing_package))";
"  raise(E_INVIND, \"No enclosing package\", enclosing_package);";
"endif";
"";
"/* find the reference */";
"if (reference == \"__package__\")";
"  return enclosing_package;";
"";
"elseif (reference == \"__owner__\")";
"  return enclosing_package.owner;";
"";
"elseif (r = match(reference, \"^%([a-z_][a-z0-9_]*%)%(|%([a-z][a-z0-9_]*%)%)?$\"))";
"  reference = r[4][r[3][1][1]..r[3][1][2]];";
"  package = `r[4][r[3][3][1]..r[3][3][2]] ! E_RANGE';";
"  if (!package || (package == enclosing_package.identifier))";
"    package = enclosing_package;";
"  else";
"    if (`versions = requires_cache[package] ! E_RANGE')";
"      for packages, version in (versions)";
"        if (enclosing_package in packages)";
"          package = provides_cache[package][version][1];";
"          break;";
"        endif";
"      endfor";
"    else";
"      package = $nothing;";
"    endif";
"  endif";
"  for entry in (`package.manifest ! ANY => {}')";
"    {object, label} = entry;";
"    if (reference == label)";
"      return object;";
"    endif";
"  endfor";
"endif";
"";
"return $failed_match;";
"";
"chunk_length:89";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:EA2837ED97EE0405D2B20A8B990CF445E9461AD3";
"state:clean";
"updated_at:Fri Aug  2 22:27:22 2013 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"[\"pre.usage\",[\"code.language-moocode\",[\"em\",\"OBJ\"],\" \",[\"strong\",\"$lookup_reference\"],\"(\",[\"var\",\"STR reference\"],\")\"]]";
"[\"p\",\"Dynamically resolves the specified \",[\"var\",\"reference\"],\" into the associated object in an installed package. The \",[\"var\",\"reference\"],\" can refer to an object in the enclosing package, or can explicitly refer to an object in a package on which the enclosing package depends. \",\"The format of \",[\"var\",\"reference\"],\" is \\\"object|package\\\". The \",[\"em\",\"package\"],\" part of the reference is optional. If present, it refers to a package by its identifier. \",\"The \",[\"em\",\"object\"],\" part of the reference is required and must be listed in the package manifest.\"]";
"[\"pre.example\",[\"code.language-moocode\",\"$lookup(\\\"no_such_object\\\")    => $failed_match\"],[\"code.language-moocode\",\"$lookup(\\\"bilbo|baggins\\\")     => #12345\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:7AD2FEBA4B4C447B2260D550B2762EB86C2F7FBD";
"-=-=-mxyzptlk-=-=-";
.
#0:25
{type, attributes, ?external_compilers = $external_compilers} = args;
for value, key in (external_compilers)
if ((parsed = this:_parse_content_type(key)) && (parsed[1] == type))
pattern = `parsed[2]["version"] ! E_RANGE';
version = `attributes["version"] ! E_RANGE';
if (!pattern)
return value;
elseif (version)
pattern = strsub(strsub(pattern, ".", "%."), "*", "[^%.]*");
if (match(version, pattern))
return value;
endif
endif
endif
endfor
return $failed_match;
return;
"{type, attributes, ?external_compilers = $external_compilers} = args;";
"";
"for value, key in (external_compilers)";
"  if ((parsed = this:_parse_content_type(key)) && parsed[1] == type)";
"    pattern = `parsed[2][\"version\"] ! E_RANGE';";
"    version = `attributes[\"version\"] ! E_RANGE';";
"    if (!pattern)";
"      return value;";
"    elseif (version)";
"      pattern = strsub(strsub(pattern, \".\", \"%.\"), \"*\", \"[^%.]*\");";
"      if (match(version, pattern))";
"        return value;";
"      endif";
"    endif";
"  endif";
"endfor";
"";
"return $failed_match;";
"";
"chunk_length:18";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:AFFF1A06980617D1A04465EE4B987EF294E61836";
"state:clean";
"updated_at:Thu Dec 20 05:58:54 2012 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#0:26
{permit, ?owner = 0} = args;
task_local = task_local();
caller_perms = caller_perms();
if ((owner != 0) && (owner != caller_perms))
if (!caller_perms.wizard)
raise(E_PERM, "Invalid owner");
elseif ((typeof(owner) != OBJ) || (!valid(owner)))
raise(E_INVARG, "Invalid owner");
endif
else
owner = caller_perms;
endif
if (!`permits = task_local["permits"] ! E_RANGE')
permits = {};
endif
if ((len = length(permits)) > 99)
raise(E_INVARG, "Too many permits");
endif
for i in [1..len]
if (permits[i] == {owner, permit})
raise(E_INVARG, "Duplicate permit");
endif
endfor
task_local["permits"] = listappend(permits, {owner, permit});
set_task_local(task_local);
return permit;
return;
"/* Grants the stated permit.  There is no restriction on what types";
" * of values can be used as permits.  The `owner' defaults to the";
" * caller's permissions, however wizardly players can change the";
" * owner.  Both the permit and the owner are used during matching.";
" */";
"";
"{permit, ?owner = 0} = args;";
"";
"task_local = task_local();";
"caller_perms = caller_perms();";
"";
"if (owner != 0 && owner != caller_perms)";
"  if (!caller_perms.wizard)";
"    raise(E_PERM, \"Invalid owner\");";
"  elseif (typeof(owner) != OBJ || !valid(owner))";
"    raise(E_INVARG, \"Invalid owner\");";
"  endif";
"else";
"  owner = caller_perms;";
"endif";
"";
"if (!(`permits = task_local[\"permits\"] ! E_RANGE'))";
"  permits = {};";
"endif";
"";
"if ((len = length(permits)) > 99)";
"  raise(E_INVARG, \"Too many permits\");";
"endif";
"";
"for i in [1..len]";
"  if (permits[i] == {owner, permit})";
"    raise(E_INVARG, \"Duplicate permit\");";
"  endif";
"endfor";
"";
"task_local[\"permits\"] = listappend(permits, {owner, permit});";
"set_task_local(task_local);";
"";
"return permit;";
"";
"chunk_length:39";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:1725814E8F3E0D1990E3B4CB530E1E2FC038B0E0";
"state:clean";
"updated_at:Fri Jan 11 11:34:32 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"[\"pre.usage\",[\"code.language-moocode\",[\"em\",\"none\"],\" \",[\"strong\",\"$grant\"],\"(\",[\"var\",\"permit\"],\" [, \",[\"var\",\"OBJ owner\"],\"])\"]]";
"[\"p\",\"Grants the specified \",[\"var\",\"permit\"],\". There is no restriction on what types of values can be used as permits. The \",[\"var\",\"owner\"],\" defaults to the caller's permissions, however wizardly callers can specify the owner. Both \",[\"var\",\"permit\"],\" and \",[\"var\",\"owner\"],\" are used during matching. \",\"The extent of a grant is limited to the duration of the task in which the grant occurred.\"]";
"[\"pre.example\",[\"code.language-moocode\",\"$grant(\\\"a string\\\", player)\"],[\"code.language-moocode\",\"$grant($fancy.permit:create())\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:9B1D472880B6EDFA5DD26D7FCEACD5C5C131FD46";
"-=-=-mxyzptlk-=-=-";
.
#0:27
{permit, ?owner = 0} = args;
task_local = task_local();
caller_perms = caller_perms();
if ((owner != 0) && (owner != caller_perms))
if (!caller_perms.wizard)
raise(E_PERM, "Invalid owner");
elseif ((typeof(owner) != OBJ) || (!valid(owner)))
raise(E_INVARG, "Invalid owner");
endif
else
owner = caller_perms;
endif
if (!`permits = task_local["permits"] ! E_RANGE')
permits = {};
endif
len = length(permits);
for i in [1..len]
if (permits[i] == {owner, permit})
task_local["permits"] = listdelete(permits, i);
set_task_local(task_local);
return permit;
endif
endfor
raise(E_INVARG, "Invalid permit");
return;
"/* Revokes the stated permit.  A player can only revoke his/her";
" * granted permits, however a wizardly player can specify a value for";
" * `owner' and revoke that owner's permits.";
" */";
"";
"{permit, ?owner = 0} = args;";
"";
"task_local = task_local();";
"caller_perms = caller_perms();";
"";
"if (owner != 0 && owner != caller_perms)";
"  if (!caller_perms.wizard)";
"    raise(E_PERM, \"Invalid owner\");";
"  elseif (typeof(owner) != OBJ || !valid(owner))";
"    raise(E_INVARG, \"Invalid owner\");";
"  endif";
"else";
"  owner = caller_perms;";
"endif";
"";
"if (!(`permits = task_local[\"permits\"] ! E_RANGE'))";
"  permits = {};";
"endif";
"";
"len = length(permits);";
"";
"for i in [1..len]";
"  if (permits[i] == {owner, permit})";
"    task_local[\"permits\"] = listdelete(permits, i);";
"    set_task_local(task_local);";
"";
"    return permit;";
"  endif";
"endfor";
"";
"raise(E_INVARG, \"Invalid permit\");";
"";
"chunk_length:36";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:3D5960742E6BC6BF7D299D46EFD097C96A8CA37F";
"state:clean";
"updated_at:Fri Jan 11 11:34:32 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"[\"pre.usage\",[\"code.language-moocode\",[\"em\",\"none\"],\" \",[\"strong\",\"$revoke\"],\"(\",[\"var\",\"permit\"],\" [, \",[\"var\",\"OBJ owner\"],\"])\"]]";
"[\"p\",\"Revokes the specified \",[\"var\",\"permit\"],\". A player can only revoke his/her granted permits, however a wizardly player can specify a value for \",[\"var\",\"owner\"],\" and revoke that player's permits.\"]";
"[\"pre.example\",[\"code.language-moocode\",\"$revoke(permit)\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:6EF8C79C178F195758446905F17A922614F36EA1";
"-=-=-mxyzptlk-=-=-";
.
#0:28
{permit, owner, ?subject = 0} = args;
task_local = task_local();
caller_perms = caller_perms();
for caller in (callers())
if (caller_perms != caller[3])
break;
endif
endfor
if (!valid(caller[3]))
raise(E_INVARG);
endif
caller_perms = caller[3];
if ((subject != 0) && (subject != caller_perms))
if (!caller_perms().wizard)
raise(E_PERM, "Invalid subject");
elseif ((typeof(subject) != OBJ) || (!valid(subject)))
raise(E_INVARG, "Invalid subject");
endif
else
subject = caller_perms;
endif
if (!`permits = task_local["permits"] ! E_RANGE')
return $failed_match;
endif
if (`valid(permit) ! E_TYPE')
for pair in (permits)
{o, p} = pair;
if (((o == owner) && `isa(p, permit) ! E_TYPE') && p:permit(permit, owner, subject))
return p;
endif
endfor
else
for pair in (permits)
if (pair == {owner, permit})
return permit;
endif
endfor
endif
return $failed_match;
return;
"/* This is called by a verb to determine whether or not to perform a";
" * risky operation on behalf of _its_ caller, the `subject'.  This";
" * verb finds the subject by walking the call stack, looking for the";
" * first verb running with permissions different from its immediate";
" * caller.  The `owner' may be the ultimate direct/indirect object of";
" * the action (in any event, it must be the object that granted the";
" * permit).";
" */";
"";
"{permit, owner, ?subject = 0} = args;";
"";
"task_local = task_local();";
"caller_perms = caller_perms();";
"";
"for caller in (callers())";
"  if (caller_perms != caller[3])";
"    break;";
"  endif";
"endfor";
"";
"if (!valid(caller[3]))";
"  raise(E_INVARG);";
"endif";
"";
"caller_perms = caller[3];";
"";
"if (subject != 0 && subject != caller_perms)";
"  if (!caller_perms().wizard) /* note! must check the immediate caller, here */";
"    raise(E_PERM, \"Invalid subject\");";
"  elseif (typeof(subject) != OBJ || !valid(subject))";
"    raise(E_INVARG, \"Invalid subject\");";
"  endif";
"else";
"  subject = caller_perms;";
"endif";
"";
"if (!(`permits = task_local[\"permits\"] ! E_RANGE'))";
"  return $failed_match;";
"endif";
"";
"if (`valid(permit) ! E_TYPE')";
"  for pair in (permits)";
"    {o, p} = pair;";
"    if (o == owner && `isa(p, permit) ! E_TYPE' && p:permit(permit, owner, subject))";
"      return p;";
"    endif";
"  endfor";
"else";
"  for pair in (permits)";
"    if (pair == {owner, permit})";
"      return permit;";
"    endif";
"  endfor";
"endif";
"";
"return $failed_match;";
"";
"chunk_length:56";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:E6A48E5A942EADA49DC00CB8A20C806A5DE59F5E";
"state:clean";
"updated_at:Fri Jan 11 12:05:57 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"[\"pre.usage\",[\"code.language-moocode\",[\"em\",\"permit\"],\" \",[\"strong\",\"$match_permit\"],\"(\",[\"var\",\"permit\"],\", \",[\"var\",\"OBJ owner\"],\" [, \",[\"var\",\"OBJ subject\"],\"])\"]]";
"[\"p\",\"Called by a verb to determine whether or not to perform an operation on behalf of \",[\"em\",\"its\"],\" caller, the \",[\"var\",\"subject\"],\". If not specified by a wizardly player, this verb finds the subject by walking the call stack, looking for the first verb running with permissions different from the immediate caller. The \",[\"var\",\"owner\"],\" may be the ultimate direct/indirect object of the action (but, it must be the object that granted the permit).\"]";
"[\"pre.example\",[\"code.language-moocode\",\"$match_permit(\\\"i-can-haz\\\", player)    => \\\"i-can-haz\\\"\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:AE50890A6DA78C5E7821DA9C0DE56463EE71BB40";
"-=-=-mxyzptlk-=-=-";
.
#0:29
{object, verb, @options} = args;
valid(object) || raise(E_INVARG);
`{owner, flags, name} = verb_info(object, verb) ! E_VERBNF' || raise(E_VERBNF);
perms = caller_perms();
((perms.wizard || (perms == owner)) || index(flags, "r")) || raise(E_PERM);
perms.programmer || raise(E_PERM);
verb_code = verb_code(object, verb, 0, 0);
set_task_perms(perms);
chunks = this:_unpack_verb_code(verb_code);
for chunk in (chunks)
if (`chunk["metadata"]["chunk_type"] ! E_RANGE' == "documentation")
documentation = `chunk["source"] ! E_RANGE => {}';
for line, i in (documentation)
documentation[i] = parse_json(line, "embedded-types");
endfor
return documentation;
endif
endfor
return {};
return;
"{object, verb, @options} = args;";
"";
"/* check arguments and permissions */";
"valid(object) || raise(E_INVARG);";
"`{owner, flags, name} = verb_info(object, verb) ! E_VERBNF' || raise(E_VERBNF);";
"perms = caller_perms();";
"perms.wizard || (perms == owner) || index(flags, \"r\") || raise(E_PERM);";
"perms.programmer || raise(E_PERM);";
"";
"/* grab verb code before dropping perms */";
"verb_code = verb_code(object, verb, 0, 0);";
"";
"/* drop wiz-perms */";
"set_task_perms(perms);";
"";
"chunks = this:_unpack_verb_code(verb_code);";
"";
"for chunk in (chunks)";
"  if (`chunk[\"metadata\"][\"chunk_type\"] ! E_RANGE' == \"documentation\")";
"    documentation = `chunk[\"source\"] ! E_RANGE => {}';";
"    for line, i in (documentation)";
"      documentation[i] = parse_json(line, \"embedded-types\");";
"    endfor";
"    return documentation;";
"  endif";
"endfor";
"";
"return {};";
"";
"chunk_length:28";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:5D1BCE4D4B551A4D46730A9584A5598056638808";
"state:clean";
"updated_at:Fri Mar 29 07:16:34 2013 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"LIST\"],\" \",[\"strong\",\"$verb_doc\"],\"(\",[\"var\",\"OBJ object\"],\", \",[\"var\",\"STR verb\"],\")\"]]";
"[\"p\",\"Returns the documentation for \",[\"var\",\"verb\"],\" on \",[\"var\",\"object\"],\".\"]";
"[\"p\",\"If \",[\"var\",\"object\"],\" is not valid, then \",[\"em\",\"E_INVARG\"],\" is raised. If \",[\"var\",\"object\"],\" does not define \",[\"var\",\"verb\"],\", then \",[\"em\",\"E_VERBNF\"],\" is raised. If the programmer does not have read permission on the verb in question, then \",[\"strong\",\"$verb_doc()\"],\" raises \",[\"em\",\"E_PERM\"],\". If the programmer is not, in fact, a programmer, then \",[\"em\",\"E_PERM\"],\" is raised.\"]";
"[\"p\",\"The documentation is represented as a list of tagged elements and lines of text. Lines of text are simple strings. Tagged elements are lists with the following form:\"]";
"[\"pre\",\"{STR tag [, MAP attributes] [, LIST body]}\"]";
"[\"p\",\"The \",[\"var\",\"body\"],\", if present, is itself a list of tagged elements and lines of text.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"{\\\"a line of documentation\\\"}\"],[\"code\",{\"class\":\"language-moocode\"},\"{\\\"a \\\", {\\\"tag\\\", \\\"line\\\"}, \\\" of documentation\\\"}\"],[\"code\",{\"class\":\"language-moocode\"},\"{\\\"a \\\", {\\\"tag\\\", [\\\"key\\\" -> \\\"value\\\"], \\\"line\\\"}, \\\" of documentation\\\"}\"],[\"code\",{\"class\":\"language-moocode\"},\"{{\\\"tag\\\"}, {\\\"tag\\\"}, {\\\"tag\\\"}}\"]]";
"";
"chunk_length:7";
"chunk_type:documentation";
"content_type:application/json";
"sha1:FCBBAEA4AF9D0760DCEC01D5AE7480D4A02A1DA2";
"-=-=-mxyzptlk-=-=-";
.
#0:30
{object, verb, documentation, @options} = args;
valid(object) || raise(E_INVARG);
`{owner, flags, name} = verb_info(object, verb) ! E_VERBNF' || raise(E_VERBNF);
perms = caller_perms();
((perms.wizard || (perms == owner)) || index(flags, "w")) || raise(E_PERM);
perms.programmer || raise(E_PERM);
if (typeof(documentation) != LIST)
raise(E_INVARG, tostr("Invalid format: ", toliteral(documentation)), documentation);
endif
errors = {};
for line in (documentation)
try
this:_validate_doc_format(line);
except ex (E_INVARG)
errors = {@errors, ex[2]};
endtry
endfor
if (errors)
return errors;
endif
verb_code = verb_code(object, verb, 0, 0);
set_task_perms(perms);
chunks = this:_unpack_verb_code(verb_code);
(length(chunks) > 1) || raise(E_INVARG, "Cannot document legacy verbs");
saved_chunks = {};
for chunk in (chunks)
if (`chunk["metadata"]["chunk_type"] ! E_RANGE' != "documentation")
saved_chunks = {@saved_chunks, chunk};
endif
endfor
metadata = ["chunk_type" -> "documentation", "chunk_length" -> length(documentation), "content_type" -> "application/json", "sha1" -> value_hash(documentation, "sha1")];
for line, i in (documentation)
documentation[i] = generate_json(line, "embedded-types");
endfor
code = this:_pack_verb_code({@saved_chunks, ["metadata" -> metadata, "source" -> documentation]});
return set_verb_code(object, verb, code);
return;
"{object, verb, documentation, @options} = args;";
"";
"/* check arguments and permissions */";
"valid(object) || raise(E_INVARG);";
"`{owner, flags, name} = verb_info(object, verb) ! E_VERBNF' || raise(E_VERBNF);";
"perms = caller_perms();";
"perms.wizard || (perms == owner) || index(flags, \"w\") || raise(E_PERM);";
"perms.programmer || raise(E_PERM);";
"";
"/* check format */";
"if (typeof(documentation) != LIST)";
"  raise(E_INVARG, tostr(\"Invalid format: \", toliteral(documentation)), documentation);";
"endif";
"";
"errors = {};";
"for line in (documentation)";
"  try";
"    this:_validate_doc_format(line);";
"  except ex (E_INVARG)";
"    errors = {@errors, ex[2]};";
"  endtry";
"endfor";
"if (errors)";
"  return errors;";
"endif";
"";
"/* grab verb code before dropping perms */";
"verb_code = verb_code(object, verb, 0, 0);";
"";
"/* drop wiz-perms */";
"set_task_perms(perms);";
"";
"chunks = this:_unpack_verb_code(verb_code);";
"";
"/* must not be a legacy/naked verb */";
"length(chunks) > 1 || raise(E_INVARG, \"Cannot document legacy verbs\");";
"";
"/* delete existing doc chunks */";
"saved_chunks = {};";
"for chunk in (chunks)";
"  if (`chunk[\"metadata\"][\"chunk_type\"] ! E_RANGE' != \"documentation\")";
"    saved_chunks = {@saved_chunks, chunk};";
"  endif";
"endfor";
"";
"metadata = [";
"  \"chunk_type\" -> \"documentation\",";
"  \"chunk_length\" -> length(documentation),";
"  \"content_type\" -> \"application/json\",";
"  \"sha1\" -> value_hash(documentation, \"sha1\")";
"];";
"";
"for line, i in (documentation)";
"  documentation[i] = generate_json(line, \"embedded-types\");";
"endfor";
"";
"code = this:_pack_verb_code({@saved_chunks, [\"metadata\" -> metadata, \"source\" -> documentation]});";
"";
"return set_verb_code(object, verb, code);";
"";
"chunk_length:59";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:F43FE55E1F9776E709507E08A54EB5A5BEB4556F";
"state:clean";
"updated_at:Fri Mar 29 13:07:11 2013 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"LIST\"],\" \",[\"strong\",\"$set_verb_doc\"],\"(\",[\"var\",\"OBJ object\"],\", \",[\"var\",\"STR verb\"],\", \",[\"var\",\"LIST documentation\"],\")\"]]";
"[\"p\",\"Sets the documentation of \",[\"var\",\"verb\"],\" on \",[\"var\",\"object\"],\".\"]";
"[\"p\",\"If \",[\"var\",\"object\"],\" is not valid, then \",[\"em\",\"E_INVARG\"],\" is raised. If \",[\"var\",\"object\"],\" does not define \",[\"var\",\"verb\"],\", then \",[\"em\",\"E_VERBNF\"],\" is raised. If the programmer does not have write permission on the verb in question, then \",[\"strong\",\"$set_verb_doc()\"],\" raises \",[\"em\",\"E_PERM\"],\". If the programmer is not, in fact, a programmer, then \",[\"em\",\"E_PERM\"],\" is raised.\"]";
"[\"p\",\"The documentation is represented as a list of tagged elements and lines of text. Lines of text are simple strings. Tagged elements are lists with the following form:\"]";
"[\"pre\",\"{STR tag [, MAP attributes] [, LIST body]}\"]";
"[\"p\",\"The \",[\"var\",\"body\"],\", if present, is itself a list of tagged elements and lines of text.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"{\\\"a line of documentation\\\"}\"],[\"code\",{\"class\":\"language-moocode\"},\"{\\\"a \\\", {\\\"tag\\\", \\\"line\\\"}, \\\" of documentation\\\"}\"],[\"code\",{\"class\":\"language-moocode\"},\"{\\\"a \\\", {\\\"tag\\\", [\\\"key\\\" -> \\\"value\\\"], \\\"line\\\"}, \\\" of documentation\\\"}\"],[\"code\",{\"class\":\"language-moocode\"},\"{{\\\"tag\\\"}, {\\\"tag\\\"}, {\\\"tag\\\"}}\"]]";
"";
"chunk_length:7";
"chunk_type:documentation";
"content_type:application/json";
"sha1:FD4C48CEBFF253F4009E894B07B3AFC29C77F43C";
"-=-=-mxyzptlk-=-=-";
.
#0:31
set_task_perms(caller_perms());
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(@args);
return;
"set_task_perms(caller_perms());";
"(ticks_left() < 10000 || seconds_left() < 2) && suspend(@args);";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:77AB1A7AC59146F17BFD0DDA68A84ECD7691CF32";
"state:clean";
"updated_at:Sun Feb 24 08:52:26 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#0:32
{line} = args;
if ((t = typeof(line)) == STR)
return;
elseif (t == LIST)
if ((l = length(line)) && (typeof(line[1]) == STR))
if (l == 1)
return;
else
attrs = [];
if (typeof(line[2]) == MAP)
{_, attrs, @line} = line;
else
{_, @line} = line;
endif
for v, k in (attrs)
if (typeof(v) != STR)
raise(E_INVARG, tostr("Bad format: ", toliteral(v)), v);
endif
if (typeof(k) != STR)
raise(E_INVARG, tostr("Bad format: ", toliteral(k)), k);
endif
endfor
for l in (line)
this:_validate_doc_format(l);
endfor
endif
return;
endif
endif
raise(E_INVARG, tostr("Bad format: ", toliteral(line)), line);
return;
"/* not $private(), but not part of the published interface */";
"";
"{line} = args;";
"";
"if ((t = typeof(line)) == STR)";
"   return;";
"elseif (t == LIST)";
"  if ((l = length(line)) && typeof(line[1]) == STR)";
"    if (l == 1)";
"      return;";
"    else";
"      attrs = [];";
"      if (typeof(line[2]) == MAP)";
"        {_, attrs, @line} = line;";
"      else";
"        {_, @line} = line;";
"      endif";
"      for v, k in (attrs)";
"        if (typeof(v) != STR)";
"	  raise(E_INVARG, tostr(\"Bad format: \", toliteral(v)), v);";
"	endif";
"        if (typeof(k) != STR)";
"	  raise(E_INVARG, tostr(\"Bad format: \", toliteral(k)), k);";
"	endif";
"      endfor";
"      for l in (line)";
"        this:_validate_doc_format(l);";
"      endfor";
"    endif";
"    return;";
"  endif";
"endif";
"";
"raise(E_INVARG, tostr(\"Bad format: \", toliteral(line)), line);";
"";
"chunk_length:34";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:78244A75B3FF62417769F7A6EAC88D036D991BEF";
"state:clean";
"updated_at:Fri Mar 29 13:24:24 2013 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#3:0
{code, message, value, traceback, formatted} = args;
callers() && raise(E_PERM, "Server task");
for line in (formatted)
server_log(line);
endfor
.
#3:1
{resource, traceback, formatted} = args;
callers() && raise(E_PERM, "Server task");
for line in (formatted)
server_log(line);
endfor
.
#3:2
$restrict_to_caller($system, "server_started");
$epoch = $epoch + 1;
$last_login_connection = #-1;
if (!$disable_passkey_login)
server_log(tostr("WARNING: Log-in via passkey is enabled for the following players (specified in $passkey_players):"));
for player in ($passkey_players)
server_log(tostr("WARNING:   \"", player.name, "\" (", player, ")"));
endfor
server_log("WARNING: This is a severe security vulnerability.  In a secure environment you should:");
server_log("WARNING:   disable passkey login:");
server_log("WARNING:     ; $disable_passkey_login = 1");
server_log("WARNING:     ; $passkey_players = {}");
server_log("WARNING:   disable existing passkeys:");
for player in ($passkey_players)
server_log(tostr("WARNING:     ; ", player, ".passkey = 0"));
endfor
server_log("WARNING:   and for good measure:");
for player in ($passkey_players)
server_log(tostr("WARNING:     ; set_player_flag(", player, ", 0)"));
endfor
for player in ($passkey_players)
if (passkey = getenv(tostr("Stunt_Passkey_", player.name)))
player.passkey = passkey;
else
player.passkey = 0;
endif
endfor
endif
return;
"$restrict_to_caller($system, \"server_started\");";
"";
"$epoch = $epoch + 1;";
"$last_login_connection = #-1;";
"";
"if (!$disable_passkey_login)";
"  server_log(tostr(\"WARNING: Log-in via passkey is enabled for the following players (specified in $passkey_players):\"));";
"  for player in ($passkey_players)";
"    server_log(tostr(\"WARNING:   \\\"\", player.name, \"\\\" (\", player, \")\"));";
"  endfor";
"  server_log(\"WARNING: This is a severe security vulnerability.  In a secure environment you should:\");";
"  server_log(\"WARNING:   disable passkey login:\");";
"  server_log(\"WARNING:     ; $disable_passkey_login = 1\");";
"  server_log(\"WARNING:     ; $passkey_players = {}\");";
"  server_log(\"WARNING:   disable existing passkeys:\");";
"  for player in ($passkey_players)";
"    server_log(tostr(\"WARNING:     ; \", player, \".passkey = 0\"));";
"  endfor";
"  server_log(\"WARNING:   and for good measure:\");";
"  for player in ($passkey_players)";
"    server_log(tostr(\"WARNING:     ; set_player_flag(\", player, \", 0)\"));";
"  endfor";
"  for player in ($passkey_players)";
"    if ((passkey = getenv(tostr(\"Stunt_Passkey_\", player.name))))";
"      player.passkey = passkey;";
"    else";
"      player.passkey = 0;";
"    endif";
"  endfor";
"endif";
"";
"chunk_length:30";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:526E7583141D236A47891532CDEB51E5FD607115";
"state:clean";
"updated_at:Sat May 18 06:03:35 2013 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#3:3
$restrict_to_caller($system, "authenticate");
if (length(args) == 1)
{passkey} = args;
if (!$disable_passkey_login)
for player in ($passkey_players)
if (length(passkey) == length(player.passkey))
count = 0;
for i in [1..length(passkey)]
count = ((passkey[i] == player.passkey[i]) ? 1 | 0) + count;
endfor
if (length(passkey) == count)
return player;
endif
endif
endfor
endif
endif
return $failed_match;
.
#5:0
if (player != this)
notify(player, "I couldn't understand that.");
return;
endif
if (!player.wizard)
notify(player, "You must be a wizard to do that!");
return;
endif
if (length($composed.packages) > 1)
notify(player, "You have non-kernel packages installed.");
return;
endif
notify(player, "Bye!");
boot_player(player);
for task in (queued_tasks())
kill_task(task[1]);
endfor
$epoch = 0;
$last_login_connection = 0;
$external_compilers = [];
$disable_passkey_login = 0;
#5.passkey = 0;
#6.passkey = 0;
$composed.archive_sources = {"http://stunt.io/v2/packages.json"};
$composed.last_fetch_index = 0;
$composed.archived = [];
$composed.cached = [];
chparents(#0, {#3});
chparents(#5, {});
chparents(#6, {});
package = $composed:export(#2);
json = generate_json(package, "embedded-types");
while (len = length(json))
len = (len > 60000) ? 60000 | len;
line = json[1..len];
json[1..len] = "";
server_log(line);
endwhile
reset_max_object();
shutdown();
return;
"if (player != this)";
"  notify(player, \"I couldn't understand that.\");";
"  return;";
"endif";
"if (!player.wizard)";
"  notify(player, \"You must be a wizard to do that!\");";
"  return;";
"endif";
"";
"if (length($composed.packages) > 1)";
"  notify(player, \"You have non-kernel packages installed.\");";
"  return;";
"endif";
"";
"notify(player, \"Bye!\");";
"boot_player(player);";
"";
"for task in (queued_tasks())";
"  kill_task(task[1]);";
"endfor";
"";
"#0.epoch = 0;";
"#0.last_login_connection = 0;";
"#0.external_compilers = [];";
"";
"#0.disable_passkey_login = 0;";
"#5.passkey = 0;";
"#6.passkey = 0;";
"";
"$composed.archive_sources = {\"http://stunt.io/v2/packages.json\"};";
"$composed.last_fetch_index = 0;";
"$composed.archived = [];";
"$composed.cached = [];";
"";
"chparents(#0, {#3});";
"chparents(#5, {});";
"chparents(#6, {});";
"";
"package = $composed:export(#2);";
"json = generate_json(package, \"embedded-types\");";
"while (len = length(json))";
"  len = len > 60000 ? 60000 | len;";
"  line = json[1..len];";
"  json[1..len] = \"\";";
"  server_log(line);";
"endwhile";
"";
"reset_max_object();";
"shutdown();";
"";
"chunk_length:49";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:B3F69B65640E578B1EEC70EB7FBA43C4CA0BBCFC";
"state:clean";
"updated_at:Sat Feb  9 18:02:32 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#5:1
callers() && raise(E_PERM, "Server task");
set_task_perms(player);
"very simple, really primitive matching";
if (((prepstr == "with") && (iobjstr == "$composed")) && `valid($composed) ! ANY')
if ((verb in {"@install", "@uninstall", "@list"}) && `respond_to($composed, verb) ! ANY')
return $composed:(verb)(@args);
endif
endif
notify(player, "I couldn't understand that.");
.
#7:0
if (player.location != this)
notify(player, "I couldn't understand that.");
return;
elseif (!player.programmer)
notify(player, "You need to be a programmer to evaluate code.");
return;
endif
set_task_perms(player);
if (!(args[1] in {";", "if", "for", "while", "fork", "return"}))
notify(player, toliteral(eval(("return " + argstr) + ";")[2]));
else
notify(player, toliteral(eval(argstr + ";")[2]));
endif
.
#8:0
$private();
notify(player, tostr(@args));
return;
"$private();";
"notify(player, tostr(@args));";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:4D3218AE4E5E033F8DEBE454635C738FD9A8FC0A";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:1
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
return;
"/* intentionally not $private() */";
"(ticks_left() < 10000 || seconds_left() < 2) && suspend(0);";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:2C1EA11D12899B2BA0E13071EB96FB49B19F22AE";
"state:clean";
"updated_at:Fri Jun  8 06:28:02 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:2
{who, what} = args;
return (who == what.owner) || who.wizard;
return;
"{who, what} = args;";
"return who == what.owner || who.wizard;";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:9DD4270A2909D7E9B7ACF51318A725A3B6018DAE";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:3
{who, what, name} = args;
$private();
return (who == verb_info(what, name)[1]) || who.wizard;
return;
"{who, what, name} = args;";
"$private();";
"return who == verb_info(what, name)[1] || who.wizard;";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:1CD475E09642CB93FFE212FC6EBC0D3AE8C6FC0A";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:4
{who, what, name} = args;
$private();
return (who == property_info(what, name)[1]) || who.wizard;
return;
"{who, what, name} = args;";
"$private();";
"return who == property_info(what, name)[1] || who.wizard;";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:E2A6A9525DE1893AB0B8744CC406118FABF8A208";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:5
args && raise(E_ARGS);
set_task_perms(caller_perms());
r = [];
r["Objects"] = {};
return r;
return;
"args && raise(E_ARGS);";
"set_task_perms(caller_perms());";
"r = [];";
"r[\"Objects\"] = {};";
"return r;";
"";
"chunk_length:5";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:2A97664DD035B6AD7F03BA1868859F92532B37D5";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:6
{o, ?options = []} = args;
((ticks_left() < 2000) || (seconds_left() < 2)) && suspend(0);
if (`valid(o) ! E_TYPE')
pcount = length(properties(o));
vcount = length(verbs(o));
set_task_perms(caller_perms());
r = ["Attributes" -> []];
v = parents(o);
m = ["id" -> "parents"];
m["status"] = this:_controls(caller_perms(), o) ? "writable" | "readable";
r["Attributes"]["parents"] = ["Meta" -> m, "Value" -> ["value" -> v]];
if (typeof(o) == OBJ)
v = is_player(o);
m = ["id" -> "player"];
m["status"] = `caller_perms().wizard ! E_INVIND' ? "writable" | "readable";
r["Attributes"]["player"] = ["Meta" -> m, "Value" -> ["value" -> v]];
endif
r["Values"] = [];
for a in (this:_values(o))
this:_suspend_if_necessary();
r["Values"][a] = this:read_value(o, a, options);
endfor
r["Properties"] = {};
for p in [1..pcount]
this:_suspend_if_necessary();
r["Properties"] = {@r["Properties"], this:read_property(o, p)};
endfor
r["Verbs"] = {};
for v in [1..vcount]
this:_suspend_if_necessary();
r["Verbs"] = {@r["Verbs"], this:read_verb(o, v)};
endfor
if (p = o.w || this:_controls(caller_perms(), o))
status = "writable";
elseif (o.r)
status = "readable";
else
status = "";
endif
if (typeof(o) == OBJ)
r["Meta"] = ["id" -> toint(o), "status" -> status];
else
r["Meta"] = ["status" -> status];
endif
return r;
else
if (typeof(o) == OBJ)
r = ["Meta" -> ["id" -> toint(o), "status" -> "invalid"]];
else
r = ["Meta" -> ["status" -> "invalid"]];
endif
return r;
endif
return;
"{o, ?options = []} = args;";
"";
"ticks_left() < 2000 || seconds_left() < 2 && suspend(0);";
"";
"if (`valid(o) ! E_TYPE')";
"";
"  /* inform ourselves about basic object structure before losing perms */";
"  pcount = length(properties(o));";
"  vcount = length(verbs(o));";
"";
"  set_task_perms(caller_perms());";
"";
"  r = [\"Attributes\" -> []];";
"  v = parents(o);";
"  m = [\"id\" -> \"parents\"];";
"  m[\"status\"] = this:_controls(caller_perms(), o) ? \"writable\" | \"readable\";";
"  r[\"Attributes\"][\"parents\"] = [\"Meta\" -> m, \"Value\" -> [\"value\" -> v]];";
"";
"  if (typeof(o) == OBJ)";
"    v = is_player(o);";
"    m = [\"id\" -> \"player\"];";
"    m[\"status\"] = `caller_perms().wizard ! E_INVIND' ? \"writable\" | \"readable\";";
"    r[\"Attributes\"][\"player\"] = [\"Meta\" -> m, \"Value\" -> [\"value\" -> v]];";
"  endif";
"";
"  r[\"Values\"] = [];";
"  for a in (this:_values(o))";
"    this:_suspend_if_necessary();";
"    r[\"Values\"][a] = this:read_value(o, a, options);";
"  endfor";
"";
"  r[\"Properties\"] = {};";
"  for p in [1..pcount]";
"    this:_suspend_if_necessary();";
"    r[\"Properties\"] = {@r[\"Properties\"], this:read_property(o, p)};";
"  endfor";
"";
"  r[\"Verbs\"] = {};";
"  for v in [1..vcount]";
"    this:_suspend_if_necessary();";
"    r[\"Verbs\"] = {@r[\"Verbs\"], this:read_verb(o, v)};";
"  endfor";
"";
"  if (p = o.w || this:_controls(caller_perms(), o))";
"    status = \"writable\";";
"  elseif (o.r)";
"    status = \"readable\";";
"  else";
"    status = \"\";";
"  endif";
"";
"  if (typeof(o) == OBJ)";
"    r[\"Meta\"] = [\"id\" -> toint(o), \"status\" -> status];";
"  else";
"    r[\"Meta\"] = [\"status\" -> status];";
"  endif";
"  return r;";
"else";
"  if (typeof(o) == OBJ)";
"    r = [\"Meta\" -> [\"id\" -> toint(o), \"status\" -> \"invalid\"]];";
"  else";
"    r = [\"Meta\" -> [\"status\" -> \"invalid\"]];";
"  endif";
"  return r;";
"endif";
"";
"chunk_length:65";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:C88F2C4D74D53093007C94FE472E800669BE0AE6";
"state:clean";
"updated_at:Wed Jan  2 08:06:01 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:7
{o, r, ?options = []} = args;
((ticks_left() < 2000) || (seconds_left() < 2)) && suspend(0);
if (`valid(o) ! E_TYPE')
properties = properties(o);
verbs = verbs(o);
set_task_perms(caller_perms());
try
r["Attributes"];
r["Values"];
r["Properties"];
r["Verbs"];
errors = 0;
parents = `r["Attributes"]["parents"]["Value"]["value"] ! E_RANGE => parents(o)';
if (parents(o) != parents)
x = this:_write_parents(o, ["Value" -> ["value" -> {}]]);
errors = errors + ("Error" in mapkeys(x));
endif
location = `r["Values"]["location"]["Value"]["value"] ! E_RANGE => o.location';
if (o.location != location)
x = this:write_value(o, "location", ["Value" -> ["value" -> $nothing]]);
errors = errors + ("Error" in mapkeys(x));
endif
owner = `r["Values"]["owner"]["Value"]["value"] ! E_RANGE => o.owner';
if ("owner" in mapkeys(r["Values"]))
r["Values"]["owner"] = this:write_value(o, "owner", r["Values"]["owner"]);
errors = errors + ("Error" in mapkeys(r["Values"]["owner"]));
endif
if ("parents" in mapkeys(r["Attributes"]))
r["Attributes"]["parents"] = this:_write_parents(o, r["Attributes"]["parents"]);
errors = errors + ("Error" in mapkeys(r["Attributes"]["parents"]));
endif
if ("player" in mapkeys(r["Attributes"]))
r["Attributes"]["player"] = this:_write_player(o, r["Attributes"]["player"]);
errors = errors + ("Error" in mapkeys(r["Attributes"]["player"]));
endif
if ("location" in mapkeys(r["Values"]))
r["Values"]["location"] = this:write_value(o, "location", r["Values"]["location"]);
errors = errors + ("Error" in mapkeys(r["Values"]["location"]));
endif
if ((lp1 = length(properties)) < (lp2 = length(r["Properties"])))
for p in [lp1 + 1..lp2]
this:_suspend_if_necessary();
`add_property(o, tostr("___", p, "___"), 0, {owner, ""}) ! E_PERM';
endfor
else
for p in [lp2 + 1..lp1]
this:_suspend_if_necessary();
delete_property(o, properties[p]);
endfor
endif
if ((lv1 = length(verbs)) < (lv2 = length(r["Verbs"])))
for v in [lv1 + 1..lv2]
this:_suspend_if_necessary();
`add_verb(o, {owner, "", tostr("___", v, "___")}, {"this", "none", "this"}) ! E_PERM';
endfor
else
for v in [lv2 + 1..lv1]
this:_suspend_if_necessary();
delete_verb(o, lv2 + 1);
endfor
endif
for p in [1..length(r["Properties"])]
this:_suspend_if_necessary();
r["Properties"][p] = this:write_property(o, p, r["Properties"][p]);
if ("Error" in mapkeys(r["Properties"][p]))
if ((lp1 < lp2) && (r["Properties"][p]["Error"]["diagnostic"] == "property is invalid"))
r["Properties"][p]["Error"]["diagnostic"] = "permission denied";
endif
errors = errors + 1;
endif
endfor
for v in [1..length(r["Verbs"])]
this:_suspend_if_necessary();
r["Verbs"][v] = this:write_verb(o, v, r["Verbs"][v], `options["verbs"] ! E_RANGE => []');
if ("Error" in mapkeys(r["Verbs"][v]))
if ((lv1 < lv2) && (r["Verbs"][v]["Error"]["diagnostic"] == "verb is invalid"))
r["Verbs"][v]["Error"]["diagnostic"] = "permission denied";
endif
errors = errors + 1;
endif
endfor
values = setremove(setremove(mapkeys(r["Values"]), "location"), "owner");
for a in (values)
this:_suspend_if_necessary();
r["Values"][a] = this:write_value(o, a, r["Values"][a], options);
errors = errors + ("Error" in mapkeys(r["Values"][a]));
endfor
if (errors < 1)
r = this:read_object(o);
else
r["Meta"] = ["id" -> toint(o), "status" -> "unknown"];
r["Error"] = ["diagnostic" -> "errors in sub-operations"];
endif
return r;
except (E_RANGE, E_TYPE)
r["Error"] = ["diagnostic" -> "bad message format"];
return r;
except (E_PERM)
r["Error"] = ["diagnostic" -> "permission denied"];
return r;
endtry
else
r["Error"] = ["diagnostic" -> "object reference is invalid"];
return r;
endif
return;
"{o, r, ?options = []} = args;";
"";
"ticks_left() < 2000 || seconds_left() < 2 && suspend(0);";
"";
"if (`valid(o) ! E_TYPE')";
"";
"  /* inform ourselves about basic object structure before losing perms */";
"  properties = properties(o);";
"  verbs = verbs(o);";
"";
"  set_task_perms(caller_perms());";
"";
"  try";
"    /* get basic message format checks out of the way */";
"    r[\"Attributes\"];";
"    r[\"Values\"];";
"    r[\"Properties\"];";
"    r[\"Verbs\"];";
"";
"    errors = 0;";
"";
"    /* Before doing anything else, reset the object to a known";
"     * state. If the parents are going to change, set the parents";
"     * to an empty list; if the location is going to change, move";
"     * the object to $nothing.";
"     */";
"";
"    parents = `r[\"Attributes\"][\"parents\"][\"Value\"][\"value\"] ! E_RANGE => parents(o)';";
"";
"    if (parents(o) != parents)";
"      x = this:_write_parents(o, [\"Value\" -> [\"value\" -> {}]]);";
"      errors = errors + (\"Error\" in mapkeys(x));";
"    endif";
"";
"    location = `r[\"Values\"][\"location\"][\"Value\"][\"value\"] ! E_RANGE => o.location';";
"";
"    if (o.location != location)";
"      x = this:write_value(o, \"location\", [\"Value\" -> [\"value\" -> $nothing]]);";
"      errors = errors + (\"Error\" in mapkeys(x));";
"    endif";
"";
"    owner = `r[\"Values\"][\"owner\"][\"Value\"][\"value\"] ! E_RANGE => o.owner';";
"";
"    /* Do the owner, parents, player and location values first, in that";
"     * order.  Then properties and verbs.  Then the rest of the";
"     * values.";
"     */";
"";
"    if (\"owner\" in mapkeys(r[\"Values\"]))";
"      r[\"Values\"][\"owner\"] = this:write_value(o, \"owner\", r[\"Values\"][\"owner\"]);";
"      errors = errors + (\"Error\" in mapkeys(r[\"Values\"][\"owner\"]));";
"    endif";
"";
"    if (\"parents\" in mapkeys(r[\"Attributes\"]))";
"      r[\"Attributes\"][\"parents\"] = this:_write_parents(o, r[\"Attributes\"][\"parents\"]);";
"      errors = errors + (\"Error\" in mapkeys(r[\"Attributes\"][\"parents\"]));";
"    endif";
"";
"    if (\"player\" in mapkeys(r[\"Attributes\"]))";
"      r[\"Attributes\"][\"player\"] = this:_write_player(o, r[\"Attributes\"][\"player\"]);";
"      errors = errors + (\"Error\" in mapkeys(r[\"Attributes\"][\"player\"]));";
"    endif";
"";
"    if (\"location\" in mapkeys(r[\"Values\"]))";
"      r[\"Values\"][\"location\"] = this:write_value(o, \"location\", r[\"Values\"][\"location\"]);";
"      errors = errors + (\"Error\" in mapkeys(r[\"Values\"][\"location\"]));";
"    endif";
"";
"    if ((lp1 = length(properties)) < (lp2 = length(r[\"Properties\"])))";
"      for p in [lp1 + 1..lp2]";
"        this:_suspend_if_necessary();";
"        `add_property(o, tostr(\"___\", p, \"___\"), 0, {owner, \"\"}) ! E_PERM';";
"      endfor";
"    else";
"      for p in [lp2 + 1..lp1]";
"        this:_suspend_if_necessary();";
"        delete_property(o, properties[p]);";
"      endfor";
"    endif";
"";
"    if ((lv1 = length(verbs)) < (lv2 = length(r[\"Verbs\"])))";
"      for v in [lv1 + 1..lv2]";
"        this:_suspend_if_necessary();";
"        `add_verb(o, {owner, \"\", tostr(\"___\", v, \"___\")}, {\"this\", \"none\", \"this\"}) ! E_PERM';";
"      endfor";
"    else";
"      for v in [lv2 + 1..lv1]";
"        this:_suspend_if_necessary();";
"        delete_verb(o, lv2 + 1);";
"      endfor";
"    endif";
"";
"    for p in [1..length(r[\"Properties\"])]";
"      this:_suspend_if_necessary();";
"      r[\"Properties\"][p] = this:write_property(o, p, r[\"Properties\"][p]);";
"      if (\"Error\" in mapkeys(r[\"Properties\"][p]))";
"        if (lp1 < lp2 && r[\"Properties\"][p][\"Error\"][\"diagnostic\"] == \"property is invalid\")";
"          /* if we had to add properties but the property does not actually exist it should have been... */";
"          r[\"Properties\"][p][\"Error\"][\"diagnostic\"] = \"permission denied\";";
"        endif";
"        errors = errors + 1;";
"      endif";
"    endfor";
"";
"    for v in [1..length(r[\"Verbs\"])]";
"      this:_suspend_if_necessary();";
"      r[\"Verbs\"][v] = this:write_verb(o, v, r[\"Verbs\"][v], `options[\"verbs\"] ! E_RANGE => []');";
"      if (\"Error\" in mapkeys(r[\"Verbs\"][v]))";
"        if (lv1 < lv2 && r[\"Verbs\"][v][\"Error\"][\"diagnostic\"] == \"verb is invalid\")";
"          /* if we had to add verbs but the verb does not actually exist it should have been... */";
"          r[\"Verbs\"][v][\"Error\"][\"diagnostic\"] = \"permission denied\";";
"        endif";
"        errors = errors + 1;";
"      endif";
"    endfor";
"";
"    /* do the rest of the values */";
"";
"    values = setremove(setremove(mapkeys(r[\"Values\"]), \"location\"), \"owner\");";
"";
"    for a in (values)";
"      this:_suspend_if_necessary();";
"      r[\"Values\"][a] = this:write_value(o, a, r[\"Values\"][a], options);";
"      errors = errors + (\"Error\" in mapkeys(r[\"Values\"][a]));";
"    endfor";
"";
"    if (errors < 1)";
"      r = this:read_object(o);";
"    else";
"      r[\"Meta\"] = [\"id\" -> toint(o), \"status\" -> \"unknown\"];";
"      r[\"Error\"] = [\"diagnostic\" -> \"errors in sub-operations\"];";
"    endif";
"";
"    return r;";
"";
"  except (E_RANGE, E_TYPE)";
"    r[\"Error\"] = [\"diagnostic\" -> \"bad message format\"];";
"    return r;";
"  except (E_PERM)";
"    r[\"Error\"] = [\"diagnostic\" -> \"permission denied\"];";
"    return r;";
"  endtry";
"else";
"  r[\"Error\"] = [\"diagnostic\" -> \"object reference is invalid\"];";
"  return r;";
"endif";
"";
"chunk_length:146";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:3A4250A3A30EF80C0F2FC484261153890A9BB810";
"state:clean";
"updated_at:Wed Jan  2 08:06:26 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:8
{object, property} = args;
$private();
for parent in (parents(object))
this:_suspend_if_necessary();
if (ret = `property_info(parent, property) ! E_PROPNF')
return ret;
endif
endfor
return {};
return;
"{object, property} = args;";
"$private();";
"for parent in (parents(object))";
"  this:_suspend_if_necessary();";
"  if (ret = `property_info(parent, property) ! E_PROPNF')";
"    return ret;";
"  endif";
"endfor";
"return {};";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:6828227C67A26B9EB2F5086E7854A55943E5A2C5";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:9
{o} = args;
$private();
x = {};
for t in ({o, @ancestors(o)})
this:_suspend_if_necessary();
y = {};
for z in (properties(t))
this:_suspend_if_necessary();
y = {z, @y};
endfor
x = {@y, @x};
endfor
x = {"name", "owner", "location", "programmer", "wizard", "r", "w", "f", "a", @x};
return x;
return;
"{o} = args;";
"$private();";
"x = {};";
"for t in ({o, @ancestors(o)})";
"  this:_suspend_if_necessary();";
"  y = {};";
"  for z in (properties(t))";
"    this:_suspend_if_necessary();";
"    y = {z, @y};";
"  endfor";
"  x = {@y, @x};";
"endfor";
"x = {\"name\", \"owner\", \"location\", \"programmer\", \"wizard\", \"r\", \"w\", \"f\", \"a\", @x};";
"return x;";
"";
"chunk_length:14";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:2F864E57D535E087E2CA7BD57C8195299E171A57";
"state:clean";
"updated_at:Thu Dec 27 08:35:47 2012 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:10
{o} = args;
set_task_perms(caller_perms());
r = ["Values" -> {}];
for value in (this:_values(o))
this:_suspend_if_necessary();
r["Values"] = {@r["Values"], this:read_value(o, value)};
endfor
return r;
return;
"{o} = args;";
"set_task_perms(caller_perms());";
"r = [\"Values\" -> {}];";
"for value in (this:_values(o))";
"  this:_suspend_if_necessary();";
"  r[\"Values\"] = {@r[\"Values\"], this:read_value(o, value)};";
"endfor";
"return r;";
"";
"chunk_length:8";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:9AA9361F32A2726062ACD072432C55955CD1CAB1";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:11
{o, a, ?options = []} = args;
strip_clear_values = `options["strip_clear_values"] ! E_RANGE';
set_task_perms(caller_perms());
try
if (a == "location")
v = o.location;
p = this:_controls(caller_perms(), o) ? "rw" | "r";
elseif (a in {"owner", "programmer", "wizard"})
v = o.(a);
p = `caller_perms().wizard ! E_INVIND' ? "rw" | "r";
elseif (a in {"r", "w", "f", "a"})
v = o.(a);
p = this:_controls(caller_perms(), o) ? "rw" | "r";
elseif (a in {"name"})
v = o.(a);
p = (`caller_perms().wizard ! E_INVIND' || (this:_controls(caller_perms(), o) && (!is_player(o)))) ? "rw" | "r";
else
v = o.(a);
pi = property_info(o, a);
p = (index(pi[2], "w") || this:_controls_property(caller_perms(), o, a)) ? "rw" | "r";
c = is_clear_property(o, a);
endif
except (E_INVIND, E_PROPNF)
r = ["Meta" -> ["id" -> a, "status" -> "invalid"]];
return r;
except (E_PERM)
r = ["Meta" -> ["id" -> a, "status" -> "denied"]];
return r;
endtry
m = ["id" -> a];
m["status"] = index(p, "w") ? "writable" | "readable";
r = ["Meta" -> m, "Value" -> ["value" -> v]];
if (`r["Value"]["clear"] = c ! E_VARNF' && strip_clear_values)
r["Value"] = mapdelete(r["Value"], "value");
endif
if (`pi ! E_VARNF')
if ((ppi = this:_parent_property_info(o, a)) && (ppi != pi))
r["Value"]["owner"] = pi[1];
r["Value"]["perms"] = pi[2];
endif
endif
return r;
return;
"{o, a, ?options = []} = args;";
"";
"strip_clear_values = `options[\"strip_clear_values\"] ! E_RANGE';";
"";
"set_task_perms(caller_perms());";
"";
"try";
"  if (a == \"location\")";
"    v = o.location;";
"    p = this:_controls(caller_perms(), o) ? \"rw\" | \"r\";";
"  elseif (a in {\"owner\", \"programmer\", \"wizard\"})";
"    v = o.(a);";
"    p = `caller_perms().wizard ! E_INVIND' ? \"rw\" | \"r\";";
"  elseif (a in {\"r\", \"w\", \"f\", \"a\"})";
"    v = o.(a);";
"    p = this:_controls(caller_perms(), o) ? \"rw\" | \"r\";";
"  elseif (a in {\"name\"})";
"    v = o.(a);";
"    p = `caller_perms().wizard ! E_INVIND' || (this:_controls(caller_perms(), o) && !is_player(o)) ? \"rw\" | \"r\";";
"  else";
"    v = o.(a);";
"    pi = property_info(o, a);";
"    p = index(pi[2], \"w\") || this:_controls_property(caller_perms(), o, a) ? \"rw\" | \"r\";";
"    c = is_clear_property(o, a);";
"  endif";
"except (E_INVIND, E_PROPNF)";
"  r = [\"Meta\" -> [\"id\" -> a, \"status\" -> \"invalid\"]];";
"  return r;";
"except (E_PERM)";
"  r = [\"Meta\" -> [\"id\" -> a, \"status\" -> \"denied\"]];";
"  return r;";
"endtry";
"m = [\"id\" -> a];";
"m[\"status\"] = index(p, \"w\") ? \"writable\" | \"readable\";";
"r = [\"Meta\" -> m, \"Value\" -> [\"value\" -> v]];";
"if (`r[\"Value\"][\"clear\"] = c ! E_VARNF' && strip_clear_values) /* `c' is not defined for built-in properties */";
"  r[\"Value\"] = mapdelete(r[\"Value\"], \"value\");";
"endif";
"if (`pi ! E_VARNF')";
"  if ((ppi = this:_parent_property_info(o, a)) && ppi != pi)";
"    r[\"Value\"][\"owner\"] = pi[1];";
"    r[\"Value\"][\"perms\"] = pi[2];";
"  endif";
"endif";
"";
"return r;";
"";
"chunk_length:46";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:E51DADB807832C3FA5A13490E55B70B98D580B0B";
"state:clean";
"updated_at:Wed Jan  2 08:07:00 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:12
{o, a, r, ?options = []} = args;
set_task_perms(caller_perms());
mk = mapkeys(r);
if ((!("Meta" in mk)) && (!("Value" in mk)))
r["Error"] = ["diagnostic" -> "bad message format"];
return r;
endif
old = this:read_value(o, a, options);
if (`old["Value"] ! E_RANGE' == `r["Value"] ! E_RANGE')
return old;
endif
try
mk = mapkeys(r["Value"]);
if (a in {"name", "owner", "location", "programmer", "wizard", "r", "w", "f", "a"})
if ("clear" in mk)
r["Error"] = ["diagnostic" -> "clear is not applicable"];
return r;
endif
if ("owner" in mk)
r["Error"] = ["diagnostic" -> "owner is not applicable"];
return r;
endif
if ("perms" in mk)
r["Error"] = ["diagnostic" -> "perms is not applicable"];
return r;
endif
endif
c = `r["Value"]["clear"] ! E_RANGE';
if (c)
clear_property(o, a);
else
v = r["Value"]["value"];
if (a == "location")
(o.location != v) && move(o, v);
else
o.(a) = v;
endif
endif
if (("owner" in mk) || ("perms" in mk))
set_property_info(o, a, {`r["Value"]["owner"] ! E_RANGE => caller_perms()', r["Value"]["perms"]});
endif
except (E_RANGE)
r["Error"] = ["diagnostic" -> "bad message format"];
return r;
except (E_INVIND)
r["Error"] = ["diagnostic" -> "object reference is invalid"];
return r;
except (E_PROPNF)
r["Error"] = ["diagnostic" -> "value is invalid"];
return r;
except (E_PERM)
r["Error"] = ["diagnostic" -> "permission denied"];
return r;
except (E_TYPE)
r["Error"] = ["diagnostic" -> "data type is invalid"];
return r;
except (E_NACC)
r["Error"] = ["diagnostic" -> "move refused by destination"];
return r;
except (E_RECMOVE)
r["Error"] = ["diagnostic" -> "recursive move"];
return r;
endtry
return this:read_value(o, a, options);
return;
"{o, a, r, ?options = []} = args;";
"";
"set_task_perms(caller_perms());";
"";
"/* My thinking is that a valid input will either have meta data";
" * (from a prior read) or a value.  If both are missing, this";
" * input is garbage of some sort.";
" */";
"mk = mapkeys(r);";
"if (!(\"Meta\" in mk) && !(\"Value\" in mk))";
"  r[\"Error\"] = [\"diagnostic\" -> \"bad message format\"];";
"  return r;";
"endif";
"";
"old = this:read_value(o, a, options);";
"if (`old[\"Value\"] ! E_RANGE' == `r[\"Value\"] ! E_RANGE')";
"  return old;";
"endif";
"";
"try";
"  mk = mapkeys(r[\"Value\"]);";
"  if (a in {\"name\", \"owner\", \"location\", \"programmer\", \"wizard\", \"r\", \"w\", \"f\", \"a\"})";
"    if (\"clear\" in mk)";
"      r[\"Error\"] = [\"diagnostic\" -> \"clear is not applicable\"];";
"      return r;";
"    endif";
"    if (\"owner\" in mk)";
"      r[\"Error\"] = [\"diagnostic\" -> \"owner is not applicable\"];";
"      return r;";
"    endif";
"    if (\"perms\" in mk)";
"      r[\"Error\"] = [\"diagnostic\" -> \"perms is not applicable\"];";
"      return r;";
"    endif";
"  endif";
"  c = `r[\"Value\"][\"clear\"] ! E_RANGE';";
"  if (c)";
"    clear_property(o, a);";
"  else";
"    v = r[\"Value\"][\"value\"];";
"    if (a == \"location\")";
"      o.location != v && move(o, v);";
"    else";
"      o.(a) = v;";
"    endif";
"  endif";
"  if (\"owner\" in mk || \"perms\" in mk)";
"    set_property_info(o, a, {`r[\"Value\"][\"owner\"] ! E_RANGE => caller_perms()', r[\"Value\"][\"perms\"]});";
"  endif";
"except (E_RANGE)";
"  r[\"Error\"] = [\"diagnostic\" -> \"bad message format\"];";
"  return r;";
"except (E_INVIND)";
"  r[\"Error\"] = [\"diagnostic\" -> \"object reference is invalid\"];";
"  return r;";
"except (E_PROPNF)";
"  r[\"Error\"] = [\"diagnostic\" -> \"value is invalid\"];";
"  return r;";
"except (E_PERM)";
"  r[\"Error\"] = [\"diagnostic\" -> \"permission denied\"];";
"  return r;";
"except (E_TYPE)";
"  r[\"Error\"] = [\"diagnostic\" -> \"data type is invalid\"];";
"  return r;";
"except (E_NACC)";
"  r[\"Error\"] = [\"diagnostic\" -> \"move refused by destination\"];";
"  return r;";
"except (E_RECMOVE)";
"  r[\"Error\"] = [\"diagnostic\" -> \"recursive move\"];";
"  return r;";
"endtry";
"";
"return this:read_value(o, a, options);";
"";
"chunk_length:73";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:C4A0362C17C05647E05D00C699D093AE43D007DC";
"state:clean";
"updated_at:Wed Jan  2 07:36:11 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:13
{o, r} = args;
$private();
set_task_perms(caller_perms());
try
v = r["Value"]["value"];
(parents(o) != v) && chparents(o, v);
except (E_RANGE)
r["Error"] = ["diagnostic" -> "bad message format"];
return r;
except (E_INVARG)
r["Error"] = ["diagnostic" -> "argument is invalid"];
return r;
except (E_TYPE)
r["Error"] = ["diagnostic" -> "data type is invalid"];
return r;
except (E_PERM)
r["Error"] = ["diagnostic" -> "permission denied"];
return r;
endtry
v = parents(o);
m = ["id" -> "parents"];
m["status"] = this:_controls(caller_perms(), o) ? "writable" | "readable";
return ["Meta" -> m, "Value" -> ["value" -> v]];
return;
"{o, r} = args;";
"";
"$private();";
"";
"set_task_perms(caller_perms());";
"";
"try";
"  v = r[\"Value\"][\"value\"];";
"  parents(o) != v && chparents(o, v);";
"except (E_RANGE)";
"  r[\"Error\"] = [\"diagnostic\" -> \"bad message format\"];";
"  return r;";
"except (E_INVARG)";
"  r[\"Error\"] = [\"diagnostic\" -> \"argument is invalid\"];";
"  return r;";
"except (E_TYPE)";
"  r[\"Error\"] = [\"diagnostic\" -> \"data type is invalid\"];";
"  return r;";
"except (E_PERM)";
"  r[\"Error\"] = [\"diagnostic\" -> \"permission denied\"];";
"  return r;";
"endtry";
"v = parents(o);";
"m = [\"id\" -> \"parents\"];";
"m[\"status\"] = this:_controls(caller_perms(), o) ? \"writable\" | \"readable\";";
"";
"return [\"Meta\" -> m, \"Value\" -> [\"value\" -> v]];";
"";
"chunk_length:27";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:13295564FAFF9F44B09B6E7E1EBA217EACD36506";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:14
{o, r} = args;
$private();
set_task_perms(caller_perms());
try
v = r["Value"]["value"];
(is_player(o) != v) && set_player_flag(o, v);
except (E_RANGE)
r["Error"] = ["diagnostic" -> "bad message format"];
return r;
except (E_INVARG)
r["Error"] = ["diagnostic" -> "argument is invalid"];
return r;
except (E_TYPE)
r["Error"] = ["diagnostic" -> "data type is invalid"];
return r;
except (E_PERM)
r["Error"] = ["diagnostic" -> "permission denied"];
return r;
endtry
v = is_player(o);
m = ["id" -> "player"];
m["status"] = `caller_perms().wizard ! E_INVIND' ? "writable" | "readable";
return ["Meta" -> m, "Value" -> ["value" -> v]];
return;
"{o, r} = args;";
"";
"$private();";
"";
"set_task_perms(caller_perms());";
"";
"try";
"  v = r[\"Value\"][\"value\"];";
"  is_player(o) != v && set_player_flag(o, v);";
"except (E_RANGE)";
"  r[\"Error\"] = [\"diagnostic\" -> \"bad message format\"];";
"  return r;";
"except (E_INVARG)";
"  r[\"Error\"] = [\"diagnostic\" -> \"argument is invalid\"];";
"  return r;";
"except (E_TYPE)";
"  r[\"Error\"] = [\"diagnostic\" -> \"data type is invalid\"];";
"  return r;";
"except (E_PERM)";
"  r[\"Error\"] = [\"diagnostic\" -> \"permission denied\"];";
"  return r;";
"endtry";
"v = is_player(o);";
"m = [\"id\" -> \"player\"];";
"m[\"status\"] = `caller_perms().wizard ! E_INVIND' ? \"writable\" | \"readable\";";
"";
"return [\"Meta\" -> m, \"Value\" -> [\"value\" -> v]];";
"";
"chunk_length:27";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:2F9B28A8C6CB72E794788386CBEC7597681A088E";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:15
{o, v, ?options = []} = args;
try
vx = verbs(o);
except (E_TYPE, E_INVARG)
r = ["Meta" -> ["id" -> o, "status" -> "invalid"]];
return r;
endtry
try
vn = vx[v];
except (E_TYPE, E_RANGE)
r = ["Meta" -> ["id" -> v, "status" -> "invalid"]];
return r;
endtry
set_task_perms(caller_perms());
try
vd = $verb_detail(o, v);
code = verb_code(o, v);
doc = $verb_doc(o, v);
d = ["owner" -> vd["owner"], "perms" -> vd["perms"], "names" -> vd["names"], "dobj" -> vd["dobj"], "prep" -> vd["prep"], "iobj" -> vd["iobj"]];
d["code"] = code;
doc && (d["documentation"] = doc);
`d["content_type"] = vd["content_type"] ! E_RANGE';
p = (index(d["perms"], "w") || this:_controls_verb(caller_perms(), o, v)) ? "rw" | "r";
except (E_TYPE, E_INVARG, E_VERBNF)
r = ["Meta" -> ["id" -> v, "status" -> "invalid"]];
return r;
except (E_PERM)
r = ["Meta" -> ["id" -> v, "status" -> "denied"]];
return r;
endtry
m = ["id" -> v];
m["status"] = index(p, "w") ? "writable" | "readable";
r = ["Meta" -> m, "Verb" -> d];
return r;
return;
"{o, v, ?options = []} = args;";
"";
"try";
"  vx = verbs(o);";
"except (E_TYPE, E_INVARG)";
"  r = [\"Meta\" -> [\"id\" -> o, \"status\" -> \"invalid\"]];";
"  return r;";
"endtry";
"try";
"  vn = vx[v];";
"except (E_TYPE, E_RANGE)";
"  r = [\"Meta\" -> [\"id\" -> v, \"status\" -> \"invalid\"]];";
"  return r;";
"endtry";
"";
"set_task_perms(caller_perms());";
"";
"try";
"  vd = $verb_detail(o, v);";
"  code = verb_code(o, v);";
"  doc = $verb_doc(o, v);";
"";
"  d = [\"owner\" -> vd[\"owner\"], \"perms\" -> vd[\"perms\"], \"names\" -> vd[\"names\"], \"dobj\" -> vd[\"dobj\"], \"prep\" -> vd[\"prep\"], \"iobj\" -> vd[\"iobj\"]];";
"";
"  d[\"code\"] = code;";
"  doc && (d[\"documentation\"] = doc);";
"";
"  `d[\"content_type\"] = vd[\"content_type\"] ! E_RANGE';";
"";
"  p = index(d[\"perms\"], \"w\") || this:_controls_verb(caller_perms(), o, v) ? \"rw\" | \"r\";";
"except (E_TYPE, E_INVARG, E_VERBNF)";
"  r = [\"Meta\" -> [\"id\" -> v, \"status\" -> \"invalid\"]];";
"  return r;";
"except (E_PERM)";
"  r = [\"Meta\" -> [\"id\" -> v, \"status\" -> \"denied\"]];";
"  return r;";
"endtry";
"m = [\"id\" -> v];";
"m[\"status\"] = index(p, \"w\") ? \"writable\" | \"readable\";";
"r = [\"Meta\" -> m, \"Verb\" -> d];";
"";
"return r;";
"";
"chunk_length:42";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:52580BB302E80CD6D053ABBA8E02368124868D18";
"state:clean";
"updated_at:Sun Aug 11 10:17:05 2013 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:16
{o, v, r, ?options = []} = args;
error1 = error2 = 0;
try
vx = verbs(o);
except (E_TYPE, E_INVARG)
error1 = 1;
endtry
try
vn = vx[v];
except (E_VARNF)
except (E_TYPE, E_RANGE)
error2 = 1;
endtry
set_task_perms(caller_perms());
old = this:read_verb(o, v);
if (`old["Verb"] ! E_RANGE' == `r["Verb"] ! E_RANGE')
return old;
endif
if (error1)
r["Error"] = ["diagnostic" -> "object reference is invalid"];
return r;
elseif (error2)
r["Error"] = ["diagnostic" -> "verb is invalid"];
return r;
endif
try
r1 = r["Verb"];
set_verb_info(o, v, {`r1["owner"] ! E_RANGE => caller_perms()', r1["perms"], r1["names"]});
set_verb_args(o, v, {r1["dobj"], r1["prep"], r1["iobj"]});
vc = `r1["code"] ! E_RANGE => {}';
if (vc != E_RANGE)
t = options;
`t["content_type"] = r1["content_type"] ! E_RANGE';
if (set_verb_code(o, v, vc, t))
r["Error"] = ["diagnostic" -> "compilation errors"];
return r;
endif
endif
vd = `r1["documentation"] ! E_RANGE';
if (vd != E_RANGE)
if ($set_verb_doc(o, v, vd))
r["Error"] = ["diagnostic" -> "documentation format errors"];
return r;
endif
endif
except (E_RANGE)
r["Error"] = ["diagnostic" -> "bad message format"];
return r;
except (E_INVIND, E_INVARG)
r["Error"] = ["diagnostic" -> "object reference is invalid"];
return r;
except (E_PERM)
r["Error"] = ["diagnostic" -> "permission denied"];
return r;
except (E_TYPE)
r["Error"] = ["diagnostic" -> "data type is invalid"];
return r;
endtry
return this:read_verb(o, v);
return;
"{o, v, r, ?options = []} = args;";
"";
"/* measure, then drop perms, then take action if necessary */";
"";
"error1 = error2 = 0;";
"";
"try";
"  vx = verbs(o);";
"except (E_TYPE, E_INVARG)";
"  error1 = 1;";
"endtry";
"try";
"  vn = vx[v];";
"except (E_VARNF)";
"  /* vx is not defined because `verbs(o)' failed */";
"except (E_TYPE, E_RANGE)";
"  error2 = 1;";
"endtry";
"";
"set_task_perms(caller_perms());";
"";
"old = this:read_verb(o, v);";
"if (`old[\"Verb\"] ! E_RANGE' == `r[\"Verb\"] ! E_RANGE')";
"  return old;";
"endif";
"";
"if (error1)";
"  r[\"Error\"] = [\"diagnostic\" -> \"object reference is invalid\"];";
"  return r;";
"elseif (error2)";
"  r[\"Error\"] = [\"diagnostic\" -> \"verb is invalid\"];";
"  return r;";
"endif";
"";
"try";
"  r1 = r[\"Verb\"];";
"";
"  set_verb_info(o, v, {`r1[\"owner\"] ! E_RANGE => caller_perms()', r1[\"perms\"], r1[\"names\"]});";
"  set_verb_args(o, v, {r1[\"dobj\"], r1[\"prep\"], r1[\"iobj\"]});";
"";
"  vc = `r1[\"code\"] ! E_RANGE => {}';";
"";
"  if (vc != E_RANGE)";
"    t = options;";
"    `t[\"content_type\"] = r1[\"content_type\"] ! E_RANGE';";
"    if (set_verb_code(o, v, vc, t))";
"      r[\"Error\"] = [\"diagnostic\" -> \"compilation errors\"];";
"      return r;";
"    endif";
"  endif";
"";
"  vd = `r1[\"documentation\"] ! E_RANGE';";
"";
"  if (vd != E_RANGE)";
"    if ($set_verb_doc(o, v, vd))";
"      r[\"Error\"] = [\"diagnostic\" -> \"documentation format errors\"];";
"      return r;";
"    endif";
"  endif";
"";
"except (E_RANGE)";
"  r[\"Error\"] = [\"diagnostic\" -> \"bad message format\"];";
"  return r;";
"except (E_INVIND, E_INVARG)";
"  r[\"Error\"] = [\"diagnostic\" -> \"object reference is invalid\"];";
"  return r;";
"except (E_PERM)";
"  r[\"Error\"] = [\"diagnostic\" -> \"permission denied\"];";
"  return r;";
"except (E_TYPE)";
"  r[\"Error\"] = [\"diagnostic\" -> \"data type is invalid\"];";
"  return r;";
"endtry";
"";
"return this:read_verb(o, v);";
"";
"chunk_length:75";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:1E74FD0137192222D717768B6859517C8C2831B3";
"state:clean";
"updated_at:Sun Aug 11 10:17:05 2013 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:17
{o, p, ?options = []} = args;
try
px = properties(o);
except (E_TYPE, E_INVARG)
r = ["Meta" -> ["id" -> o, "status" -> "invalid"]];
return r;
endtry
try
pn = px[p];
except (E_TYPE, E_RANGE)
r = ["Meta" -> ["id" -> p, "status" -> "invalid"]];
return r;
endtry
set_task_perms(caller_perms());
try
pi = property_info(o, pn);
pv = o.(pn);
s = (index(pi[2], "w") || this:_controls_property(caller_perms(), o, pn)) ? "rw" | "r";
except (E_TYPE, E_INVARG, E_PROPNF)
r = ["Meta" -> ["id" -> p, "status" -> "invalid"]];
return r;
except (E_PERM)
r = ["Meta" -> ["id" -> p, "status" -> "denied"]];
return r;
endtry
m = ["id" -> p];
m["status"] = index(s, "w") ? "writable" | "readable";
r = ["Meta" -> m, "Property" -> ["owner" -> pi[1], "perms" -> pi[2], "name" -> pn, "value" -> pv]];
return r;
return;
"{o, p, ?options = []} = args;";
"";
"try";
"  px = properties(o);";
"except (E_TYPE, E_INVARG)";
"  r = [\"Meta\" -> [\"id\" -> o, \"status\" -> \"invalid\"]];";
"  return r;";
"endtry";
"try";
"  pn = px[p];";
"except (E_TYPE, E_RANGE)";
"  r = [\"Meta\" -> [\"id\" -> p, \"status\" -> \"invalid\"]];";
"  return r;";
"endtry";
"";
"set_task_perms(caller_perms());";
"";
"try";
"  pi = property_info(o, pn);";
"  pv = o.(pn);";
"  s = index(pi[2], \"w\") || this:_controls_property(caller_perms(), o, pn) ? \"rw\" | \"r\";";
"except (E_TYPE, E_INVARG, E_PROPNF)";
"  r = [\"Meta\" -> [\"id\" -> p, \"status\" -> \"invalid\"]];";
"  return r;";
"except (E_PERM)";
"  r = [\"Meta\" -> [\"id\" -> p, \"status\" -> \"denied\"]];";
"  return r;";
"endtry";
"m = [\"id\" -> p];";
"m[\"status\"] = index(s, \"w\") ? \"writable\" | \"readable\";";
"r = [\"Meta\" -> m, \"Property\" -> [\"owner\" -> pi[1], \"perms\" -> pi[2], \"name\" -> pn, \"value\" -> pv]];";
"";
"return r;";
"";
"chunk_length:33";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:A68B9AEA6EB6F822FAFF6105D1A109B9F99D6025";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:18
{o, p, r, ?options = []} = args;
error1 = error2 = 0;
try
px = properties(o);
except (E_TYPE, E_INVARG)
error1 = 1;
endtry
try
pn = px[p];
except (E_VARNF)
except (E_TYPE, E_RANGE)
error2 = 1;
endtry
set_task_perms(caller_perms());
old = this:read_property(o, p);
if (`old["Property"] ! E_RANGE' == `r["Property"] ! E_RANGE')
return old;
endif
if (error1)
r["Error"] = ["diagnostic" -> "object reference is invalid"];
return r;
elseif (error2)
r["Error"] = ["diagnostic" -> "property is invalid"];
return r;
endif
try
r1 = r["Property"];
set_property_info(o, pn, {`r1["owner"] ! E_RANGE => caller_perms()', r1["perms"], r1["name"]});
o.(r1["name"]) = r1["value"];
except (E_RANGE)
r["Error"] = ["diagnostic" -> "bad message format"];
return r;
except (E_INVIND, E_INVARG)
r["Error"] = ["diagnostic" -> "object reference is invalid"];
return r;
except (E_PERM)
r["Error"] = ["diagnostic" -> "permission denied"];
return r;
except (E_TYPE)
r["Error"] = ["diagnostic" -> "data type is invalid"];
return r;
endtry
return this:read_property(o, p);
return;
"{o, p, r, ?options = []} = args;";
"";
"/* measure, then drop perms, then take action if necessary */";
"";
"error1 = error2 = 0;";
"";
"try";
"  px = properties(o);";
"except (E_TYPE, E_INVARG)";
"  error1 = 1;";
"endtry";
"try";
"  pn = px[p];";
"except (E_VARNF)";
"  /* px is not defined because `properties(o)' failed */";
"except (E_TYPE, E_RANGE)";
"  error2 = 1;";
"endtry";
"";
"set_task_perms(caller_perms());";
"";
"old = this:read_property(o, p);";
"if (`old[\"Property\"] ! E_RANGE' == `r[\"Property\"] ! E_RANGE')";
"  return old;";
"endif";
"";
"if (error1)";
"  r[\"Error\"] = [\"diagnostic\" -> \"object reference is invalid\"];";
"  return r;";
"elseif (error2)";
"  r[\"Error\"] = [\"diagnostic\" -> \"property is invalid\"];";
"  return r;";
"endif";
"";
"try";
"  r1 = r[\"Property\"];";
"";
"  set_property_info(o, pn, {`r1[\"owner\"] ! E_RANGE => caller_perms()', r1[\"perms\"], r1[\"name\"]});";
"  o.(r1[\"name\"]) = r1[\"value\"];";
"";
"except (E_RANGE)";
"  r[\"Error\"] = [\"diagnostic\" -> \"bad message format\"];";
"  return r;";
"except (E_INVIND, E_INVARG)";
"  r[\"Error\"] = [\"diagnostic\" -> \"object reference is invalid\"];";
"  return r;";
"except (E_PERM)";
"  r[\"Error\"] = [\"diagnostic\" -> \"permission denied\"];";
"  return r;";
"except (E_TYPE)";
"  r[\"Error\"] = [\"diagnostic\" -> \"data type is invalid\"];";
"  return r;";
"endtry";
"";
"return this:read_property(o, p);";
"";
"chunk_length:55";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:D78DD21D8FA7CEC926AF6779C32C69E66E7F2311";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:19
{?parents = {}} = args;
o = ["Attributes" -> [], "Values" -> [], "Properties" -> {}, "Verbs" -> {}];
if (parents)
o["Attributes"]["parents"] = ["Value" -> ["value" -> parents]];
endif
return o;
return;
"{?parents = {}} = args;";
"o = [\"Attributes\" -> [], \"Values\" -> [], \"Properties\" -> {}, \"Verbs\" -> {}];";
"if (parents)";
"  o[\"Attributes\"][\"parents\"] = [\"Value\" -> [\"value\" -> parents]];";
"endif";
"return o;";
"";
"chunk_length:6";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:9969B59DEBF0F2BC6F62679AF94EBE480E3A6B38";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:20
{t, n, v} = args;
t["Values"][n] = ["Value" -> ["value" -> v]];
return t;
return;
"{t, n, v} = args;";
"";
"t[\"Values\"][n] = [\"Value\" -> [\"value\" -> v]];";
"";
"return t;";
"";
"chunk_length:5";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:6B7C622565FB5DA32263B609A8125AB3BCF3F229";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:21
{t, pn, pv, pi} = args;
p = ["Property" -> ["owner" -> pi[1], "perms" -> pi[2], "name" -> pn, "value" -> pv]];
t["Properties"] = {@t["Properties"], p};
return t;
return;
"{t, pn, pv, pi} = args;";
"";
"p = [\"Property\" -> [\"owner\" -> pi[1], \"perms\" -> pi[2], \"name\" -> pn, \"value\" -> pv]];";
"";
"t[\"Properties\"] = {@t[\"Properties\"], p};";
"";
"return t;";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:4EA890888B90932C61B555A4FF4158BEDB2B945E";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:22
{t, vi, va, ?vc = {}} = args;
v = ["Verb" -> ["owner" -> vi[1], "perms" -> vi[2], "names" -> vi[3], "dobj" -> va[1], "prep" -> va[2], "iobj" -> va[3], "code" -> vc]];
t["Verbs"] = {@t["Verbs"], v};
return t;
return;
"{t, vi, va, ?vc = {}} = args;";
"";
"v = [\"Verb\" -> [\"owner\" -> vi[1], \"perms\" -> vi[2], \"names\" -> vi[3], \"dobj\" -> va[1], \"prep\" -> va[2], \"iobj\" -> va[3], \"code\" -> vc]];";
"";
"t[\"Verbs\"] = {@t[\"Verbs\"], v};";
"";
"return t;";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:8A4B8E29A09479CE3DED7B5855A8AEA121411BCB";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:0
$private();
notify(player, tostr(@args));
return;
"$private();";
"";
"/* Log args -- for debugging. */";
"";
"notify(player, tostr(@args));";
"";
"chunk_length:5";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:490E6AF4153E0141BFBA78C901285331F568EB41";
"state:clean";
"updated_at:Sun Dec 30 19:04:42 2012 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:1
$private();
{what, @messages} = args;
if (`what.alt_display_options ! E_PROPNF' == E_PROPNF)
message = "";
stack = messages;
while (stack)
{top, @stack} = stack;
if (typeof(top) == LIST)
{_, _, @body} = top;
stack = {@body, @stack};
else
message = tostr(message, top);
endif
endwhile
`notify(what, message) ! ANY';
else
`what:notify(@messages) ! ANY';
endif
return;
"$private();";
"";
"{what, @messages} = args;";
"";
"/* Send `messages' to `what' for output. Prefer a `notify()' verb over";
" * the `notify()' built-in, but remember that this still has to work";
" * during bootstrapping and with legacy code.";
" */";
"";
"if (`what.alt_display_options ! E_PROPNF' == E_PROPNF)";
"  message = \"\";";
"  stack = messages;";
"  while (stack)";
"    {top, @stack} = stack;";
"    if (typeof(top) == LIST)";
"      {_, _, @body} = top;";
"      stack = {@body, @stack};";
"    else";
"      message = tostr(message, top);";
"    endif";
"  endwhile";
"  `notify(what, message) ! ANY';";
"else";
"  `what:notify(@messages) ! ANY';";
"endif";
"";
"chunk_length:25";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:F646249DB33283A4415AD0B64C2D2C4DD839C37B";
"state:clean";
"updated_at:Sat Apr 13 08:59:55 2013 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:2
$private();
{what, where} = args;
`move(what, where) ! ANY';
return;
"$private();";
"";
"{what, where} = args;";
"";
"/* Move `what' to `where'.  Runs with wiz-perms.  Won't raise an error. */";
"";
"`move(what, where) ! ANY';";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:D8E4C8B1FC542890503A041C595CD6A7507E8CF3";
"state:clean";
"updated_at:Thu Feb 14 21:59:46 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:3
((ticks_left() < 5000) || (seconds_left() < 2)) && suspend(0);
.
#9:4
{specifier} = args;
$private();
if (r = match(specifier, "^%([0-9]+%.[0-9]+%.[0-9]+%),%([_a-zA-Z0-9]+%)$"))
version = specifier[r[3][1][1]..r[3][1][2]];
identifier = specifier[r[3][2][1]..r[3][2][2]];
return {identifier, version};
else
raise(E_INVARG, tostr("Invalid package specifier:  ", specifier));
endif
.
#9:5
{operation} = args;
$private();
if (r = match(operation, "^%(<=%|>=%|<%|>%|=%)? *%([0-9]+%)?%(%.%([0-9]+%)%)?%(%.%([0-9]+%)%)?$"))
op = operation[r[3][1][1]..r[3][1][2]] || "=";
major = operation[r[3][2][1]..r[3][2][2]];
minor = operation[r[3][4][1]..r[3][4][2]];
build = operation[r[3][6][1]..r[3][6][2]];
return {op, major, minor, build};
else
raise(E_INVARG, tostr("Invalid operation:  ", operation));
endif
.
#9:6
{version} = args;
$private();
if (r = match(version, "^%([0-9]+%)%(%.%([0-9]+%)%)%(%.%([0-9]+%)%)$"))
major = version[r[3][1][1]..r[3][1][2]];
minor = version[r[3][3][1]..r[3][3][2]];
build = version[r[3][5][1]..r[3][5][2]];
return {major, minor, build};
else
raise(E_INVARG, tostr("Invalid version:  ", version));
endif
.
#9:7
{ver1, ver2} = args;
$private();
res = 0;
if (ver1[1] && ver2[1])
if (((!(res = toint(ver1[1]) - toint(ver2[1]))) && ver1[2]) && ver2[2])
if (((!(res = toint(ver1[2]) - toint(ver2[2]))) && ver1[3]) && ver2[3])
res = toint(ver1[3]) - toint(ver2[3]);
endif
endif
endif
return res;
.
#9:8
{vers} = args;
$private();
l = length(vers);
i = 1;
while (i <= l)
v = vers[i];
j = i - 1;
while (j > 0)
if (this:_compare_versions(vers[j], v) >= 0)
break;
endif
vers[j + 1] = vers[j];
j = j - 1;
endwhile
vers[j + 1] = v;
i = i + 1;
endwhile
return vers;
.
#9:9
{identifier, @args} = args;
if (args && (typeof(args[$]) == MAP))
patterns = args[1..$ - 1];
provides = args[$];
else
patterns = args;
provides = this.provides_cache;
endif
if ((patterns && (length(patterns) == 1)) && (typeof(patterns[1]) == LIST))
patterns = patterns[1];
endif
if ((versions = `provides[identifier] ! E_RANGE => $nothing') == $nothing)
return {$failed_match};
endif
operations = {};
for pattern in (patterns)
this:_suspend_if_necessary();
operations = {@operations, this:_parse_operation(pattern)};
endfor
for _, version in (versions)
this:_suspend_if_necessary();
v1 = this:_parse_version(version);
for operation in (operations)
this:_suspend_if_necessary();
{op, @v2} = operation;
if (((((("=" == op) && this:_compare_versions(v1, v2)) || ((">=" == op) && (this:_compare_versions(v1, v2) < 0))) || (("<=" == op) && (this:_compare_versions(v1, v2) > 0))) || ((">" == op) && (this:_compare_versions(v1, v2) <= 0))) || (("<" == op) && (this:_compare_versions(v1, v2) >= 0)))
versions = mapdelete(versions, version);
break;
endif
endfor
endfor
if (length(versions) < 1)
return {$failed_match};
elseif (length(versions) > 1)
return {$ambiguous_match};
else
version = mapkeys(versions)[1];
object = mapvalues(versions)[1][1];
return {object, identifier, version};
endif
.
#9:10
{MAP, specifier, object} = args;
$private();
if (typeof(specifier) == LIST)
{identifier, version} = specifier;
else
{identifier, version} = this:_parse_specifier(specifier);
endif
(identifier in mapkeys(MAP)) || (MAP[identifier] = []);
(version in mapkeys(MAP[identifier])) || (MAP[identifier][version] = {});
MAP[identifier][version] = setadd(MAP[identifier][version], object);
return MAP;
.
#9:11
{MAP, specifier, object} = args;
$private();
if (typeof(specifier) == LIST)
{identifier, version} = specifier;
else
{identifier, version} = this:_parse_specifier(specifier);
endif
((identifier in mapkeys(MAP)) && (version in mapkeys(MAP[identifier]))) && (MAP[identifier][version] = setremove(MAP[identifier][version], object));
`MAP[identifier][version] ! E_RANGE => 1' || (MAP[identifier] = mapdelete(MAP[identifier], version));
`MAP[identifier] ! E_RANGE => 1' || (MAP = mapdelete(MAP, identifier));
return MAP;
.
#9:12
$private();
{identifier, version, object} = args;
try
error = 1;
packages_backup = this.packages;
provides_cache_backup = this.provides_cache;
requires_cache_backup = this.requires_cache;
this.packages = setadd(this.packages, object);
this.provides_cache = this:_map_specifier(this.provides_cache, {identifier, version}, object);
for provides in (`object.provides ! E_INVIND, E_TYPE, E_PROPNF => {}')
this.provides_cache = this:_map_specifier(this.provides_cache, provides, object);
endfor
for requires in (`object.requires ! E_INVIND, E_TYPE, E_PROPNF => {}')
provider = this:_match(@requires, this.provides_cache);
this.requires_cache = this:_map_specifier(this.requires_cache, provider[2..3], object);
endfor
error = 0;
finally
if (error)
this.packages = packages_backup;
this.provides_cache = provides_cache_backup;
this.requires_cache = requires_cache_backup;
endif
endtry
return;
"/* Updates $composed data structures that track installed packages.";
" * Assumes that all prerequisites have been checked and are met.";
" * Rolls back changes if an error occurs.  Used by";
" * $composed:install() and $composed:reinitialize().";
" */";
"$private();";
"";
"{identifier, version, object} = args;";
"";
"try";
"  error = 1;";
"  packages_backup = this.packages;";
"  provides_cache_backup = this.provides_cache;";
"  requires_cache_backup = this.requires_cache;";
"";
"  this.packages = setadd(this.packages, object);";
"  this.provides_cache = this:_map_specifier(this.provides_cache, {identifier, version}, object);";
"  for provides in (`object.provides ! E_INVIND, E_TYPE, E_PROPNF => {}')";
"    this.provides_cache = this:_map_specifier(this.provides_cache, provides, object);";
"  endfor";
"  /* add a record for every installed package I require */";
"  /* match() must succeed because all prerequisites should have been checked */";
"  for requires in (`object.requires ! E_INVIND, E_TYPE, E_PROPNF => {}')";
"    provider = this:_match(@requires, this.provides_cache);";
"    this.requires_cache = this:_map_specifier(this.requires_cache, provider[2..3], object);";
"  endfor";
"  error = 0;";
"finally";
"  /* after cleanup, allow the error to propagate upward */";
"  if (error)";
"    this.packages = packages_backup;";
"    this.provides_cache = provides_cache_backup;";
"    this.requires_cache = requires_cache_backup;";
"  endif";
"endtry";
"";
"chunk_length:35";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:1EDBBF4653B5547D16A54AD09B13C13BE227B79D";
"state:clean";
"updated_at:Sat Jul  6 03:55:24 2013 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:13
$private();
{identifier, version, object} = args;
try
error = 1;
packages_backup = this.packages;
provides_cache_backup = this.provides_cache;
requires_cache_backup = this.requires_cache;
this.packages = setremove(this.packages, object);
this.provides_cache = this:_unmap_specifier(this.provides_cache, {identifier, version}, object);
for provides in (`object.provides ! E_INVIND, E_TYPE, E_PROPNF => {}')
this.provides_cache = this:_unmap_specifier(this.provides_cache, provides, object);
endfor
for requires in (`object.requires ! E_INVIND, E_TYPE, E_PROPNF => {}')
provider = this:_find_requires_provider(requires[1], object);
this.requires_cache = this:_unmap_specifier(this.requires_cache, provider[2..3], object);
endfor
error = 0;
finally
if (error)
this.packages = packages_backup;
this.provides_cache = provides_cache_backup;
this.requires_cache = requires_cache_backup;
endif
endtry
return;
"/* Updates $composed data structures that track installed packages.";
" * Assumes that all prerequisites have been checked and are met.";
" * Rolls back changes if an error occurs.  Used by";
" * $composed:uninstall() and $composed:delete().";
" */";
"$private();";
"";
"{identifier, version, object} = args;";
"";
"try";
"  error = 1;";
"  packages_backup = this.packages;";
"  provides_cache_backup = this.provides_cache;";
"  requires_cache_backup = this.requires_cache;";
"";
"  this.packages = setremove(this.packages, object);";
"  this.provides_cache = this:_unmap_specifier(this.provides_cache, {identifier, version}, object);";
"  for provides in (`object.provides ! E_INVIND, E_TYPE, E_PROPNF => {}')";
"    this.provides_cache = this:_unmap_specifier(this.provides_cache, provides, object);";
"  endfor";
"  /* remove all records for all installed packages I require (don't use match here because we need to remove a specific record) */";
"  /* _find_requires_provider() must succeed because all prerequisites should have been checked */";
"  for requires in (`object.requires ! E_INVIND, E_TYPE, E_PROPNF => {}')";
"    provider = this:_find_requires_provider(requires[1], object);";
"    this.requires_cache = this:_unmap_specifier(this.requires_cache, provider[2..3], object);";
"  endfor";
"  error = 0;";
"finally";
"  /* after cleanup, allow the error to propagate upward */";
"  if (error)";
"    this.packages = packages_backup;";
"    this.provides_cache = provides_cache_backup;";
"    this.requires_cache = requires_cache_backup;";
"  endif";
"endtry";
"";
"chunk_length:35";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:0B91739788A1C59D10ABC028C36927A1AE90F1FA";
"state:clean";
"updated_at:Sat Jul  6 03:55:24 2013 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:14
{identifier, object} = args;
$private();
for _, version in (this.requires_cache[identifier])
if (object in this.requires_cache[identifier][version])
return {this.provides_cache[identifier][version][1], identifier, version};
endif
endfor
.
#9:15
$permit("wizard");
if (args)
objects = ((length(args) == 1) && (typeof(args[1]) == LIST)) ? args[1] | args;
else
objects = this.packages;
endif
for object in (objects)
if (typeof(object) != OBJ)
raise(E_INVARG, tostr("Invalid argument: ", object), object);
endif
endfor
limit = length(objects) ^ 2;
packages_backup = this.packages;
requires_cache_backup = this.requires_cache;
provides_cache_backup = this.provides_cache;
this.packages = {};
this.requires_cache = [];
this.provides_cache = [];
while (objects && limit)
{object, @objects} = objects;
$suspend_if_necessary(0);
limit = limit - 1;
try
this:_install(object.identifier, object.version, object);
except (ANY)
objects = {@objects, object};
endtry
endwhile
if (objects)
this.packages = packages_backup;
this.requires_cache = requires_cache_backup;
this.provides_cache = provides_cache_backup;
failed = "";
for object in (objects)
failed = failed ? tostr(failed, ", ", object) | tostr(object);
endfor
raise(E_INVARG, tostr("Failed: ", failed), objects);
endif
return;
"$permit(\"wizard\");";
"";
"/* Reinitializes the package caches from the specified list of";
" * packages.  If the install fails (due to currently uninstalled";
" * packages) it moves the package to the end of the list, continues,";
" * and retries.";
" */";
"";
"if (args)";
"  objects = (length(args) == 1 && typeof(args[1]) == LIST) ? args[1] | args;";
"else";
"  objects = this.packages;";
"endif";
"";
"for object in (objects)";
"  if (typeof(object) != OBJ)";
"    raise(E_INVARG, tostr(\"Invalid argument: \", object), object);";
"  endif";
"endfor";
"";
"/* limit the iterations */";
"limit = length(objects) ^ 2;";
"";
"packages_backup = this.packages;";
"requires_cache_backup = this.requires_cache;";
"provides_cache_backup = this.provides_cache;";
"";
"this.packages = {};";
"this.requires_cache = [];";
"this.provides_cache = [];";
"";
"while (objects && limit)";
"  {object, @objects} = objects;";
"";
"  $suspend_if_necessary(0);";
"";
"  limit = limit - 1;";
"";
"  try";
"    this:_install(object.identifier, object.version, object);";
"  except (ANY)";
"    objects = {@objects, object};";
"  endtry";
"endwhile";
"";
"if (objects)";
"  this.packages = packages_backup;";
"  this.requires_cache = requires_cache_backup;";
"  this.provides_cache = provides_cache_backup;";
"  failed = \"\";";
"  for object in (objects)";
"    failed = failed ? tostr(failed, \", \", object) | tostr(object);";
"  endfor";
"  raise(E_INVARG, tostr(\"Failed: \", failed), objects);";
"endif";
"";
"chunk_length:55";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:1C3F76EDBCB01659115A123D93664FC9DFFB66B7";
"state:clean";
"updated_at:Sat Jul  6 04:13:49 2013 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:16
{required} = args;
$private();
for selector in (required)
object = this:_match(@selector, this.provides_cache)[1];
if (valid(object))
required = setremove(required, selector);
endif
endfor
return required;
.
#9:17
{provided} = args;
$private();
for package in (provided)
{identifier, version} = package;
object = `this.requires_cache[identifier][version][1] ! E_RANGE => $failed_match';
if (!valid(object))
provided = setremove(provided, package);
endif
endfor
return provided;
.
#9:18
$private();
{specifiers} = args;
global = {};
for specifier in (specifiers)
this:_suspend_if_necessary();
{package, ?identifier, ?version} = this:_match(@specifier, this.provides_cache);
if ($failed_match == package)
raise(E_INVARG, tostr("Failed match:  ", toliteral(specifier)));
elseif ($ambiguous_match == package)
raise(E_INVARG, tostr("Ambiguous match:  ", toliteral(specifier)));
endif
for item in (`package.manifest ! E_PROPNF => {}')
{object, label} = item;
global = {@global, {object, tostr(label, "|", identifier)}};
endfor
endfor
global = {@global, {$nothing, "__nothing__"}};
return global;
return;
"$private();";
"";
"{specifiers} = args;";
"";
"/*";
" * Take a list of package specifiers, ensure that the specified";
" * packages are present/installed, and generate a mapping between";
" * objects and identifiers based on the information in each";
" * package manifest.";
" *";
" * $nothing maps to \"__nothing__\", and is included for free.";
" */";
"";
"global = {};";
"";
"for specifier in (specifiers)";
"  this:_suspend_if_necessary();";
"  {package, ?identifier, ?version} = this:_match(@specifier, this.provides_cache);";
"  if ($failed_match == package)";
"    raise(E_INVARG, tostr(\"Failed match:  \", toliteral(specifier)));";
"  elseif ($ambiguous_match == package)";
"    raise(E_INVARG, tostr(\"Ambiguous match:  \", toliteral(specifier)));";
"  endif";
"  for item in (`package.manifest ! E_PROPNF => {}')";
"    {object, label} = item;";
"    global = {@global, {object, tostr(label, \"|\", identifier)}};";
"  endfor";
"endfor";
"";
"global = {@global, {$nothing, \"__nothing__\"}};";
"";
"return global;";
"";
"chunk_length:32";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:D230EE830DC6DADFDA69CF0E029566BDD9C2AFDF";
"state:clean";
"updated_at:Sun Dec 30 13:18:21 2012 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:19
$private();
{specifiers} = args;
global = {};
for specifier in (specifiers)
this:_suspend_if_necessary();
{package, ?identifier, ?version} = this:_match(@specifier, this.provides_cache);
if ($failed_match == package)
raise(E_INVARG, tostr("Failed match:  ", toliteral(specifier)));
elseif ($ambiguous_match == package)
raise(E_INVARG, tostr("Ambiguous match:  ", toliteral(specifier)));
endif
for item in (`package.manifest ! E_PROPNF => {}')
{object, label} = item;
global = {@global, {tostr(label, "|", identifier), object}};
endfor
endfor
global = {@global, {"__nothing__", $nothing}};
return global;
return;
"$private();";
"";
"{specifiers} = args;";
"";
"/*";
" * Take a list of package specifiers, ensure that the specified";
" * packages are present/installed, and generate a mapping between";
" * identifiers and objects based on the information in each";
" * package manifest.";
" *";
" * \"__nothing__\" maps to $nothing, and is included for free.";
" */";
"";
"global = {};";
"";
"for specifier in (specifiers)";
"  this:_suspend_if_necessary();";
"  {package, ?identifier, ?version} = this:_match(@specifier, this.provides_cache);";
"  if ($failed_match == package)";
"    raise(E_INVARG, tostr(\"Failed match:  \", toliteral(specifier)));";
"  elseif ($ambiguous_match == package)";
"    raise(E_INVARG, tostr(\"Ambiguous match:  \", toliteral(specifier)));";
"  endif";
"  for item in (`package.manifest ! E_PROPNF => {}')";
"    {object, label} = item;";
"    global = {@global, {tostr(label, \"|\", identifier), object}};";
"  endfor";
"endfor";
"";
"global = {@global, {\"__nothing__\", $nothing}};";
"";
"return global;";
"";
"chunk_length:32";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:24DDBE3F1CE3D27790AA712723A575665F37AA31";
"state:clean";
"updated_at:Sun Dec 30 17:52:10 2012 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:20
{verb, LIST, @options} = args;
$private();
for i in [1..length(LIST)]
this:_suspend_if_necessary();
LIST[i] = this:(verb)(LIST[i], @options);
endfor
return LIST;
.
#9:21
$private();
{collection, index} = args;
if (typeof(collection) == MAP)
return collection[index];
else
for item in (collection)
if (item[1] == index)
return item[2];
endif
endfor
endif
return E_RANGE;
return;
"$private();";
"";
"{collection, index} = args;";
"";
"if (typeof(collection) == MAP)";
"  return collection[index];";
"else";
"  for item in (collection)";
"    if (item[1] == index)";
"      return item[2];";
"    endif";
"  endfor";
"endif";
"";
"return E_RANGE;";
"";
"chunk_length:15";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:CB252079DCCFB98DF55C376BD0BA7DB8471DDE94";
"state:clean";
"updated_at:Fri Dec 28 20:48:25 2012 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:22
$private();
{object, global, local, package, ?target = ""} = args;
if (typeof(object) == LIST)
return this:_map(verb, @args);
endif
if ((ret = this:_lookup(local, object)) != E_RANGE)
return ret;
elseif ((ret = this:_lookup(global, object)) != E_RANGE)
return ret;
elseif (`object.wizard ! E_INVIND')
return "__wizard__";
elseif (object == caller_perms())
return "__owner__";
elseif (object == package)
return "__package__";
endif
if (target)
raise(E_INVARG, tostr("Lookup failed for:  ", object, " on ", target));
else
raise(E_INVARG, tostr("Lookup failed for:  ", object));
endif
return;
"$private();";
"";
"{object, global, local, package, ?target = \"\"} = args;";
"";
"/* Given an object look up the corresponding reference/label. */";
"";
"if (typeof(object) == LIST)";
"  return this:_map(verb, @args);";
"endif";
"";
"if ((ret = this:_lookup(local, object)) != E_RANGE)";
"  return ret;";
"elseif ((ret = this:_lookup(global, object)) != E_RANGE)";
"  return ret;";
"elseif (`object.wizard ! E_INVIND')";
"  return \"__wizard__\";";
"elseif (object == caller_perms())";
"  return \"__owner__\";";
"elseif (object == package)";
"  return \"__package__\";";
"endif";
"";
"if (target)";
"  raise(E_INVARG, tostr(\"Lookup failed for:  \", object, \" on \", target));";
"else";
"  raise(E_INVARG, tostr(\"Lookup failed for:  \", object));";
"endif";
"";
"chunk_length:27";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:6F6CE157CEC9A11B4A52B217E159ECA43AD57D69";
"state:clean";
"updated_at:Tue Jan  1 14:12:47 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:23
$private();
{label, global, local, package} = args;
if (typeof(label) == LIST)
return this:_map(verb, @args);
endif
if ("__nothing__" == label)
return this:_lookup(global, "__nothing__");
elseif ("__wizard__" == label)
return caller_perms();
elseif ("__owner__" == label)
return caller_perms();
elseif ("__package__" == label)
return package;
elseif (r = match(label, "^%([a-z_][a-z0-9_]*%)%(|%([a-z][a-z0-9_]*%)%)?$"))
reference = label[r[3][1][1]..r[3][1][2]];
identifier = label[r[3][3][1]..r[3][3][2]];
if (reference && identifier)
if ((ret = this:_lookup(global, label)) != E_RANGE)
return ret;
endif
else
if ((ret = this:_lookup(local, label)) != E_RANGE)
return ret;
endif
endif
endif
raise(E_INVARG, tostr("Lookup failed for:  ", toliteral(label)));
return;
"$private();";
"";
"{label, global, local, package} = args;";
"";
"/* Given a reference/label look up the corresponding object. */";
"";
"if (typeof(label) == LIST)";
"  return this:_map(verb, @args);";
"endif";
"";
"if (\"__nothing__\" == label)";
"  return this:_lookup(global, \"__nothing__\");";
"elseif (\"__wizard__\" == label)";
"  return caller_perms();";
"elseif (\"__owner__\" == label)";
"  return caller_perms();";
"elseif (\"__package__\" == label)";
"  return package;";
"elseif (r = match(label, \"^%([a-z_][a-z0-9_]*%)%(|%([a-z][a-z0-9_]*%)%)?$\"))";
"  reference = label[r[3][1][1]..r[3][1][2]];";
"  identifier = label[r[3][3][1]..r[3][3][2]];";
"  if (reference && identifier)";
"    if ((ret = this:_lookup(global, label)) != E_RANGE)";
"      return ret;";
"    endif";
"  else";
"    if ((ret = this:_lookup(local, label)) != E_RANGE)";
"      return ret;";
"    endif";
"  endif";
"endif";
"";
"raise(E_INVARG, tostr(\"Lookup failed for:  \", toliteral(label)));";
"";
"chunk_length:33";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:DCE8E6339CD12567ED1B5C7E3B3694E167F80CAE";
"state:clean";
"updated_at:Tue Jan  1 14:12:55 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:24
{subject, target, MAP} = args;
$private();
keys = mapkeys(MAP);
stack = {target};
while (stack)
this:_suspend_if_necessary();
{target, @stack} = stack;
if (target in keys)
parents = `MAP[target]["Attributes"]["parents"]["Value"]["value"] ! E_RANGE => "__nothing__"';
if (typeof(parents) == LIST)
if (subject in parents)
return 1;
else
stack = {@parents, @stack};
endif
else
if (subject == parents)
return 1;
else
stack = {parents, @stack};
endif
endif
endif
endwhile
return 0;
.
#9:25
{object} = args;
$private();
objects = {};
if (valid(object))
stack = {object};
while (stack)
top = stack[1];
stack = {@top.contents, @stack[2..$]};
objects = {@objects, top};
endwhile
endif
return objects;
.
#9:26
$permit("wizard");
`{package, @options} = args ! E_ARGS => raise(E_ARGS, "Incorrect number of arguments:  package, @options")';
if (options)
if (typeof(options[1]) != MAP)
{?identifier, ?version, ?options = []} = options;
else
options = options[1];
endif
endif
try
identifier;
version;
except (E_VARNF)
identifier = package.identifier;
version = package.version;
endtry
(!valid(package.location)) || raise(E_INVARG, "Not in $nothing");
(package in this.packages) && raise(E_INVARG, "Package is already installed");
provides = `package.provides ! E_PROPNF => {}';
provides = {{identifier, version}, @provides};
for p in (provides)
{id, v} = p;
valid(this:_match(id, v)[1]) && raise(E_INVARG, tostr("Package is already installed:  identifier = ", id, ", version = ", v));
endfor
requires = `package.requires ! E_PROPNF => {}';
(requires = this:_check_required_provides(requires)) && raise(E_INVARG, tostr("Package requires:  ", toliteral(requires)));
errors = [];
if (respond_to(package, "before_install"))
try
package:before_install();
except ex (ANY)
errors["before_install"] = ex;
endtry
endif
if (`options["follow-instructions"] ! ANY')
this:_do_instructions(identifier, version, package);
endif
this:_install(identifier, version, package);
if (respond_to(package, "after_install"))
try
package:after_install();
except ex (ANY)
errors["after_install"] = ex;
endtry
endif
return errors || 0;
.
#9:27
$permit("wizard");
`{identifier, version, ?options = []} = args ! E_ARGS => raise(E_ARGS, "Incorrect number of arguments:  identifier, version, ?options")';
valid(object = this:_match(identifier, version)[1]) || raise(E_INVARG, tostr("Package is not installed:  identifier = ", identifier, ", version = ", version));
provides = `object.provides ! E_PROPNF => {}';
provides = {{identifier, version}, @provides};
(provides = this:_check_provided_requires(provides)) && raise(E_INVARG, tostr("Package provides:  ", toliteral(provides)));
errors = [];
if (respond_to(object, "before_uninstall"))
try
object:before_uninstall();
except ex (ANY)
errors["before_uninstall"] = ex;
endtry
endif
if (`options["follow-instructions"] ! ANY')
this:_undo_instructions(identifier, version, object);
endif
this:_uninstall(identifier, version, object);
if (respond_to(object, "after_uninstall"))
try
object:after_uninstall();
except ex (ANY)
errors["after_uninstall"] = ex;
endtry
endif
return errors || 0;
.
#9:28
args || raise(E_ARGS);
packages = this.packages;
set_task_perms(caller_perms());
if (((t = typeof(args[1])) == OBJ) || (t == ANON))
{object, ?options = []} = args;
identifier = version = "";
else
{identifier, version, ?options = []} = args;
object = this:_match(identifier, version)[1];
(object == $failed_match) && raise(E_INVARG, tostr("Package is not installed:  identifier = ", identifier, ", version = ", version));
endif
(object == $lookup("__package__")) && raise(E_INVARG, tostr("Can't delete privileged package:  identifier = ", object.identifier, ", version = ", object.version));
p = caller_perms();
while (valid(p))
(p == object) && raise(E_INVARG, tostr(caller_perms(), " is/is inside of ", object));
p = p.location;
endwhile
errors = [];
if (object in packages)
identifier = identifier || object.identifier;
version = version || object.version;
provides = {{identifier, version}};
(provides = this:_check_provided_requires(provides)) && raise(E_INVARG, tostr("Package provides:  ", toliteral(provides)));
if (valid(object) && respond_to(object, "before_uninstall"))
try
object:before_uninstall();
except ex (ANY)
errors["before_uninstall"] = ex;
endtry
endif
if (`options["follow-instructions"] ! ANY')
this:_undo_instructions(identifier, version, object);
endif
this:_uninstall(identifier, version, object);
if (valid(object) && respond_to(object, "after_uninstall"))
try
object:after_uninstall();
except ex (ANY)
errors["after_uninstall"] = ex;
endtry
endif
endif
if (valid(object))
for item in (this:_contents(object))
`recycle(item) ! ANY => 0';
endfor
endif
return errors || 0;
.
#9:29
$private();
bg_seconds = $server_options.bg_seconds;
bg_ticks = $server_options.bg_ticks;
$server_options.bg_seconds = 60 * 60;
$server_options.bg_ticks = (1024 * 1024) * 1024;
suspend(0);
return {bg_seconds, bg_ticks};
.
#9:30
$private();
{args} = args;
{bg_seconds, bg_ticks} = args;
$server_options.bg_seconds = bg_seconds;
$server_options.bg_ticks = bg_ticks;
.
#9:31
{package} = args;
set_task_perms(caller_perms());
try
configuration = package["Configuration"];
version = configuration["version"];
top = configuration["top"];
objects = package["Objects"];
objects[top];
except ex (E_TYPE, E_RANGE)
raise(E_INVARG, "Incompatible package format");
endtry
(version in {"0.1", "0.2"}) || raise(E_INVARG, "Unsupported package version");
anonymous = (version == "0.2") ? configuration["anonymous"] | {};
requires = `objects[top]["Values"]["requires"]["Value"]["value"] ! E_RANGE => {}';
manifest = `objects[top]["Values"]["manifest"]["Value"]["value"] ! E_RANGE => {}';
relocate = `objects[top]["Values"]["relocate"]["Value"]["value"] ! E_RANGE => {}';
(missing = this:_check_required_provides(requires)) && raise(E_INVARG, tostr("Package requires:  ", toliteral(missing)));
global = this:_generate_global_mapping_keyed_on_identifier(requires);
labels = {};
mapkeys_objects = mapkeys(objects);
for label in (manifest)
(label in mapkeys_objects) || raise(E_INVARG, tostr("Invalid value in `manifest':  ", label));
labels = setadd(labels, label);
endfor
for label in (mapkeys_objects)
labels = setadd(labels, label);
endfor
unsorted = labels;
labels = {};
for label in (unsorted)
i = 1;
for target in (labels)
if (this:_is_ancestor(label, target, objects))
break;
endif
i = i + 1;
endfor
labels = {@labels[1..i - 1], label, @labels[i..$]};
endfor
success = 0;
try
local = {};
locations = [];
local = {@local, {top, top_object = create($nothing, top in anonymous)}};
for label in (setremove(labels, top))
this:_suspend_if_necessary();
local = {@local, {label, object = create($nothing, label in anonymous)}};
this:_move(object, top_object);
endfor
relocate_map = [];
for reference in (relocate)
this:_suspend_if_necessary();
if (r = match(reference, "^%([a-z_][a-z0-9_]*%)%.%([a-z_][a-z0-9_]*%)$"))
r1 = reference[r[3][1][1]..r[3][1][2]];
r2 = reference[r[3][2][1]..r[3][2][2]];
if (!(r2 in {"owner", "parents", "location"}))
(r1 in mapkeys(relocate_map)) || (relocate_map[r1] = {});
relocate_map[r1] = {@relocate_map[r1], r2};
endif
else
raise(E_INVARG, tostr("Invalid reference in `relocate':  ", reference));
endif
endfor
for label in (labels)
this:_suspend_if_necessary();
object = this:_lookup(local, label);
definition = objects[label];
if (`definition["Values"]["owner"] ! E_RANGE' != E_RANGE)
if (caller_perms().wizard)
definition["Values"]["owner"]["Value"]["value"] = this:_lookup_by_label(definition["Values"]["owner"]["Value"]["value"], global, local, top_object);
else
definition["Values"] = mapdelete(definition["Values"], "owner");
endif
endif
if (`definition["Attributes"]["parents"] ! E_RANGE' != E_RANGE)
definition["Attributes"]["parents"]["Value"]["value"] = this:_lookup_by_label(definition["Attributes"]["parents"]["Value"]["value"], global, local, top_object);
endif
if (`definition["Values"]["location"] ! E_RANGE' != E_RANGE)
locations[label] = definition["Values"]["location"]["Value"]["value"];
definition["Values"] = mapdelete(definition["Values"], "location");
endif
if (`relocate_map[label] ! E_RANGE => 0')
for name in (relocate_map[label])
this:_suspend_if_necessary();
if (`definition["Values"][name]["Value"]["value"] ! E_RANGE => 0')
definition["Values"][name]["Value"]["value"] = this:_lookup_by_label(definition["Values"][name]["Value"]["value"], global, local, top_object);
else
for property in (definition["Properties"])
this:_suspend_if_necessary();
if (property["Property"]["name"] == name)
value = this:_lookup_by_label(property["Property"]["value"], global, local, top_object);
definition["Values"][name] = ["Value" -> ["value" -> value]];
endif
endfor
endif
endfor
endif
for _, value in (definition["Values"])
this:_suspend_if_necessary();
if (`definition["Values"][value]["Value"]["owner"] ! E_RANGE' != E_RANGE)
if (caller_perms().wizard)
definition["Values"][value]["Value"]["owner"] = this:_lookup_by_label(definition["Values"][value]["Value"]["owner"], global, local, top_object);
else
definition["Values"][value]["Value"] = mapdelete(definition["Values"][value]["Value"], "owner");
endif
endif
endfor
for index in [1..length(definition["Verbs"])]
this:_suspend_if_necessary();
if (`definition["Verbs"][index]["Verb"]["owner"] ! E_RANGE' != E_RANGE)
if (caller_perms().wizard)
definition["Verbs"][index]["Verb"]["owner"] = this:_lookup_by_label(definition["Verbs"][index]["Verb"]["owner"], global, local, top_object);
else
definition["Verbs"][index]["Verb"] = mapdelete(definition["Verbs"][index]["Verb"], "owner");
endif
endif
endfor
for index in [1..length(definition["Properties"])]
this:_suspend_if_necessary();
if (`definition["Properties"][index]["Property"]["owner"] ! E_RANGE' != E_RANGE)
if (caller_perms().wizard)
definition["Properties"][index]["Property"]["owner"] = this:_lookup_by_label(definition["Properties"][index]["Property"]["owner"], global, local, top_object);
else
definition["Properties"][index]["Property"] = mapdelete(definition["Properties"][index]["Property"], "owner");
endif
endif
endfor
definition = $shapes:write_object(object, definition, ["verbs" -> ["do-not-version" -> 1, "do-not-stamp" -> 1]]);
objects[label] = definition;
package["Objects"] = objects;
endfor
for label in (labels)
this:_suspend_if_necessary();
if ("Error" in mapkeys(package["Objects"][label]))
raise("E_PACKAGE", "Error in package operation", package);
endif
endfor
for label in (labels)
this:_suspend_if_necessary();
if (label != top)
object = this:_lookup(local, label);
value = `locations[label] ! E_RANGE => "__package__"';
value = (value == "__package__") ? top_object | this:_lookup(local, value);
this:_move(object, value);
endif
endfor
for entry in [1..`length(top_object.manifest) ! E_PROPNF => 0']
this:_suspend_if_necessary();
top_object.manifest[entry] = {this:_lookup(local, top_object.manifest[entry]), top_object.manifest[entry]};
endfor
success = 1;
finally
success || this:delete(top_object);
endtry
return top_object;
.
#9:32
{package, ?options = []} = args;
set_task_perms(caller_perms());
strip = `options["strip"] ! E_RANGE => {}';
truncate = `options["truncate"] ! E_RANGE => {}';
`valid(package) ! E_TYPE => 0' || raise(E_INVARG, "Not a valid package");
(!valid(package.location)) || raise(E_INVARG, "Not a valid package:  must not have a location");
requires = `package.requires ! E_PROPNF => {}';
manifest = `package.manifest ! E_PROPNF => {}';
relocate = `package.relocate ! E_PROPNF => {}';
objects = this:_contents(package);
for item in (manifest)
{object, label} = item;
`valid(object) ! E_TYPE' || raise(E_INVARG, tostr("Invalid object in manifest:  ", label));
(caller_perms().wizard || (package.owner == object.owner)) || raise(E_PERM, tostr("Invalid object in manifest:  ", label));
objects = setadd(objects, object);
endfor
definition = ["Configuration" -> ["Version" -> "0.2"], "Objects" -> []];
(missing = this:_check_required_provides(requires)) && raise(E_INVARG, tostr("Package requires:  ", toliteral(missing)));
global = this:_generate_global_mapping_keyed_on_object(requires);
for key in (`mapkeys(options["global"]) ! E_RANGE => {}')
this:_suspend_if_necessary();
global = {@global, {key, options["global"][key]}};
endfor
local = {};
anonymous = {};
for object in (objects)
this:_suspend_if_necessary();
if ((t = typeof(object)) == OBJ)
label = tostr("__", toint(object), "__");
else
label = tostr("__", random(), "__");
endif
if (object == package)
label = "__package__";
endif
for entry in (manifest)
if (entry[1] == object)
label = entry[2];
break;
endif
endfor
local = {@local, {object, label}};
if (t == ANON)
anonymous = {@anonymous, label};
endif
definition["Objects"][label] = $shapes:read_object(object, ["strip_clear_values" -> 1]);
if (object in strip)
values = [];
for name in ({"name", "owner", "location", "programmer", "wizard", "r", "w", "f", "a"})
values[name] = definition["Objects"][label]["Values"][name];
endfor
for index in [1..length(definition["Objects"][label]["Properties"])]
name = definition["Objects"][label]["Properties"][index]["property"]["name"];
values[name] = definition["Objects"][label]["Values"][name];
endfor
definition["Objects"][label]["Values"] = values;
endif
endfor
top = definition["Configuration"]["top"] = this:_lookup(local, package);
definition["Configuration"]["anonymous"] = anonymous;
labels = {};
for entry in (manifest)
this:_suspend_if_necessary();
labels = {@labels, entry[2]};
endfor
for object in (objects)
this:_suspend_if_necessary();
label = this:_lookup(local, object);
for _, v in (definition["Objects"][label]["Values"])
this:_suspend_if_necessary();
if (`"owner" in mapkeys(definition["Objects"][label]["Values"][v]["Value"]) ! E_RANGE')
definition["Objects"][label]["Values"][v]["Value"]["owner"] = this:_lookup_by_object(definition["Objects"][label]["Values"][v]["Value"]["owner"], global, local, package, label);
endif
endfor
for i in [1..length(definition["Objects"][label]["Properties"])]
this:_suspend_if_necessary();
definition["Objects"][label]["Properties"][i]["Property"]["owner"] = this:_lookup_by_object(definition["Objects"][label]["Properties"][i]["Property"]["owner"], global, local, package, label);
endfor
for i in [1..length(definition["Objects"][label]["Verbs"])]
this:_suspend_if_necessary();
definition["Objects"][label]["Verbs"][i]["Verb"]["owner"] = this:_lookup_by_object(definition["Objects"][label]["Verbs"][i]["Verb"]["owner"], global, local, package, label);
endfor
if ("owner" in mapkeys(definition["Objects"][label]["Values"]))
definition["Objects"][label]["Values"]["owner"]["Value"]["value"] = this:_lookup_by_object(definition["Objects"][label]["Values"]["owner"]["Value"]["value"], global, local, package, label);
endif
definition["Objects"][label]["Attributes"]["parents"]["Value"]["value"] = this:_lookup_by_object(definition["Objects"][label]["Attributes"]["parents"]["Value"]["value"], global, local, package, label);
definition["Objects"][label]["Values"]["location"]["Value"]["value"] = this:_lookup_by_object(definition["Objects"][label]["Values"]["location"]["Value"]["value"], global, local, package, label);
endfor
for reference in (relocate)
this:_suspend_if_necessary();
if (r = match(reference, "^%([a-z_][a-z0-9_]*%)%.%([a-z_][a-z0-9_]*%)$"))
r1 = reference[r[3][1][1]..r[3][1][2]];
r2 = reference[r[3][2][1]..r[3][2][2]];
if (r1 in labels)
if (((r2 != "parents") && (r2 != "location")) && (r2 != "owner"))
try
definition["Objects"][r1]["Values"][r2]["Value"]["value"];
except (E_RANGE)
raise(E_INVARG, tostr("Invalid reference in `relocate':  \"", r2, "\" in \"", reference, "\""));
endtry
definition["Objects"][r1]["Values"][r2]["Value"]["value"] = this:_lookup_by_object(definition["Objects"][r1]["Values"][r2]["Value"]["value"], global, local, package, r1);
for property in [1..length(definition["Objects"][r1]["Properties"])]
this:_suspend_if_necessary();
if (definition["Objects"][r1]["Properties"][property]["Property"]["name"] == r2)
definition["Objects"][r1]["Properties"][property]["Property"]["value"] = definition["Objects"][r1]["Values"][r2]["Value"]["value"];
break property;
endif
endfor
endif
else
raise(E_INVARG, tostr("Invalid reference in `relocate':  \"", r1, "\" in \"", reference, "\""));
endif
else
raise(E_INVARG, tostr("Invalid reference in `relocate':  ", reference));
endif
endfor
for object in (truncate)
this:_suspend_if_necessary();
if (object in objects)
label = this:_lookup(local, object);
values = [];
for _, value in (definition["Objects"][label]["Values"])
this:_suspend_if_necessary();
if (value in {"name", "owner", "location", "programmer", "wizard", "r", "w", "f", "a"})
values[value] = definition["Objects"][label]["Values"][value];
endif
endfor
definition["Objects"][label]["Values"] = values;
endif
endfor
if (("manifest" in mapkeys(definition["Objects"][top]["Values"])) && (!definition["Objects"][top]["Values"]["manifest"]["Value"]["clear"]))
for entry in [1..length(definition["Objects"][top]["Values"]["manifest"]["Value"]["value"])]
this:_suspend_if_necessary();
definition["Objects"][top]["Values"]["manifest"]["Value"]["value"][entry] = definition["Objects"][top]["Values"]["manifest"]["Value"]["value"][entry][2];
endfor
endif
for property in [1..length(definition["Objects"][top]["Properties"])]
this:_suspend_if_necessary();
if (definition["Objects"][top]["Properties"][property]["Property"]["name"] == "manifest")
for entry in [1..length(definition["Objects"][top]["Properties"][property]["Property"]["value"])]
this:_suspend_if_necessary();
definition["Objects"][top]["Properties"][property]["Property"]["value"][entry] = definition["Objects"][top]["Properties"][property]["Property"]["value"][entry][2];
endfor
break;
endif
endfor
return definition;
.
#9:33
$private();
{url} = args;
if (r = match(url, "^http://%([^/:]+%)%(:[0-9]+%)?%(.*%)$"))
host = url[r[3][1][1]..r[3][1][2]];
port = toint(url[r[3][2][1] + 1..r[3][2][2]]) || 80;
path = url[r[3][3][1]..r[3][3][2]];
return {host, port, path};
else
return 0;
endif
return;
"$private();";
"";
"{url} = args;";
"";
"if ((r = match(url, \"^http://%([^/:]+%)%(:[0-9]+%)?%(.*%)$\")))";
"  host = url[r[3][1][1]..r[3][1][2]];";
"  port = toint(url[r[3][2][1] + 1..r[3][2][2]]) || 80;";
"  path = url[r[3][3][1]..r[3][3][2]];";
"  return {host, port, path};";
"else";
"  return 0;";
"endif";
"";
"chunk_length:12";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:C8D6E8A9369CE73B1A13EBE02B3990C010133F8D";
"state:clean";
"updated_at:Sat Jan  5 13:26:29 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:34
$private();
{url} = args;
while redirect (1)
try
connection = 0;
url = strsub(url, "~", "~7E");
if (r = this:_parse_url(url))
{host, port, path} = r;
else
raise(E_INVARG, "Bad URL");
endif
try
connection = open_network_connection(host, port);
except (E_INVARG)
raise(E_INVARG, "Open network connection failed");
endtry
set_connection_option(connection, "hold-input", 1);
set_connection_option(connection, "binary", 1);
notify(connection, tostr("GET ", path, " HTTP/1.1~0D~0A"));
notify(connection, (port != 80) ? tostr("Host: ", host, ":", port, "~0D~0A") | tostr("Host: ", host, "~0D~0A"));
notify(connection, "Accept: application/json~0D~0A");
notify(connection, "~0D~0A");
response = read_http("response", connection);
if (`reason = response["error"] ! E_RANGE')
raise(E_INVARG, tostr("Fetch failed: ", reason[2]));
elseif (!((status = response["status"]) in {200, 301, 302, 303, 307}))
raise(E_INVARG, tostr("Fetch failed: invalid HTTP status: ", status));
elseif ((status / 100) == 3)
try
url = response["headers"]["location"];
continue redirect;
except (E_RANGE)
raise(E_INVARG, "Fetch failed: missing HTTP header: Location");
endtry
endif
json = strsub(response["body"], "~7E", "~");
try
return parse_json(json, "embedded-types");
except (E_RANGE, E_INVARG)
raise(E_INVARG, "Bad JSON");
endtry
finally
`boot_player(connection) ! ANY';
endtry
endwhile
return;
"$private();";
"";
"{url} = args;";
"";
"/* Attempt an HTTP connection; handle success, follow redirects and";
" * raise errors on everything else.  Note: this verb is optimized for";
" * fetching package lists/packages, and takes a few short-cuts.  In";
" * particular, it simply uses `strsub()' to encode/decode the MOO";
" * binary string representation of tilde (\"~\"), relying on the fact";
" * that packages _should not have_ any binary (non-printable)";
" * characters in them.";
" */";
"";
"while redirect (1)";
"  try";
"    connection = 0;";
"";
"    url = strsub(url, \"~\", \"~7E\");";
"";
"    if ((r = this:_parse_url(url)))";
"      {host, port, path} = r;";
"    else";
"      raise(E_INVARG, \"Bad URL\");";
"    endif";
"";
"    try";
"      connection = open_network_connection(host, port);";
"    except (E_INVARG)";
"      raise(E_INVARG, \"Open network connection failed\");";
"    endtry";
"";
"    set_connection_option(connection, \"hold-input\", 1);";
"    set_connection_option(connection, \"binary\", 1);";
"";
"    notify(connection, tostr(\"GET \", path, \" HTTP/1.1~0D~0A\"));";
"    notify(connection, (port != 80) ? tostr(\"Host: \", host, \":\", port, \"~0D~0A\") | tostr(\"Host: \", host, \"~0D~0A\"));";
"    notify(connection, \"Accept: application/json~0D~0A\");";
"    notify(connection, \"~0D~0A\");";
"";
"    response = read_http(\"response\", connection);";
"";
"    if (`reason = response[\"error\"] ! E_RANGE')";
"      raise(E_INVARG, tostr(\"Fetch failed: \", reason[2]));";
"    elseif (!((status = response[\"status\"]) in {200, 301, 302, 303, 307}))";
"      raise(E_INVARG, tostr(\"Fetch failed: invalid HTTP status: \", status));";
"    elseif (status / 100 == 3)";
"      try";
"        url = response[\"headers\"][\"location\"];";
"        continue redirect;";
"      except (E_RANGE)";
"        raise(E_INVARG, \"Fetch failed: missing HTTP header: Location\");";
"      endtry";
"    endif";
"";
"    json = strsub(response[\"body\"], \"~7E\", \"~\");";
"";
"    try";
"      return parse_json(json, \"embedded-types\");";
"    except (E_RANGE, E_INVARG)";
"      raise(E_INVARG, \"Bad JSON\");";
"    endtry";
"";
"  finally";
"    `boot_player(connection) ! ANY';";
"  endtry";
"";
"endwhile";
"";
"chunk_length:67";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:D83D736F33D7938C27F62A0AD910A718DA0CE0BF";
"state:clean";
"updated_at:Tue Feb 12 06:36:06 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:35
$permit("wizard");
args && raise(E_ARGS);
sources = this.archive_sources;
this:_notify(player, {"h2", [], "Updating index from archive sources"});
indexes = [];
for source in (sources)
try
this:_suspend_if_necessary();
indexes[source] = this:_fetch(source);
this:_notify(player, "   ", source);
except ex (E_INVARG)
this:_notify(player, "   ", source, " ... ", {"span", ["class" -> "error"], ex[2]});
endtry
endfor
this:_notify(player);
archived = [];
while (sources)
source = sources[$];
sources = sources[^..$ - 1];
try
index = indexes[source];
except (E_RANGE)
continue;
endtry
if (`index["_links"] ! E_RANGE')
for package in (index["_embedded"]["packages"])
this:_suspend_if_necessary();
mk = mapkeys(package);
if ((("identifier" in mk) && ("version" in mk)) && ("_links" in mk))
if (`href = package["_links"]["self"]["href"] ! E_RANGE')
if (r = this:_parse_url(href))
else
r = this:_parse_url(source);
if (href[1] == "/")
href = tostr("http://", r[1], ":", r[2], href);
else
if (i = rindex(r[3], "/"))
href = tostr("http://", r[1], ":", r[2], r[3][1..i], href);
else
href = tostr("http://", r[1], ":", r[2], "/", href);
endif
endif
endif
identifier = package["identifier"];
version = package["version"];
requires = `package["requires"] ! E_RANGE => {}';
`archived[identifier] ! E_RANGE' || (archived[identifier] = []);
archived[identifier][version] = ["href" -> href, "requires" -> requires];
endif
endif
endfor
else
for package in (index["Packages"])
this:_suspend_if_necessary();
mk = mapkeys(package);
if ((("identifier" in mk) && ("version" in mk)) && ("link" in mk))
mk = mapkeys(package["link"]);
if ((("uri" in mk) && ("rel" in mk)) && (package["link"]["rel"] == "package"))
uri = package["link"]["uri"];
r = this:_parse_url(source);
if (i = rindex(r[3], "/"))
href = tostr("http://", r[1], ":", r[2], r[3][1..i], uri);
else
href = tostr("http://", r[1], ":", r[2], "/", uri);
endif
identifier = package["identifier"];
version = package["version"];
requires = `package["requires"] ! E_RANGE => {}';
`archived[identifier] ! E_RANGE' || (archived[identifier] = []);
archived[identifier][version] = ["href" -> href, "requires" -> requires];
endif
endif
endfor
endif
endwhile
this.archived = archived;
this.last_fetch_index = time();
return archived;
return;
"$permit(\"wizard\");";
"";
"args && raise(E_ARGS);";
"";
"sources = this.archive_sources;";
"";
"this:_notify(player, {\"h2\", [], \"Updating index from archive sources\"});";
"";
"indexes = [];";
"";
"for source in (sources)";
"  try";
"    this:_suspend_if_necessary();";
"    indexes[source] = this:_fetch(source);";
"    this:_notify(player, \"   \", source);";
"  except ex (E_INVARG)";
"    this:_notify(player, \"   \", source, \" ... \", {\"span\", [\"class\" -> \"error\"], ex[2]});";
"  endtry";
"endfor";
"";
"this:_notify(player);";
"";
"archived = [];";
"";
"while (sources)";
"";
"  /* Fetch in reverse order.  The packages in the archives in";
"   * `archive_sources' will take precedence in order, first to last by";
"   * source.";
"   */";
"";
"  source = sources[$];";
"  sources = sources[^ .. ($ - 1)];";
"";
"  try";
"    index = indexes[source];";
"  except (E_RANGE)";
"    /* there must have been a fetch error */";
"    continue;";
"  endtry";
"";
"  /* Handle both the old and new index formats.  Look for \"_links\" at";
"   * the top-level to distinguish the two.  See the HAL JSON";
"   * specification for details on the format.";
"   */";
"";
"  if (`index[\"_links\"] ! E_RANGE')";
"    for package in (index[\"_embedded\"][\"packages\"])";
"      this:_suspend_if_necessary();";
"      mk = mapkeys(package);";
"      if (\"identifier\" in mk && \"version\" in mk && \"_links\" in mk)";
"        if (`href = package[\"_links\"][\"self\"][\"href\"] ! E_RANGE')";
"          if ((r = this:_parse_url(href)))";
"            /* full URL -- use it as is */";
"          else";
"            r = this:_parse_url(source);";
"            if (href[1] == \"/\")              /* absolute URL */";
"              href = tostr(\"http://\", r[1], \":\", r[2], href);";
"            else                             /* relative URL */";
"              if ((i = rindex(r[3], \"/\")))";
"                href = tostr(\"http://\", r[1], \":\", r[2], r[3][1..i], href);";
"              else";
"                href = tostr(\"http://\", r[1], \":\", r[2], \"/\", href);";
"              endif";
"            endif";
"          endif";
"          identifier = package[\"identifier\"];";
"          version = package[\"version\"];";
"          requires = `package[\"requires\"] ! E_RANGE => {}';";
"          `archived[identifier] ! E_RANGE' || (archived[identifier] = []);";
"          archived[identifier][version] = [\"href\" -> href, \"requires\" -> requires];";
"        endif";
"      endif";
"    endfor";
"  else";
"    for package in (index[\"Packages\"])";
"      this:_suspend_if_necessary();";
"      mk = mapkeys(package);";
"      if (\"identifier\" in mk && \"version\" in mk && \"link\" in mk)";
"        mk = mapkeys(package[\"link\"]);";
"        if (\"uri\" in mk && \"rel\" in mk && package[\"link\"][\"rel\"] == \"package\")";
"          /* old style is relative URLs */";
"          uri = package[\"link\"][\"uri\"];";
"          r = this:_parse_url(source);";
"          if ((i = rindex(r[3], \"/\")))";
"            href = tostr(\"http://\", r[1], \":\", r[2], r[3][1..i], uri);";
"          else";
"            href = tostr(\"http://\", r[1], \":\", r[2], \"/\", uri);";
"          endif";
"          identifier = package[\"identifier\"];";
"          version = package[\"version\"];";
"          requires = `package[\"requires\"] ! E_RANGE => {}';";
"          `archived[identifier] ! E_RANGE' || (archived[identifier] = []);";
"          archived[identifier][version] = [\"href\" -> href, \"requires\" -> requires];";
"        endif";
"      endif";
"    endfor";
"  endif";
"endwhile";
"";
"this.archived = archived;";
"";
"this.last_fetch_index = time();";
"";
"return archived;";
"";
"chunk_length:105";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:C0052C727BE95D2548259AC604DEF9F7D2F528A2";
"state:clean";
"updated_at:Fri Jul 12 23:07:49 2013 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:36
$permit("wizard");
`{identifier, version} = args ! E_ARGS => raise(E_ARGS, "Incorrect number of arguments:  identifier, version")';
package = this:_fetch(this.archived[identifier][version]["href"]);
top = package["Configuration"]["top"];
requires = `package["Objects"][top]["Values"]["requires"]["Value"]["value"] ! E_RANGE => {}';
packages = this.cached;
`packages[identifier] ! E_RANGE' || (packages[identifier] = []);
packages[identifier][version] = ["definition" -> package, "requires" -> requires];
this.cached = packages;
return package;
return;
"$permit(\"wizard\");";
"";
"`{identifier, version} = args ! E_ARGS => raise(E_ARGS, \"Incorrect number of arguments:  identifier, version\")';";
"";
"package = this:_fetch(this.archived[identifier][version][\"href\"]);";
"";
"top = package[\"Configuration\"][\"top\"];";
"";
"requires = `package[\"Objects\"][top][\"Values\"][\"requires\"][\"Value\"][\"value\"] ! E_RANGE => {}';";
"";
"packages = this.cached;";
"";
"`packages[identifier] ! E_RANGE' || (packages[identifier] = []);";
" packages[identifier][version] = [\"definition\" -> package, \"requires\" -> requires];";
"";
"this.cached = packages;";
"";
"return package;";
"";
"chunk_length:18";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:01C2E9E16C30CD5AD646D51ED98F9427F6BCE58A";
"state:clean";
"updated_at:Sat Jan  5 17:22:53 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:37
$permit("wizard");
`{identifier, version, ?upgrade = 0} = args ! E_ARGS => raise(E_ARGS, "Incorrect number of arguments:  identifier, version, ?upgrade = 0")';
package = this:_fetch(this.archived[identifier][version]["href"]);
try
package = this:import(package);
except ex ("E_PACKAGE")
package = ex[3];
endtry
return package;
return;
"$permit(\"wizard\");";
"";
"`{identifier, version, ?upgrade = 0} = args ! E_ARGS => raise(E_ARGS, \"Incorrect number of arguments:  identifier, version, ?upgrade = 0\")';";
"";
"package = this:_fetch(this.archived[identifier][version][\"href\"]);";
"";
"try";
"  package = this:import(package);";
"except ex (\"E_PACKAGE\")";
"  package = ex[3];";
"endtry";
"";
"return package;";
"";
"chunk_length:13";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:768048A2249D537CDF385450EF126B3F8ED37ABA";
"state:clean";
"updated_at:Sat Jan  5 15:37:55 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:38
$permit("wizard");
`{identifier, version, ?upgrade = 0} = args ! E_ARGS => raise(E_ARGS, "Incorrect number of arguments:  identifier, version, ?upgrade = 0")';
package = this.cached[identifier][version]["definition"];
try
package = this:import(package);
except ex ("E_PACKAGE")
package = ex[3];
endtry
return package;
return;
"$permit(\"wizard\");";
"";
"`{identifier, version, ?upgrade = 0} = args ! E_ARGS => raise(E_ARGS, \"Incorrect number of arguments:  identifier, version, ?upgrade = 0\")';";
"";
"package = this.cached[identifier][version][\"definition\"];";
"";
"try";
"  package = this:import(package);";
"except ex (\"E_PACKAGE\")";
"  package = ex[3];";
"endtry";
"";
"return package;";
"";
"chunk_length:13";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:C4387772ACDB5AFF8A343A478627B7A4B57A5369";
"state:clean";
"updated_at:Sat Jan  5 17:04:50 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:39
$permit("wizard");
`{identifier, version, ?force = 1} = args ! E_ARGS => raise(E_ARGS, "Incorrect number of arguments:  identifier, version, ?force = 1")';
package = this:_match(identifier, version)[1];
package = this:export(package);
top = package["Configuration"]["top"];
requires = `package["Objects"][top]["Values"]["requires"]["Value"]["value"] ! E_RANGE => {}';
packages = this.cached;
`packages[identifier] ! E_RANGE' || (packages[identifier] = []);
packages[identifier][version] = ["definition" -> package, "requires" -> requires];
this.cached = packages;
return package;
return;
"$permit(\"wizard\");";
"";
"`{identifier, version, ?force = 1} = args ! E_ARGS => raise(E_ARGS, \"Incorrect number of arguments:  identifier, version, ?force = 1\")';";
"";
"package = this:_match(identifier, version)[1];";
"";
"package = this:export(package);";
"";
"top = package[\"Configuration\"][\"top\"];";
"";
"requires = `package[\"Objects\"][top][\"Values\"][\"requires\"][\"Value\"][\"value\"] ! E_RANGE => {}';";
"";
"packages = this.cached;";
"";
"`packages[identifier] ! E_RANGE' || (packages[identifier] = []);";
"packages[identifier][version] = [\"definition\" -> package, \"requires\" -> requires];";
"";
"this.cached = packages;";
"";
"return package;";
"";
"chunk_length:20";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:B78AE0CE24624889878E8E0BA80DA97EA363F0E9";
"state:clean";
"updated_at:Sat Jan  5 17:18:17 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:40
$permit("wizard");
`{pathname, ?options = []} = args ! E_ARGS => raise(E_ARGS, "Incorrect number of arguments:  pathname, ?options")';
fh = -1;
try
fh = file_open(pathname, "r-tn");
package = parse_json(file_readline(fh), "embedded-types");
finally
(fh > -1) && file_close(fh);
endtry
try
package = this:import(package);
except ex ("E_PACKAGE")
package = ex[3];
endtry
return package;
return;
"$permit(\"wizard\");";
"";
"`{pathname, ?options = []} = args ! E_ARGS => raise(E_ARGS, \"Incorrect number of arguments:  pathname, ?options\")';";
"";
"fh = -1;";
"try";
"  fh = file_open(pathname, \"r-tn\");";
"  package = parse_json(file_readline(fh), \"embedded-types\");";
"finally";
"  (fh > -1) && file_close(fh);";
"endtry";
"";
"try";
"  package = this:import(package);";
"except ex (\"E_PACKAGE\")";
"  package = ex[3];";
"endtry";
"";
"return package;";
"";
"chunk_length:19";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:A25F06C67428605F0AEC8DC2B5B84ADC6631BC35";
"state:clean";
"updated_at:Wed Jun  6 08:10:40 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:41
$permit("wizard");
`{identifier, version, pathname, ?options = []} = args ! E_ARGS => raise(E_ARGS, "Incorrect number of arguments:  identifier, version, pathname, ?options")';
package = this:_match(identifier, version)[1];
package = this:export(package, options);
fh = -1;
try
fh = file_open(pathname, "w-tn");
file_writeline(fh, generate_json(package, "embedded-types"));
finally
(fh > -1) && file_close(fh);
endtry
return package;
return;
"$permit(\"wizard\");";
"";
"`{identifier, version, pathname, ?options = []} = args ! E_ARGS => raise(E_ARGS, \"Incorrect number of arguments:  identifier, version, pathname, ?options\")';";
"";
"package = this:_match(identifier, version)[1];";
"";
"package = this:export(package, options);";
"";
"fh = -1;";
"try";
"  fh = file_open(pathname, \"w-tn\");";
"  file_writeline(fh, generate_json(package, \"embedded-types\"));";
"finally";
"  (fh > -1) && file_close(fh);";
"endtry";
"";
"return package;";
"";
"chunk_length:17";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:5FF1F9D03E4E435B1FF4ACD865F3FE8BA9895ADF";
"state:clean";
"updated_at:Wed Jun  6 08:10:40 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:42
$permit("wizard");
`{identifier, version} = args ! E_ARGS => raise(E_ARGS, "Incorrect number of arguments:  identifier, version")';
package = this.cached[identifier][version]["definition"];
json = generate_json(package, "embedded-types");
suspend(0);
while (len = length(json))
suspend(0);
len = (len > 60000) ? 60000 | len;
line = json[1..len];
json[1..len] = "";
while (buffered_output_length(player))
suspend(0);
endwhile
notify(player, line);
endwhile
return;
"$permit(\"wizard\");";
"";
"`{identifier, version} = args ! E_ARGS => raise(E_ARGS, \"Incorrect number of arguments:  identifier, version\")';";
"";
"package = this.cached[identifier][version][\"definition\"];";
"";
"json = generate_json(package, \"embedded-types\");";
"";
"suspend(0);";
"";
"while (len = length(json))";
"  suspend(0);";
"  len = len > 60000 ? 60000 | len;";
"  line = json[1..len];";
"  json[1..len] = \"\";";
"  while (buffered_output_length(player))";
"    suspend(0);";
"  endwhile";
"  notify(player, line);";
"endwhile";
"";
"chunk_length:20";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:A3D783A1BC444F7C27CA80179A894EE4D89EE423";
"state:clean";
"updated_at:Sat Jan  5 17:04:50 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:43
if (callers() && (caller_perms() != player))
raise(E_PERM);
endif
if (!player.wizard)
notify(player, "Only wizards can do that!");
return;
endif
if (r = match(dobjstr, "^ *%([_a-z0-9]+%) *%([0-9]+%.[0-9]+%.[0-9]+%)? *$"))
seconds_and_ticks = 0;
try
seconds_and_ticks = this:_set_seconds_and_ticks();
identifier = dobjstr[r[3][1][1]..r[3][1][2]];
version = dobjstr[r[3][2][1]..r[3][2][2]];
if (`this.provides_cache[identifier] ! E_RANGE' != E_RANGE)
notify(player, tostr("Package \"", identifier, "\" is already installed."));
return;
elseif ((`this.archived[identifier] ! E_RANGE' == E_RANGE) && (`this.cached[identifier] ! E_RANGE' == E_RANGE))
notify(player, tostr("Package \"", identifier, "\" doesn't exist in either the remote archive or local cache."));
return;
else
if (version)
if ((`this.archived[identifier][version] ! E_RANGE' == E_RANGE) && (`this.cached[identifier][version] ! E_RANGE' == E_RANGE))
notify(player, tostr("Version \"", version, "\" of package \"", identifier, "\" doesn't exist in either the remote archive or local cache."));
return;
endif
else
cached = `mapkeys(this.cached[identifier]) ! E_RANGE => {}';
archived = `mapkeys(this.archived[identifier]) ! E_RANGE => {}';
versions = {@cached, @archived};
versions = this:_map("_parse_version", versions);
versions = this:_sort_versions(versions);
version = versions[1];
version = tostr(version[1], ".", version[2], ".", version[3]);
endif
endif
if (`this.cached[identifier][version] ! E_RANGE' != E_RANGE)
requires = `this.cached[identifier][version]["requires"] ! E_RANGE => {}';
else
requires = `this.archived[identifier][version]["requires"] ! E_RANGE => {}';
endif
if (requires && (requires = this:_check_required_provides(requires)))
notify(player, tostr("Version \"", version, "\" of package \"", identifier, "\" couldn't be installed because it requires:"));
sep = "";
line = "  ";
for require in (requires)
{ispec, ?vspec = ""} = require;
if (vspec)
line = tostr(line, sep, ispec, " ", vspec);
else
line = tostr(line, sep, ispec);
endif
sep = ", ";
endfor
notify(player, line);
return;
endif
if (`this.cached[identifier][version] ! E_RANGE' != E_RANGE)
notify(player, tostr("Installing version \"", version, "\" of package \"", identifier, "\" from the local cache..."));
package = this:import_package_from_cache(identifier, version);
else
notify(player, tostr("Installing version \"", version, "\" of package \"", identifier, "\" from the remote archive..."));
package = this:import_package_from_archive(identifier, version);
endif
if (((t = typeof(package)) == OBJ) || (t == ANON))
this:install(package, ["follow-instructions" -> 1]);
else
notify(player, tostr("Version \"", version, "\" of package \"", identifier, "\" couldn't be installed (raw package below)."));
notify(player, toliteral(package));
return;
endif
notify(player, tostr("Version \"", version, "\" of package \"", identifier, "\" (", package.name, ") was successfully installed as ", package, "."));
finally
this:_reset_seconds_and_ticks(seconds_and_ticks);
endtry
else
notify(player, tostr("Correct usage is:  @install <package identifier> <package version> with $composed"));
notify(player, tostr("     for example:  @install foobar 1.2.3 with $composed"));
endif
return;
"if (callers() && caller_perms() != player)";
"  raise(E_PERM);";
"endif";
"if (!player.wizard)";
"  notify(player, \"Only wizards can do that!\");";
"  return;";
"endif";
"if (r = match(dobjstr, \"^ *%([_a-z0-9]+%) *%([0-9]+%.[0-9]+%.[0-9]+%)? *$\"))";
"  /* Modify the execution limits to give this (potentially)";
"   * long-running task some breathing room, and to keep things";
"   * atomic.";
"   */";
"  seconds_and_ticks = 0;";
"  try";
"    seconds_and_ticks = this:_set_seconds_and_ticks();";
"";
"    identifier = dobjstr[r[3][1][1]..r[3][1][2]];";
"    version = dobjstr[r[3][2][1]..r[3][2][2]];";
"";
"    if (`this.provides_cache[identifier] ! E_RANGE' != E_RANGE)";
"      notify(player, tostr(\"Package \\\"\", identifier, \"\\\" is already installed.\"));";
"      return;";
"    elseif (`this.archived[identifier] ! E_RANGE' == E_RANGE && `this.cached[identifier] ! E_RANGE' == E_RANGE)";
"      notify(player, tostr(\"Package \\\"\", identifier, \"\\\" doesn't exist in either the remote archive or local cache.\"));";
"      return;";
"    else";
"      if (version)";
"        if (`this.archived[identifier][version] ! E_RANGE' == E_RANGE && `this.cached[identifier][version] ! E_RANGE' == E_RANGE)";
"          notify(player, tostr(\"Version \\\"\", version, \"\\\" of package \\\"\", identifier, \"\\\" doesn't exist in either the remote archive or local cache.\"));";
"          return;";
"        endif";
"      else";
"        cached = `mapkeys(this.cached[identifier]) ! E_RANGE => {}';";
"        archived = `mapkeys(this.archived[identifier]) ! E_RANGE => {}';";
"        versions = {@cached, @archived};";
"        versions = this:_map(\"_parse_version\", versions);";
"        versions = this:_sort_versions(versions);";
"        version = versions[1];";
"        version = tostr(version[1], \".\", version[2], \".\", version[3]);";
"      endif";
"    endif";
"";
"    if (`this.cached[identifier][version] ! E_RANGE' != E_RANGE)";
"      requires = `this.cached[identifier][version][\"requires\"] ! E_RANGE => {}';";
"    else";
"      requires = `this.archived[identifier][version][\"requires\"] ! E_RANGE => {}';";
"    endif";
"";
"    if (requires && (requires = this:_check_required_provides(requires)))";
"      notify(player, tostr(\"Version \\\"\", version, \"\\\" of package \\\"\", identifier, \"\\\" couldn't be installed because it requires:\"));";
"      sep = \"\";";
"      line = \"  \";";
"      for require in (requires)";
"        {ispec, ?vspec = \"\"} = require;";
"        if (vspec)";
"          line = tostr(line, sep, ispec, \" \", vspec);";
"        else";
"          line = tostr(line, sep, ispec);";
"        endif";
"        sep = \", \";";
"      endfor";
"      notify(player, line);";
"      return;";
"    endif";
"";
"    if (`this.cached[identifier][version] ! E_RANGE' != E_RANGE)";
"      notify(player, tostr(\"Installing version \\\"\", version, \"\\\" of package \\\"\", identifier, \"\\\" from the local cache...\"));";
"      package = this:import_package_from_cache(identifier, version);";
"    else";
"      notify(player, tostr(\"Installing version \\\"\", version, \"\\\" of package \\\"\", identifier, \"\\\" from the remote archive...\"));";
"      package = this:import_package_from_archive(identifier, version);";
"    endif";
"";
"    if ((t = typeof(package)) == OBJ || t == ANON)";
"      this:install(package, [\"follow-instructions\" -> 1]);";
"";
"    else";
"      notify(player, tostr(\"Version \\\"\", version, \"\\\" of package \\\"\", identifier, \"\\\" couldn't be installed (raw package below).\"));";
"      notify(player, toliteral(package));";
"      return;";
"    endif";
"";
"    notify(player, tostr(\"Version \\\"\", version, \"\\\" of package \\\"\", identifier, \"\\\" (\", package.name, \") was successfully installed as \", package, \".\"));";
"";
"  finally";
"    this:_reset_seconds_and_ticks(seconds_and_ticks);";
"  endtry";
"";
"else";
"  notify(player, tostr(\"Correct usage is:  @install <package identifier> <package version> with $composed\"));";
"  notify(player, tostr(\"     for example:  @install foobar 1.2.3 with $composed\"));";
"endif";
"";
"chunk_length:92";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:16701627AB39FCE25ED9FB84F1C0038C1CF5714A";
"state:clean";
"updated_at:Sat May 25 10:04:27 2013 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:44
if (callers() && (caller_perms() != player))
raise(E_PERM);
endif
if (!player.wizard)
notify(player, "Only wizards can do that!");
return;
endif
if (r = match(dobjstr, "^ *%([_a-z0-9]+%) *%([0-9]+%.[0-9]+%.[0-9]+%) *$"))
identifier = dobjstr[r[3][1][1]..r[3][1][2]];
version = dobjstr[r[3][2][1]..r[3][2][2]];
if (`this.provides_cache[identifier][version] ! E_RANGE' == E_RANGE)
notify(player, tostr("Version \"", version, "\" of package \"", identifier, "\" is not installed."));
return;
endif
package = this.provides_cache[identifier][version][1];
this:delete(package, ["follow-instructions" -> 1]);
notify(player, tostr("Version \"", version, "\" of package \"", identifier, "\" was successfully uninstalled."));
else
notify(player, tostr("Correct usage is:  @uninstall <package identifier> <package version> with $composed"));
notify(player, tostr("     for example:  @uninstall foobar 1.2.3 with $composed"));
endif
return;
"if (callers() && caller_perms() != player)";
"  raise(E_PERM);";
"endif";
"if (!player.wizard)";
"  notify(player, \"Only wizards can do that!\");";
"  return;";
"endif";
"if (r = match(dobjstr, \"^ *%([_a-z0-9]+%) *%([0-9]+%.[0-9]+%.[0-9]+%) *$\"))";
"  identifier = dobjstr[r[3][1][1]..r[3][1][2]];";
"  version = dobjstr[r[3][2][1]..r[3][2][2]];";
"";
"  if (`this.provides_cache[identifier][version] ! E_RANGE' == E_RANGE)";
"    notify(player, tostr(\"Version \\\"\", version, \"\\\" of package \\\"\", identifier, \"\\\" is not installed.\"));";
"    return;";
"  endif";
"";
"  package = this.provides_cache[identifier][version][1];";
"";
"  this:delete(package, [\"follow-instructions\" -> 1]);";
"";
"  notify(player, tostr(\"Version \\\"\", version, \"\\\" of package \\\"\", identifier, \"\\\" was successfully uninstalled.\"));";
"";
"else";
"  notify(player, tostr(\"Correct usage is:  @uninstall <package identifier> <package version> with $composed\"));";
"  notify(player, tostr(\"     for example:  @uninstall foobar 1.2.3 with $composed\"));";
"endif";
"";
"chunk_length:26";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:A15B0A62082BBE4A51C8B55CAF095F8C743CBED9";
"state:clean";
"updated_at:Sat Jan  5 15:34:39 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:45
if (callers() && (caller_perms() != player))
raise(E_PERM);
endif
if (!player.wizard)
this:_notify(player, "Only wizards can do that!");
return;
endif
if (dobjstr && (dobjstr != "packages"))
this:_notify(player, "I couldn't list that.");
this:_notify(player, "Usage: ", {"code", [], verb, " packages with $composed"});
this:_notify(player, "       ", {"code", [], verb, " with $composed"});
return;
endif
this:fetch_index();
cached = this.cached;
archived = this.archived;
this:_notify(player, {"h2", [], "Installed packages"});
for _, identifier in (this.provides_cache)
for _, version in (this.provides_cache[identifier])
this:_suspend_if_necessary();
if (`version in mapkeys(cached[identifier]) ! E_RANGE' || `version in mapkeys(archived[identifier]) ! E_RANGE')
this:_notify(player, {"span", [], "   ", identifier, ", ", version, " (", objnum = this.provides_cache[identifier][version][1], ") ", objnum.name});
else
this:_notify(player, {"span", ["class" -> "information"], " ! ", identifier, ", ", version, " (", objnum = this.provides_cache[identifier][version][1], ") ", objnum.name});
endif
endfor
endfor
this:_notify(player);
this:_notify(player, {"h2", [], "Packages available from cache"});
for _, identifier in (this.cached)
this:_suspend_if_necessary();
versions = "";
for _, version in (this.cached[identifier])
versions = (versions + ", ") + version;
endfor
this:_notify(player, "   ", identifier, versions);
endfor
this:_notify(player);
this:_notify(player, {"h2", [], "Packages available from archives"});
for _, identifier in (this.archived)
this:_suspend_if_necessary();
versions = "";
for _, version in (this.archived[identifier])
versions = (versions + ", ") + version;
endfor
this:_notify(player, "   ", identifier, versions);
endfor
this:_notify(player);
this:_notify(player, "(done)");
return;
"if (callers() && caller_perms() != player)";
"  raise(E_PERM);";
"endif";
"if (!player.wizard)";
"  this:_notify(player, \"Only wizards can do that!\");";
"  return;";
"endif";
"if (dobjstr && dobjstr != \"packages\")";
"  this:_notify(player, \"I couldn't list that.\");";
"  this:_notify(player, \"Usage: \", {\"code\", [], verb, \" packages with $composed\"});";
"  this:_notify(player, \"       \", {\"code\", [], verb, \" with $composed\"});";
"  return;";
"endif";
"";
"this:fetch_index();";
"";
"cached = this.cached;";
"archived = this.archived;";
"";
"this:_notify(player, {\"h2\", [], \"Installed packages\"});";
"for _, identifier in (this.provides_cache)";
"  for _, version in (this.provides_cache[identifier])";
"    this:_suspend_if_necessary();";
"    if (`version in mapkeys(cached[identifier]) ! E_RANGE' || `version in mapkeys(archived[identifier]) ! E_RANGE')";
"      this:_notify(player, {\"span\", [], \"   \", identifier, \", \", version, \" (\", objnum = this.provides_cache[identifier][version][1], \") \", objnum.name});";
"    else";
"      this:_notify(player, {\"span\", [\"class\" -> \"information\"], \" ! \", identifier, \", \", version, \" (\", objnum = this.provides_cache[identifier][version][1], \") \", objnum.name});";
"    endif";
"  endfor";
"endfor";
"this:_notify(player);";
"";
"this:_notify(player, {\"h2\", [], \"Packages available from cache\"});";
"for _, identifier in (this.cached)";
"  this:_suspend_if_necessary();";
"  versions = \"\";";
"  for _, version in (this.cached[identifier])";
"    versions = versions + \", \" + version;";
"  endfor";
"  this:_notify(player, \"   \", identifier, versions);";
"endfor";
"this:_notify(player);";
"";
"this:_notify(player, {\"h2\", [], \"Packages available from archives\"});";
"for _, identifier in (this.archived)";
"  this:_suspend_if_necessary();";
"  versions = \"\";";
"  for _, version in (this.archived[identifier])";
"    versions = versions + \", \" + version;";
"  endfor";
"  this:_notify(player, \"   \", identifier, versions);";
"endfor";
"this:_notify(player);";
"";
"this:_notify(player, \"(done)\");";
"";
"chunk_length:55";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:0718F0EF44EE634A7F6E6C50255C0C8E82619E82";
"state:clean";
"updated_at:Sat Apr 13 09:08:14 2013 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:46
$private();
{identifier, version, package} = args;
manifest = `package.manifest ! E_PROPNF => {}';
instructions = `package.instructions ! E_PROPNF => {}';
if ("install-dictionary" in instructions)
for item in (manifest)
{object, label} = item;
if ("dictionary" == label)
notify(player, tostr("Adding package dictionary (", object.name, ") to parents of $system..."));
parents = {@parents($system), object};
chparents($system, parents);
break;
endif
endfor
endif
if ("install-namespace" in instructions)
for item in (manifest)
{object, label} = item;
if ("dictionary" == label)
notify(player, tostr("Adding namespace (", identifier, ") as a property on $system..."));
add_property($system, identifier, object, {package, "r"});
break;
endif
endfor
endif
for instruction in (instructions)
if ((typeof(`$sysobj ! ANY') == OBJ) && (r = match(instruction, "^install-%([_a-z0-9]+%)-on-legacy-core$")))
property = instruction[r[3][1][1]..r[3][1][2]];
for item in (manifest)
{object, label} = item;
if (property == label)
notify(player, tostr("Adding property (", label, ") to $sysobj..."));
add_property($sysobj, label, object, {package, "r"});
endif
endfor
endif
endfor
return;
"$private();";
"";
"{identifier, version, package} = args;";
"";
"manifest = `package.manifest ! E_PROPNF => {}';";
"instructions = `package.instructions ! E_PROPNF => {}';";
"if (\"install-dictionary\" in instructions)";
"  for item in (manifest)";
"    {object, label} = item;";
"    if (\"dictionary\" == label)";
"      notify(player, tostr(\"Adding package dictionary (\", object.name, \") to parents of $system...\"));";
"      parents = {@parents($system), object};";
"      chparents($system, parents);";
"      break;";
"    endif";
"  endfor";
"endif";
"if (\"install-namespace\" in instructions)";
"  for item in (manifest)";
"    {object, label} = item;";
"    if (\"dictionary\" == label)";
"      notify(player, tostr(\"Adding namespace (\", identifier, \") as a property on $system...\"));";
"      add_property($system, identifier, object, {package, \"r\"});";
"      break;";
"    endif";
"  endfor";
"endif";
"for instruction in (instructions)";
"  if (typeof(`$sysobj ! ANY') == OBJ && (r = match(instruction, \"^install-%([_a-z0-9]+%)-on-legacy-core$\")))";
"    property = instruction[r[3][1][1]..r[3][1][2]];";
"    for item in (manifest)";
"      {object, label} = item;";
"      if (property == label)";
"        notify(player, tostr(\"Adding property (\", label, \") to $sysobj...\"));";
"        add_property($sysobj, label, object, {package, \"r\"});";
"      endif";
"    endfor";
"  endif";
"endfor";
"";
"chunk_length:39";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:2CB1F7A334A9700390CBAC2EE32FCE6189E284DC";
"state:clean";
"updated_at:Thu May 31 20:37:09 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:47
$private();
{identifier, version, package} = args;
manifest = `package.manifest ! E_PROPNF => {}';
instructions = `package.instructions ! E_PROPNF => {}';
if ("install-dictionary" in instructions)
for item in (manifest)
{object, label} = item;
if (("dictionary" == label) && (object in parents($system)))
notify(player, tostr("Removing package dictionary (", object.name, ") from parents of $system..."));
parents = setremove(parents($system), object);
chparents($system, parents);
break;
endif
endfor
endif
if ("install-namespace" in instructions)
for item in (manifest)
{object, label} = item;
if (("dictionary" == label) && (identifier in properties($system)))
notify(player, tostr("Removing namespace (", identifier, ") as a property on $system..."));
delete_property($system, identifier);
break;
endif
endfor
endif
for instruction in (instructions)
if ((typeof(`$sysobj ! ANY') == OBJ) && (r = match(instruction, "^install-%([_a-z0-9]+%)-on-legacy-core$")))
property = instruction[r[3][1][1]..r[3][1][2]];
for item in (manifest)
{object, label} = item;
if ((property == label) && (property in properties($sysobj)))
notify(player, tostr("Removing property (", label, ") from $sysobj..."));
delete_property($sysobj, label);
endif
endfor
endif
endfor
return;
"$private();";
"";
"{identifier, version, package} = args;";
"";
"manifest = `package.manifest ! E_PROPNF => {}';";
"instructions = `package.instructions ! E_PROPNF => {}';";
"if (\"install-dictionary\" in instructions)";
"  for item in (manifest)";
"    {object, label} = item;";
"    if (\"dictionary\" == label && object in parents($system))";
"      notify(player, tostr(\"Removing package dictionary (\", object.name, \") from parents of $system...\"));";
"      parents = setremove(parents($system), object);";
"      chparents($system, parents);";
"      break;";
"    endif";
"  endfor";
"endif";
"if (\"install-namespace\" in instructions)";
"  for item in (manifest)";
"    {object, label} = item;";
"    if (\"dictionary\" == label && identifier in properties($system))";
"      notify(player, tostr(\"Removing namespace (\", identifier, \") as a property on $system...\"));";
"      delete_property($system, identifier);";
"      break;";
"    endif";
"  endfor";
"endif";
"for instruction in (instructions)";
"  if (typeof(`$sysobj ! ANY') == OBJ && (r = match(instruction, \"^install-%([_a-z0-9]+%)-on-legacy-core$\")))";
"    property = instruction[r[3][1][1]..r[3][1][2]];";
"    for item in (manifest)";
"      {object, label} = item;";
"      if (property == label && property in properties($sysobj))";
"        notify(player, tostr(\"Removing property (\", label, \") from $sysobj...\"));";
"        delete_property($sysobj, label);";
"      endif";
"    endfor";
"  endif";
"endfor";
"";
"chunk_length:39";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:8DF7C5499DB29B394C664EC5978F5EE705A8E030";
"state:clean";
"updated_at:Thu May 31 20:26:10 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#10:0
{message} = args;
$permit("owner", "wizard");
add_property(this, tostr(time()), message, {this.owner, "r"});
return;
"{message} = args;";
"";
"$permit(\"owner\", \"wizard\");";
"";
"add_property(this, tostr(time()), message, {this.owner, \"r\"});";
"";
"chunk_length:5";
"chunk_type:source";
"content_type:application/x-moocode";
"updated_at:Tue Oct 25 06:17:39 2011 EDT";
"-=-=-mxyzptlk-=-=-";
.
#12:0
if (`args[$][1] ! E_TYPE, E_RANGE' == ";")
args[$] = tostr("return ", args[$][2..$], ";");
endif
return {$lambda_proto, @args};
return;
"if (`args[$][1] ! E_TYPE, E_RANGE' == \";\")";
"  args[$] = tostr(\"return \", args[$][2..$], \";\");";
"endif";
"return {$lambda_proto, @args};";
"";
"chunk_length:4";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:0B180E96359BE26F6C6657852781421033A84241";
"-=-=-mxyzptlk-=-=-";
.
#14:0
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
return;
"(ticks_left() < 10000 || seconds_left() < 2) && suspend(0);";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:C7B9AA9D4FFB81B732A30FE8DFCCB25794BD2172";
"-=-=-mxyzptlk-=-=-";
.
#14:1
return ((((((verb == "is_int") && (typeof(this) == INT)) || ((verb == "is_float") && (typeof(this) == FLOAT))) || ((verb == "is_str") && (typeof(this) == STR))) || ((verb == "is_err") && (typeof(this) == ERR))) || ((verb == "is_list") && (typeof(this) == LIST))) || ((verb == "is_map") && (typeof(this) == MAP));
return;
"return";
"  (verb == \"is_int\" && typeof(this) == INT) ||";
"  (verb == \"is_float\" && typeof(this) == FLOAT) ||";
"  (verb == \"is_str\" && typeof(this) == STR) ||";
"  (verb == \"is_err\" && typeof(this) == ERR) ||";
"  (verb == \"is_list\" && typeof(this) == LIST) ||";
"  (verb == \"is_map\" && typeof(this) == MAP);";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:0B4DFFF5225BCB55E020B0D107AA249BB77B322E";
"-=-=-mxyzptlk-=-=-";
.
#14:2
{?old_school = 0} = args;
return (!old_school) ? ([0 -> $int_proto, 2 -> $str_proto, 3 -> $err_proto, 4 -> $list_proto, 10 -> $map_proto, 9 -> $float_proto])[typeof(this)] | typeof(this);
return;
"{?old_school = 0} = args;";
"return !old_school ? [0 -> $int_proto, 2 -> $str_proto, 3 -> $err_proto, 4 -> $list_proto, 10 -> $map_proto, 9 -> $float_proto][typeof(this)] | typeof(this);";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:067CFEF398A09967430E7285E89A27E09EE31E99";
"-=-=-mxyzptlk-=-=-";
.
#14:3
return generate_json(this, @args);
return;
"return generate_json(this, @args);";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:D9BCBC16608002F4DBDD530226BA55CD075E90A0";
"-=-=-mxyzptlk-=-=-";
.
#15:0
return abs(this);
return;
"return abs(this);";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:BA3950CF359CA8E59B1D31D1847CCB147F031551";
"-=-=-mxyzptlk-=-=-";
.
#16:0
set_task_perms(caller_perms());
{limit, @args} = args;
if (limit < this)
return this;
endif
lambda = args:_lambdafy();
while (limit >= this)
this:_suspend_if_necessary();
args && lambda:call(this);
this = this + 1;
endwhile
return this - 1;
return;
"set_task_perms(caller_perms());";
"";
"{limit, @args} = args;";
"";
"if (limit < this)";
"  return this;";
"endif";
"";
"lambda = args:_lambdafy();";
"";
"while (limit >= this)";
"  this:_suspend_if_necessary();";
"  args && lambda:call(this);";
"  this = this + 1;";
"endwhile";
"";
"return this - 1;";
"";
"chunk_length:17";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:3B57112B9C4DC27E648D2A04836553A174760726";
"-=-=-mxyzptlk-=-=-";
.
#16:1
set_task_perms(caller_perms());
{limit, @args} = args;
if (limit > this)
return this;
endif
lambda = args:_lambdafy();
while (limit <= this)
this:_suspend_if_necessary();
args && lambda:call(this);
this = this - 1;
endwhile
return this + 1;
return;
"set_task_perms(caller_perms());";
"";
"{limit, @args} = args;";
"";
"if (limit > this)";
"  return this;";
"endif";
"";
"lambda = args:_lambdafy();";
"";
"while (limit <= this)";
"  this:_suspend_if_necessary();";
"  args && lambda:call(this);";
"  this = this - 1;";
"endwhile";
"";
"return this + 1;";
"";
"chunk_length:17";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:9597CAE84B6371AAC5AE3D90B93B801DE451B99D";
"-=-=-mxyzptlk-=-=-";
.
#16:2
return !(this % 2);
return;
"return !(this % 2);";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:0283EBF523DD6CEB71F5A3620DB943F557D03239";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"INT\"],\" \",[\"var\",\"int\"],\":\",[\"strong\",\"is_even\"],\"()\"]]";
"[\"p\",\"Returns true if \",[\"var\",\"int\"],\" is an even integer.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"1:is_even()      => 0\"],[\"code\",{\"class\":\"language-moocode\"},\"2:is_even()      => 1\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:3A77D0C25E39A8BF23C723D96D65B7224F14CBB9";
"-=-=-mxyzptlk-=-=-";
.
#16:3
return !(!(this % 2));
return;
"return !!(this % 2);";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:852665595ADC220922DA8097C1A0ABA9B9284F25";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"INT\"],\" \",[\"var\",\"int\"],\":\",[\"strong\",\"is_odd\"],\"()\"]]";
"[\"p\",\"Returns true if \",[\"var\",\"int\"],\" is an odd integer.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"1:is_odd()       => 1\"],[\"code\",{\"class\":\"language-moocode\"},\"2:is_odd()       => 0\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:F2782EF41FFE0D757CA232F635E9188EBF7D4E91";
"-=-=-mxyzptlk-=-=-";
.
#16:4
a = this;
{b} = args;
this:_suspend_if_necessary();
if (b)
return abs(b:gcd(a % b));
else
return abs(a);
endif
return;
"a = this;";
"{b} = args;";
"";
"this:_suspend_if_necessary();";
"";
"if (b)";
"  return abs(b:gcd(a % b));";
"else";
"  return abs(a);";
"endif";
"";
"chunk_length:10";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:D137BA35692DEB38813DECD7CD520E7F013CA370";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"INT\"],\" \",[\"var\",\"int\"],\":\",[\"strong\",\"gcd\"],\"(\",[\"var\",\"INT other\"],\")\"]]";
"[\"p\",\"Calculates the greatest common divisor of \",[\"var\",\"int\"],\" and \",[\"var\",\"other\"],\".\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"54:gcd(24)      => 6\"],[\"code\",{\"class\":\"language-moocode\"},\"68:gcd(32)      => 4\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:4203FE7D05F3E3402FDD538783AF7A32105A91B0";
"-=-=-mxyzptlk-=-=-";
.
#16:5
a = this;
{b} = args;
return abs((a * b) / a:gcd(b));
return;
"a = this;";
"{b} = args;";
"";
"return abs((a * b) / a:gcd(b));";
"";
"chunk_length:4";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:BE32B29811C44B853DDFDD829B03FEC817433868";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"INT\"],\" \",[\"var\",\"int\"],\":\",[\"strong\",\"lcm\"],\"(\",[\"var\",\"INT other\"],\")\"]]";
"[\"p\",\"Calculates the least common multiple of \",[\"var\",\"int\"],\" and \",[\"var\",\"other\"],\".\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"12:lcm(26)      => 156\"],[\"code\",{\"class\":\"language-moocode\"},\"68:lcm(32)      => 544\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:374CC10EBE4B0E66BF4FB50A9859976BEAC49019";
"-=-=-mxyzptlk-=-=-";
.
#16:6
if (this <= 1)
return 0;
else
i = 2;
while ((i * i) <= this)
if ((this % i) == 0)
return 0;
endif
i = i + 1;
endwhile
return 1;
endif
return;
"if (this <= 1)";
"  return 0;";
"else";
"  i = 2;";
"  while (i * i <= this)";
"    if (this % i == 0)";
"      return 0;";
"    endif";
"    i = i + 1;";
"  endwhile";
"  return 1;";
"endif";
"";
"chunk_length:12";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:B914F5972A79C399106C9BFA5F6B46F6F4732004";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"INT\"],\" \",[\"var\",\"int\"],\":\",[\"strong\",\"is_prime\"],\"()\"]]";
"[\"p\",\"Returns true if \",[\"var\",\"int\"],\" is a prime number.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"2203:is_prime()      => 1\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:78571573B0931B7EEC3BFADEDBB541234221267E";
"-=-=-mxyzptlk-=-=-";
.
#16:7
{?base = 10} = args;
if (base == 10)
return tostr(this);
elseif ((base > 1) && (base < 17))
chars = "0123456789ABCDEF";
result = "";
while (this >= base)
rem = this % base;
this = this / base;
result = chars[rem + 1] + result;
endwhile
result = chars[this + 1] + result;
return result;
else
raise(E_INVARG, tostr("Invalid base: ", base), base);
endif
return;
"{?base = 10} = args;";
"";
"if (base == 10)";
"  return tostr(this);";
"elseif (base > 1 && base < 17)";
"  chars = \"0123456789ABCDEF\";";
"  result = \"\";";
"  while (this >= base)";
"    rem = this % base;";
"    this = this / base;";
"    result = chars[rem + 1] + result;";
"  endwhile";
"  result = chars[this + 1] + result;";
"  return result;";
"else";
"  raise(E_INVARG, tostr(\"Invalid base: \", base), base);";
"endif";
"";
"chunk_length:17";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:532709E5CA7B9DAB667B3E521B6F53AC2449DABE";
"-=-=-mxyzptlk-=-=-";
"[\"pre.usage\",[\"code.language-moocode\",[\"em\",\"STR\"],\" \",[\"var\",\"int\"],\":\",[\"strong\",\"tostr\"],\"([\",[\"var\",\"INT base\"],\"])\"]]";
"[\"p\",\"Returns the string representation of \",[\"var\",\"int\"],\" in the specified \",[\"var\",\"base\"],\". If \",[\"var\",\"base\"],\" is not specified, it defaults to \",[\"em\",\"10\"],\". The \",[\"var\",\"base\"],\" must be between 2 and 16, inclusive.\"]";
"[\"pre.example\",[\"code.language-moocode\",\"44:tostr()      => \\\"44\\\"\"],[\"code.language-moocode\",\"44:tostr(10)    => \\\"44\\\"\"],[\"code.language-moocode\",\"44:tostr(2)     => \\\"101100\\\"\"],[\"code.language-moocode\",\"44:tostr(16)    => \\\"2C\\\"\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:EF6D295EFA6B7F97C784A484738446578986AE2C";
"-=-=-mxyzptlk-=-=-";
.
#16:8
if ((this > 31) && (this < 127))
return encode_binary({this})[1];
else
raise(E_INVARG, tostr("Invalid index: ", this), this);
endif
return;
"if (this > 31 && this < 127)";
"  return encode_binary({this})[1];";
"else";
"  raise(E_INVARG, tostr(\"Invalid index: \", this), this);";
"endif";
"";
"chunk_length:5";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:1BAF5328E286ACB6604B604ACF3A7DB04B2D5568";
"-=-=-mxyzptlk-=-=-";
"[\"pre.usage\",[\"code.language-moocode\",[\"em\",\"STR\"],\" \",[\"var\",\"index\"],\":\",[\"strong\",\"chr\"],\"()\"]]";
"[\"p\",\"Returns the character at \",[\"em\",\"index\"],\" in the MOO subset of the ASCII character set (the printable characters). If \",[\"em\",\"index\"],\" is outside that set, the verb raises \",[\"var\",\"E_INVARG\"],\".\"]";
"[\"pre.example\",[\"code.language-moocode\",\"44:chr()    => \\\",\\\"\"],[\"code.language-moocode\",\"94:chr()    => \\\"^\\\"\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:60CFDA3416F03B04B1BFC5C4224A8EE9351178B8";
"-=-=-mxyzptlk-=-=-";
.
#18:0
args && raise(E_ARGS);
if (`this[1][1] ! E_TYPE, E_RANGE' == $lambda_proto)
return this[1];
elseif ((t = typeof(this)) == LIST)
return ((length(this) == 1) && (typeof(this[1]) == LIST)) ? $lambda(@this[1]) | $lambda(@this);
elseif (t == STR)
return $lambda(this);
else
raise(E_INVIND);
endif
return;
"args && raise(E_ARGS);";
"";
"if (`this[1][1] ! E_TYPE, E_RANGE' == $lambda_proto)";
"  return this[1];";
"";
"elseif ((t = typeof(this)) == LIST)";
"  return length(this) == 1 && typeof(this[1]) == LIST ? $lambda(@this[1]) | $lambda(@this);";
"";
"elseif (t == STR)";
"  return $lambda(this);";
"";
"else";
"  raise(E_INVIND);";
"";
"endif";
"";
"chunk_length:15";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:208CE21BC32D54C1950EF2D15004A5CF22046682";
"-=-=-mxyzptlk-=-=-";
.
#18:1
set_task_perms(caller_perms());
lambda = args:_lambdafy();
if ((((t = typeof(this)) == MAP) || (t == LIST)) || (t == STR))
for v, k in (this)
this:_suspend_if_necessary();
lambda:call(v, k, this);
endfor
else
raise(E_INVIND);
endif
return this;
return;
"set_task_perms(caller_perms());";
"";
"lambda = args:_lambdafy();";
"";
"if ((t = typeof(this)) == MAP || t == LIST || t == STR)";
"  for v, k in (this)";
"    this:_suspend_if_necessary();";
"    lambda:call(v, k, this);";
"  endfor";
"else";
"  raise(E_INVIND);";
"endif";
"";
"return this;";
"";
"chunk_length:14";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:D5C5A1294FA2C25DF4035A85EE57294E5625BB3D";
"-=-=-mxyzptlk-=-=-";
.
#18:2
set_task_perms(caller_perms());
lambda = args:_lambdafy();
if ((t = typeof(this)) == MAP)
result = [];
for v, k in (this)
this:_suspend_if_necessary();
result[k] = lambda:call(v, k, this);
endfor
elseif (t == LIST)
result = {};
for v, i in (this)
this:_suspend_if_necessary();
result = {@result, lambda:call(v, i, this)};
endfor
elseif (t == STR)
result = "";
for v, i in (this)
this:_suspend_if_necessary();
result = tostr(result, lambda:call(v, i, this));
endfor
else
raise(E_INVIND);
endif
return result;
return;
"set_task_perms(caller_perms());";
"";
"lambda = args:_lambdafy();";
"";
"if ((t = typeof(this)) == MAP)";
"  result = [];";
"  for v, k in (this)";
"    this:_suspend_if_necessary();";
"    result[k] = lambda:call(v, k, this);";
"  endfor";
"elseif (t == LIST)";
"  result = {};";
"  for v, i in (this)";
"    this:_suspend_if_necessary();";
"    result = {@result, lambda:call(v, i, this)};";
"  endfor";
"elseif (t == STR)";
"  result = \"\";";
"  for v, i in (this)";
"    this:_suspend_if_necessary();";
"    result = tostr(result, lambda:call(v, i, this));";
"  endfor";
"else";
"  raise(E_INVIND);";
"endif";
"";
"return result;";
"";
"chunk_length:27";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:6A182A88549B599A020E61B8D363453F653125F0";
"-=-=-mxyzptlk-=-=-";
.
#18:3
set_task_perms(caller_perms());
{initial, @args} = args;
lambda = args:_lambdafy();
if ((((t = typeof(this)) == MAP) || (t == LIST)) || (t == STR))
for v, k in (this)
this:_suspend_if_necessary();
initial = lambda:call(initial, v, k, this);
endfor
else
raise(E_INVIND);
endif
return initial;
return;
"set_task_perms(caller_perms());";
"";
"{initial, @args} = args;";
"";
"lambda = args:_lambdafy();";
"";
"if ((t = typeof(this)) == MAP || t == LIST || t == STR)";
"  for v, k in (this)";
"    this:_suspend_if_necessary();";
"    initial = lambda:call(initial, v, k, this);";
"  endfor";
"else";
"  raise(E_INVIND);";
"endif";
"";
"return initial;";
"";
"chunk_length:16";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:00B451193757129619DE758EB6865222F1113856";
"-=-=-mxyzptlk-=-=-";
.
#18:4
set_task_perms(caller_perms());
lambda = args:_lambdafy();
if ((t = typeof(this)) == MAP)
for v, k in (this)
this:_suspend_if_necessary();
if (lambda:call(v, k, this))
return [k -> v];
endif
endfor
elseif (t == LIST)
for v, i in (this)
this:_suspend_if_necessary();
if (lambda:call(v, i, this))
return v;
endif
endfor
elseif (t == STR)
for v, i in (this)
this:_suspend_if_necessary();
if (lambda:call(v, i, this))
return v;
endif
endfor
else
raise(E_INVIND);
endif
return E_RANGE;
return;
"set_task_perms(caller_perms());";
"";
"lambda = args:_lambdafy();";
"";
"if ((t = typeof(this)) == MAP)";
"  for v, k in (this)";
"    this:_suspend_if_necessary();";
"    if (lambda:call(v, k, this))";
"      return [k -> v];";
"    endif";
"  endfor";
"elseif (t == LIST)";
"  for v, i in (this)";
"    this:_suspend_if_necessary();";
"    if (lambda:call(v, i, this))";
"      return v;";
"    endif";
"  endfor";
"elseif (t == STR)";
"  for v, i in (this)";
"    this:_suspend_if_necessary();";
"    if (lambda:call(v, i, this))";
"      return v;";
"    endif";
"  endfor";
"else";
"  raise(E_INVIND);";
"endif";
"";
"return E_RANGE;";
"";
"chunk_length:30";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:9B54C30F1C5AECD5AAE7E504FE961F3E1AA5C8B6";
"-=-=-mxyzptlk-=-=-";
.
#18:5
set_task_perms(caller_perms());
lambda = args:_lambdafy();
if ((t = typeof(this)) == MAP)
result = [];
for v, k in (this)
this:_suspend_if_necessary();
if (lambda:call(v, k, this))
result[k] = v;
endif
endfor
elseif (t == LIST)
result = {};
for v, i in (this)
this:_suspend_if_necessary();
if (lambda:call(v, i, this))
result = {@result, v};
endif
endfor
elseif (t == STR)
result = "";
for v, i in (this)
this:_suspend_if_necessary();
if (lambda:call(v, i, this))
result = tostr(result, v);
endif
endfor
else
raise(E_INVIND);
endif
return result;
return;
"set_task_perms(caller_perms());";
"";
"lambda = args:_lambdafy();";
"";
"if ((t = typeof(this)) == MAP)";
"  result = [];";
"  for v, k in (this)";
"    this:_suspend_if_necessary();";
"    if (lambda:call(v, k, this))";
"      result[k] = v;";
"    endif";
"  endfor";
"elseif (t == LIST)";
"  result = {};";
"  for v, i in (this)";
"    this:_suspend_if_necessary();";
"    if (lambda:call(v, i, this))";
"      result = {@result, v};";
"    endif";
"  endfor";
"elseif (t == STR)";
"  result = \"\";";
"  for v, i in (this)";
"    this:_suspend_if_necessary();";
"    if (lambda:call(v, i, this))";
"      result = tostr(result, v);";
"    endif";
"  endfor";
"else";
"  raise(E_INVIND);";
"endif";
"";
"return result;";
"";
"chunk_length:33";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:2C699D18C9ECC48F84D6F35A40FC4BFBE19E76C6";
"-=-=-mxyzptlk-=-=-";
.
#18:6
set_task_perms(caller_perms());
lambda = args:_lambdafy();
if ((t = typeof(this)) == MAP)
result = [];
for v, k in (this)
this:_suspend_if_necessary();
if (!lambda:call(v, k, this))
result[k] = v;
endif
endfor
elseif (t == LIST)
result = {};
for v, i in (this)
this:_suspend_if_necessary();
if (!lambda:call(v, i, this))
result = {@result, v};
endif
endfor
elseif (t == STR)
result = "";
for v, i in (this)
this:_suspend_if_necessary();
if (!lambda:call(v, i, this))
result = tostr(result, v);
endif
endfor
else
raise(E_INVIND);
endif
return result;
return;
"set_task_perms(caller_perms());";
"";
"lambda = args:_lambdafy();";
"";
"if ((t = typeof(this)) == MAP)";
"  result = [];";
"  for v, k in (this)";
"    this:_suspend_if_necessary();";
"    if (!lambda:call(v, k, this))";
"      result[k] = v;";
"    endif";
"  endfor";
"elseif (t == LIST)";
"  result = {};";
"  for v, i in (this)";
"    this:_suspend_if_necessary();";
"    if (!lambda:call(v, i, this))";
"      result = {@result, v};";
"    endif";
"  endfor";
"elseif (t == STR)";
"  result = \"\";";
"  for v, i in (this)";
"    this:_suspend_if_necessary();";
"    if (!lambda:call(v, i, this))";
"      result = tostr(result, v);";
"    endif";
"  endfor";
"else";
"  raise(E_INVIND);";
"endif";
"";
"return result;";
"";
"chunk_length:33";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:4CBB74CF7ADB7925F095CDB7017AD2D763FCBBBF";
"-=-=-mxyzptlk-=-=-";
.
#18:7
set_task_perms(caller_perms());
lambda = args:_lambdafy();
if ((((t = typeof(this)) == MAP) || (t == LIST)) || (t == STR))
for v, k in (this)
this:_suspend_if_necessary();
if (!lambda:call(v, k, this))
return 0;
endif
endfor
else
raise(E_INVIND);
endif
return 1;
return;
"set_task_perms(caller_perms());";
"";
"lambda = args:_lambdafy();";
"";
"if ((t = typeof(this)) == MAP || t == LIST || t == STR)";
"  for v, k in (this)";
"    this:_suspend_if_necessary();";
"    if (!lambda:call(v, k, this))";
"      return 0;";
"    endif";
"  endfor";
"else";
"  raise(E_INVIND);";
"endif";
"";
"return 1;";
"";
"chunk_length:16";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:E50637F2A7A735C039AAEC67663C8D5A8D6A6D5E";
"-=-=-mxyzptlk-=-=-";
.
#18:8
set_task_perms(caller_perms());
lambda = args:_lambdafy();
if ((((t = typeof(this)) == MAP) || (t == LIST)) || (t == STR))
for v, k in (this)
this:_suspend_if_necessary();
if (lambda:call(v, k, this))
return 1;
endif
endfor
else
raise(E_INVIND);
endif
return 0;
return;
"set_task_perms(caller_perms());";
"";
"lambda = args:_lambdafy();";
"";
"if ((t = typeof(this)) == MAP || t == LIST || t == STR)";
"  for v, k in (this)";
"    this:_suspend_if_necessary();";
"    if (lambda:call(v, k, this))";
"      return 1;";
"    endif";
"  endfor";
"else";
"  raise(E_INVIND);";
"endif";
"";
"return 0;";
"";
"chunk_length:16";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:B3B0A17C2B7F9E452F81810DD8379F97C9E44324";
"-=-=-mxyzptlk-=-=-";
.
#18:9
return length(this);
return;
"return length(this);";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:3BB4313C64CA72A108761536D323394348A38A34";
"-=-=-mxyzptlk-=-=-";
.
#19:0
return this:_lambdafy();
return;
"return this:_lambdafy();";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:959EB05A85FBF2BC337FC649BA3AC422156EFF93";
"-=-=-mxyzptlk-=-=-";
.
#19:1
set_task_perms(caller_perms());
return this:_lambdafy():call(@args);
return;
"set_task_perms(caller_perms());";
"";
"return this:_lambdafy():call(@args);";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:3723F4F2B0BD8DA95790F583FDBFBBFC4E7A778E";
"-=-=-mxyzptlk-=-=-";
.
#19:2
return call_function(verb, this, @args);
return;
"return call_function(verb, this, @args);";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:1847674C287E387BE51DA2F0E670E76BF5069349";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"INT\"],\" \",[\"var\",\"str1\"],\":\",[\"strong\",\"index\"],\"(\",[\"var\",\"STR str2\"],\" [, \",[\"var\",\"ANY case_matters\"],\"])\"],[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"INT\"],\" \",[\"var\",\"str1\"],\":\",[\"strong\",\"rindex\"],\"(\",[\"var\",\"STR str2\"],\" [, \",[\"var\",\"ANY case_matters\"],\"])\"]]";
"[\"p\",\"Returns the index of the first character of the first/last occurrence of \",[\"var\",\"str2\"],\" in \",[\"var\",\"str1\"],\", or zero if \",[\"var\",\"str2\"],\" does not occur in \",[\"var\",\"str1\"],\" at all. \",\"By default the search for an occurrence of \",[\"var\",\"str2\"],\" is done while ignoring upper/lower-case distinctions. If \",[\"var\",\"case_matters\"],\" is provided and true, then case is treated as significant in all comparisons.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"\\\"foobar\\\":index(\\\"o\\\")        => 2\"],[\"code\",{\"class\":\"language-moocode\"},\"\\\"foobar\\\":rindex(\\\"o\\\")       => 3\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:E0C419489A96265FDD66A76CFABBE3C390C62B1E";
"-=-=-mxyzptlk-=-=-";
.
#19:3
result = call_function(verb, this, @args);
return result ? {@result, @args} | {};
return;
"result = call_function(verb, this, @args);";
"return result ? {@result, @args} | {};";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:FCAD1F12A022DB5977840517AF57F9899CF9EAA0";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"LIST\"],\" \",[\"var\",\"subject\"],\":\",[\"strong\",\"match\"],\"(\",[\"var\",\"STR pattern\"],\" [, \",[\"var\",\"ANY case_matters\"],\"])\"],[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"LIST\"],\" \",[\"var\",\"subject\"],\":\",[\"strong\",\"rmatch\"],\"(\",[\"var\",\"STR pattern\"],\" [, \",[\"var\",\"ANY case_matters\"],\"])\"]]";
"[\"p\",\"Searches for the first/last occurrence of the regular expression \",[\"var\",\"pattern\"],\" in the string \",[\"var\",\"subject\"],\". Returns a list containing information about the match, or the empty list if no match is found. \",\"By default, the search ignores upper/lower-case distinctions. If \",[\"var\",\"case_matters\"],\" is provided and true, then case is treated as significant in all comparisons.\"]";
"[\"p\",\"The list that \",[\"strong\",\"match()\"],\"/\",[\"strong\",\"rmatch()\"],\" returns contains the details about the match made. The list is in the form:\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"{start, end, replacements, subject, pattern}\"]]";
"[\"p\",\"Examples:\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"\\\"foo\\\":match(\\\"^f*o$\\\")        => {}\"],[\"code\",{\"class\":\"language-moocode\"},\"\\\"foo\\\":match(\\\"^fo*$\\\")        => {1, 3, {{0, -1}, ...}, \\\"foo\\\", \\\"^fo*$\\\"}\"],[\"code\",{\"class\":\"language-moocode\"},\"\\\"foobar\\\":match(\\\"o*b\\\")       => {2, 4, {{0, -1}, ...}, \\\"foobar\\\", \\\"o*b\\\"}\"],[\"code\",{\"class\":\"language-moocode\"},\"\\\"foobar\\\":rmatch(\\\"o*b\\\")      => {4, 4, {{0, -1}, ...}, \\\"foobar\\\", \\\"o*b\\\"}\"]]";
"";
"chunk_length:6";
"chunk_type:documentation";
"content_type:application/json";
"sha1:5471E8387B49148C2B00FD41B1907FC26FCDDE0B";
"-=-=-mxyzptlk-=-=-";
.
#19:4
{?sep = " "} = args;
parts = {};
if ((l = length(sep)) > 0)
this = this + sep;
while (this)
this:_suspend_if_necessary();
if ((i = index(this, sep)) > 1)
parts = {@parts, this[1..i - 1]};
endif
this = this[i + l..$];
endwhile
else
for c in (this)
parts = {@parts, c};
endfor
endif
return parts;
return;
"{?sep = \" \"} = args;";
"";
"parts = {};";
"";
"if ((l = length(sep)) > 0)";
"  this = this + sep;";
"  while (this)";
"    this:_suspend_if_necessary();";
"    if ((i = index(this, sep)) > 1)";
"      parts = {@parts, this[1..i - 1]};";
"    endif";
"    this = this[i + l..$];";
"  endwhile";
"else";
"  for c in (this)";
"    parts = {@parts, c};";
"  endfor";
"endif";
"";
"return parts;";
"";
"chunk_length:20";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:DB37D8B9C9A0D84DB5613E1E66D8D5804DA71F73";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"LIST\"],\" \",[\"var\",\"string\"],\":\",[\"strong\",\"split\"],\"([\",[\"var\",\"STR delimiter\"],\"])\"]]";
"[\"p\",\"Splits the string into a list of substrings based on the supplied delimiter. If \",[\"var\",\"delimiter\"],\" is not specified it defaults to a space.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"\\\"one two three\\\":split()        => {\\\"one\\\", \\\"two\\\", \\\"three\\\"}\"],[\"code\",{\"class\":\"language-moocode\"},\"\\\"123-456-7890\\\":split(\\\"-\\\")      => {\\\"123\\\", \\\"456\\\", \\\"7890\\\"}\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:0AB55A1B07A02A193D74697125E1240BA791C3AC";
"-=-=-mxyzptlk-=-=-";
.
#19:5
{?pattern = " "} = args;
if ((verb == "trim") || (verb == "triml"))
if ((this && pattern) && (r = match(this, tostr("^%(", pattern, "%)*"))))
this = this[r[2] + 1..$];
endif
endif
if ((verb == "trim") || (verb == "trimr"))
if ((this && pattern) && (r = match(this, tostr("%(", pattern, "%)*$"))))
this = this[1..r[1] - 1];
endif
endif
return this;
return;
"{?pattern = \" \"} = args;";
"if (verb == \"trim\" || verb == \"triml\")";
"  if (this && pattern && (r = match(this, tostr(\"^%(\", pattern, \"%)*\"))))";
"    this = this[r[2] + 1..$];";
"  endif";
"endif";
"if (verb == \"trim\" || verb == \"trimr\")";
"  if (this && pattern && (r = match(this, tostr(\"%(\", pattern, \"%)*$\"))))";
"    this = this[1..r[1] - 1];";
"  endif";
"endif";
"return this;";
"";
"chunk_length:12";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:1A865BF364DA2D6028E2FF30599A9715958D5EAB";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"STR\"],\" \",[\"var\",\"string\"],\":\",[\"strong\",\"triml\"],\"([\",[\"var\",\"STR pattern\"],\"])\"],[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"STR\"],\" \",[\"var\",\"string\"],\":\",[\"strong\",\"trimr\"],\"([\",[\"var\",\"STR pattern\"],\"])\"],[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"STR\"],\" \",[\"var\",\"string\"],\":\",[\"strong\",\"trim\"],\"([\",[\"var\",\"STR pattern\"],\"])\"]]";
"[\"p\",\"Trims leading/trailing/both characters from the string. If \",[\"var\",\"pattern\"],\" is not specified it defaults to a space.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"\\\"  foo  \\\":triml()        => \\\"foo  \\\"\"],[\"code\",{\"class\":\"language-moocode\"},\"\\\"  foo  \\\":trimr()        => \\\"  foo\\\"\"],[\"code\",{\"class\":\"language-moocode\"},\"\\\"  foo  \\\":trim()         => \\\"foo\\\"\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:C270CE55278B066389EA97E6D4E8A99E007421F5";
"-=-=-mxyzptlk-=-=-";
.
#19:6
if (args && (typeof(args[1]) == MAP))
{subs, ?case = 0} = args;
for value, key in (subs)
this:_suspend_if_necessary();
this = strsub(this, key, value, case);
endfor
elseif (args && (typeof(args[1]) == LIST))
{subs, ?case = 0} = args;
for item in (subs)
this:_suspend_if_necessary();
this = strsub(this, item[1], item[2], case);
endfor
elseif (args && (typeof(args[1]) == STR))
{from, to, ?case = 0} = args;
this = strsub(this, from, to, case);
else
raise(E_INVARG);
endif
return this;
return;
"if (args && typeof(args[1]) == MAP)";
"  {subs, ?case = 0} = args;";
"  for value, key in (subs)";
"    this:_suspend_if_necessary();";
"    this = strsub(this, key, value, case);";
"  endfor";
"elseif (args && typeof(args[1]) == LIST)";
"  {subs, ?case = 0} = args;";
"  for item in (subs)";
"    this:_suspend_if_necessary();";
"    this = strsub(this, item[1], item[2], case);";
"  endfor";
"elseif (args && typeof(args[1]) == STR)";
"  {from, to, ?case = 0} = args;";
"  this = strsub(this, from, to, case);";
"else";
"  raise(E_INVARG);";
"endif";
"return this;";
"";
"chunk_length:19";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:E1FB0C1CEF67E67A435D3C5411D98621BF820D47";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"STR\"],\" \",[\"var\",\"string\"],\":\",[\"strong\",\"strsub\"],\"(\",[\"var\",\"STR from\"],\", \",[\"var\",\"STR to\"],\" [, \",[\"var\",\"ANY case_matters\"],\"])\"],[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"STR\"],\" \",[\"var\",\"string\"],\":\",[\"strong\",\"strsub\"],\"(\",[\"var\",\"MAP substitutions\"],\" [, \",[\"var\",\"ANY case_matters\"],\"])\"],[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"STR\"],\" \",[\"var\",\"string\"],\":\",[\"strong\",\"strsub\"],\"(\",[\"var\",\"LIST substitutions\"],\" [, \",[\"var\",\"ANY case_matters\"],\"])\"]]";
"[\"p\",\"Performs the specified substitutions on \",[\"var\",\"string\"],\". By default, comparisons ignore upper/lower-case distinctions. If \",[\"var\",\"case_matters\"],\" is provided and true, then case is treated as significant in all comparisons.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"\\\"%n is a fink.\\\":strsub(\\\"%n\\\", \\\"Fred\\\")                    => \\\"Fred is a fink.\\\"\"],[\"code\",{\"class\":\"language-moocode\"},\"\\\"%n is a %m.\\\":strsub([\\\"%n\\\" -> \\\"Fred\\\", \\\"%m\\\" -> \\\"fink\\\"])  => \\\"Fred is a fink.\\\"\"],[\"code\",{\"class\":\"language-moocode\"},\"\\\"%n is a %m.\\\":strsub({{\\\"%n\\\", \\\"Fred\\\"}, {\\\"%m\\\", \\\"fink\\\"}})  => \\\"Fred is a fink.\\\"\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:D0F0A9BFD1E9B2DEBDB77373D84C0A04D6250AC4";
"-=-=-mxyzptlk-=-=-";
.
#19:7
{from, to, ?case = 0} = args;
((len = length(from)) == length(to)) || raise(E_INVARG);
for i in [1..len]
this:_suspend_if_necessary();
this = strsub(this, from[i], to[i], case);
endfor
return this;
return;
"{from, to, ?case = 0} = args;";
"(len = length(from)) == length(to) || raise(E_INVARG);";
"for i in [1..len]";
"  this:_suspend_if_necessary();";
"  this = strsub(this, from[i], to[i], case);";
"endfor";
"return this;";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:2DCB3342FC86401C64D103A6576BDF7B0B6633EA";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"STR\"],\" \",[\"var\",\"string\"],\":\",[\"strong\",\"strtr\"],\"(\",[\"var\",\"STR from\"],\", \",[\"var\",\"STR to\"],\" [, \",[\"var\",\"ANY case_matters\"],\"])\"]]";
"[\"p\",\"Returns a copy of \",[\"var\",\"string\"],\" with the characters in \",[\"var\",\"from\"],\" replaced by the corresponding characters in \",[\"var\",\"to\"],\". By default, translation ignores upper/lower-case distinctions. If \",[\"var\",\"case_matters\"],\" is provided and true, then case is treated as significant in all translations.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"\\\"hello\\\":strtr(\\\"el\\\", \\\"ip\\\")      => \\\"hippo\\\"\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:AEE36DBFC1CF3A5D6BD604371D4854B3F1228A8E";
"-=-=-mxyzptlk-=-=-";
.
#19:8
{length} = args;
result = "";
for i in [1..length]
result = tostr(result, this);
endfor
return result;
return;
"{length} = args;";
"";
"result = \"\";";
"for i in [1..length]";
"  result = tostr(result, this);";
"endfor";
"";
"return result;";
"";
"chunk_length:8";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:4A867180729BFA2110824E793DCB39CFD4917F5A";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"STR\"],\" \",[\"var\",\"string\"],\":\",[\"strong\",\"repeat\"],\"(\",[\"var\",\"INT length\"],\")\"]]";
"[\"p\",\"Returns a string with \",[\"var\",\"string\"],\" repeated \",[\"var\",\"length\"],\" times.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"\\\"123\\\":repeat(3)     => \\\"123123123\\\"\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:FBA98E6DB6E0929C6326485184A0B87C90C09435";
"-=-=-mxyzptlk-=-=-";
.
#19:9
{length} = args;
result = this;
for i in [1..(length - 1) / length(this)]
result = tostr(result, this);
endfor
return result[1..length];
return;
"{length} = args;";
"";
"result = this;";
"for i in [1..((length - 1) / length(this))]";
"  result = tostr(result, this);";
"endfor";
"";
"return result[1..length];";
"";
"chunk_length:8";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:67FA0B0C8110043830F16489CF65EB87AB31DD82";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"STR\"],\" \",[\"var\",\"string\"],\":\",[\"strong\",\"fill\"],\"(\",[\"var\",\"INT length\"],\")\"]]";
"[\"p\",\"Returns a string of length \",[\"var\",\"length\"],\" made up of repetitions of \",[\"var\",\"string\"],\".\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"\\\"123\\\":fill(5)       => \\\"12312\\\"\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:E7E5F31FA313F252CDDB4F671D14AFC4D29117AB";
"-=-=-mxyzptlk-=-=-";
.
#19:10
{length, ?fill = " "} = args;
len = length - length(this);
if (len > 0)
return tostr(fill:fill(len), this);
else
return this[^ - len..$];
endif
return;
"{length, ?fill = \" \"} = args;";
"";
"len = length - length(this);";
"";
"if (len > 0)";
"  return tostr(fill:fill(len), this);";
"else";
"  return this[^ - len..$];";
"endif";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:9F2F9C5AADC10B4C5DDABF739AFF6B2777F8C232";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"STR\"],\" \",[\"var\",\"string\"],\":\",[\"strong\",\"right\"],\"(\",[\"var\",\"INT length\"],\" [, \",[\"var\",\"STR fill\"],\"])\"]]";
"[\"p\",\"Returns a string of length \",[\"var\",\"length\"],\" containing the right-justified string \",[\"var\",\"string\"],\". The optional argument \",[\"var\",\"fill\"],\" specifies the fill/padding character and defaults to a space.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"\\\"foo\\\":right(10)     => \\\"       foo\\\"\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:9073C86B4C42533BDD2F08EC978E42E8B8E53B5C";
"-=-=-mxyzptlk-=-=-";
.
#19:11
{length, ?fill = " "} = args;
len = length - length(this);
if (len > 0)
return tostr(this, fill:fill(len));
else
return this[^..len + $];
endif
return;
"{length, ?fill = \" \"} = args;";
"";
"len = length - length(this);";
"";
"if (len > 0)";
"  return tostr(this, fill:fill(len));";
"else";
"  return this[^..len + $];";
"endif";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:BEF88A7AEC2E4F6F4EC7E30A47B29043337DE31B";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"STR\"],\" \",[\"var\",\"string\"],\":\",[\"strong\",\"left\"],\"(\",[\"var\",\"INT length\"],\" [, \",[\"var\",\"STR fill\"],\"])\"]]";
"[\"p\",\"Returns a string of length \",[\"var\",\"length\"],\" containing the left-justified string \",[\"var\",\"string\"],\". The optional argument \",[\"var\",\"fill\"],\" specifies the fill/padding character and defaults to a space.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"\\\"foo\\\":left(10)     => \\\"foo       \\\"\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:998167253E102E3CCA715647201C09BBEFC8861A";
"-=-=-mxyzptlk-=-=-";
.
#19:12
{length, ?fill = " "} = args;
len = length - length(this);
if (len > 0)
return tostr(fill:fill(len / 2), this, fill:fill((len + 1) / 2));
else
return this[^ - ((len - 1) / 2)..$ + (len / 2)];
endif
return;
"{length, ?fill = \" \"} = args;";
"";
"len = length - length(this);";
"";
"if (len > 0)";
"  return tostr(fill:fill(len / 2), this, fill:fill((len + 1) / 2));";
"else";
"  return this[^ - ((len - 1) / 2)..$ + (len / 2)];";
"endif";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:6D33A0A53A02BDD42863279D706BA5AB1D28DE8E";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"STR\"],\" \",[\"var\",\"string\"],\":\",[\"strong\",\"center\"],\"(\",[\"var\",\"INT length\"],\" [, \",[\"var\",\"STR fill\"],\"])\"]]";
"[\"p\",\"Returns a string of length \",[\"var\",\"length\"],\" containing the centered string \",[\"var\",\"string\"],\". The optional argument \",[\"var\",\"fill\"],\" specifies the fill/padding character and defaults to a space.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"\\\"foo\\\":center(10)     => \\\"   foo    \\\"\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:A0991603857ED686974E9CD8375DF608D690A1DF";
"-=-=-mxyzptlk-=-=-";
.
#19:13
return this:strtr("abcdefghijklmnopqrstuvwxyz", "ABCDEFGHIJKLMNOPQRSTUVWXYZ");
return;
"return this:strtr(\"abcdefghijklmnopqrstuvwxyz\", \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:9BB1469FAAA8E776A6C8AC2D32E31011CEC4C7B4";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"STR\"],\" \",[\"var\",\"string\"],\":\",[\"strong\",\"to_uppercase\"],\"()\"]]";
"[\"p\",\"Returns a copy of \",[\"var\",\"string\"],\" with all lower-case characters replaced by their upper-case counterparts.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"\\\"Foo\\\":to_uppercase()     => \\\"FOO\\\"\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:6AC3E7E63BA75A4A110D0302D530DDA32E989D6F";
"-=-=-mxyzptlk-=-=-";
.
#19:14
return this:strtr("ABCDEFGHIJKLMNOPQRSTUVWXYZ", "abcdefghijklmnopqrstuvwxyz");
return;
"return this:strtr(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", \"abcdefghijklmnopqrstuvwxyz\");";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:FAACF84749443A766183A15DBA559F417C82464D";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"STR\"],\" \",[\"var\",\"string\"],\":\",[\"strong\",\"to_lowercase\"],\"()\"]]";
"[\"p\",\"Returns a copy of \",[\"var\",\"string\"],\" with all upper-case characters replaced by their lower-case counterparts.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"\\\"Foo\\\":to_lowercase()     => \\\"foo\\\"\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:C47620E5B31E7D9AB9AE0B7875E975E4CF60BB34";
"-=-=-mxyzptlk-=-=-";
.
#19:15
this = this:to_lowercase();
if (i = index("abcdefghijklmnopqrstuvwxyz", this[1], 1))
this[1] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"[i];
endif
return this;
return;
"this = this:to_lowercase();";
"";
"if ((i = index(\"abcdefghijklmnopqrstuvwxyz\", this[1], 1)))";
"  this[1] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"[i];";
"endif";
"";
"return this;";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:5B3959347A6CB7F70548B3A8C5AF0E65ADBAB83C";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"STR\"],\" \",[\"var\",\"string\"],\":\",[\"strong\",\"capitalize\"],\"()\"]]";
"[\"p\",\"Returns a copy of \",[\"var\",\"string\"],\" with the first character upper-cased and the remaining characters lower-cased.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"\\\"eL1t3\\\":capitalize()     => \\\"El1t3\\\"\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:667F1EEC9BB5B57CE6643A4ACDDEF5DF42618106";
"-=-=-mxyzptlk-=-=-";
.
#19:16
{chars} = args;
for c in (chars)
this = strsub(this, c, "");
endfor
return this;
return;
"{chars} = args;";
"";
"for c in (chars)";
"  this = strsub(this, c, \"\");";
"endfor";
"";
"return this;";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:2DBB1D306A54F2E88EFA99486EEBB2221D66B670";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"STR\"],\" \",[\"var\",\"string\"],\":\",[\"strong\",\"strip_characters\"],\"(\",[\"var\",\"STR other\"],\")\"]]";
"[\"p\",\"Returns a copy of \",[\"var\",\"string\"],\" with the characters in \",[\"var\",\"other\"],\" removed.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"\\\"foo bar baz\\\":strip_characters(\\\"fb\\\")     => \\\"oo ar az\\\"\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:117476F40FF82F7BAEBCBF830006CC94E78C94D7";
"-=-=-mxyzptlk-=-=-";
.
#19:17
return !this;
return;
"return !this;";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:4C0E259F2F9CF9F35B2B07B8BEB597C440B4051C";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"INT\"],\" \",[\"var\",\"string\"],\":\",[\"strong\",\"is_empty\"],\"()\"]]";
"[\"p\",\"Returns true if \",[\"var\",\"string\"],\" is the empty string.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"\\\"  \\\":is_empty()     => 0\"],[\"code\",{\"class\":\"language-moocode\"},\"\\\"\\\":is_empty()       => 1\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:CCA5F34E76FADA3CF16ADC435B560793B53B5E5E";
"-=-=-mxyzptlk-=-=-";
.
#19:18
return !(!match(this, "^[ 	]*$"));
return;
"return !!match(this, \"^[ 	]*$\");";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:9F420E37E30A61F87F62CADD5D011FEF2DE208A7";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"INT\"],\" \",[\"var\",\"string\"],\":\",[\"strong\",\"is_blank\"],\"()\"]]";
"[\"p\",\"Returns true if \",[\"var\",\"string\"],\" is composed entirely of whitespace.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"\\\"  \\\":is_blank()     => 1\"],[\"code\",{\"class\":\"language-moocode\"},\"\\\"\\\":is_blank()       => 1\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:89B78717E9DCE0391E9E3FA52374015438D658CD";
"-=-=-mxyzptlk-=-=-";
.
#19:19
{sep} = args;
len = length(sep);
if (i = index(this, sep))
return {this[^..i - 1], sep, this[i + len..$]};
endif
return {this, "", ""};
return;
"{sep} = args;";
"";
"len = length(sep);";
"";
"if ((i = index(this, sep)))";
"  return {this[^..i - 1], sep, this[i + len..$]};";
"endif";
"";
"return {this, \"\", \"\"};";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:DC60508E8A9672AAC9CA865096292D54166E1CC4";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"LIST\"],\" \",[\"var\",\"string\"],\":\",[\"strong\",\"partition\"],\"(\",[\"var\",\"STR separator\"],\")\"]]";
"[\"p\",\"Finds the first occurrence of \",[\"var\",\"separator\"],\" in \",[\"var\",\"string\"],\" and returns a list consisting of the part of the string before the separator, the separator, and the part of the string after the separator. If there is no match, the verb returns the original string and two empty strings.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"\\\"foo/bar/baz\\\":partition(\\\"/\\\")     => {\\\"foo\\\", \\\"/\\\", \\\"bar/baz\\\"}\"],[\"code\",{\"class\":\"language-moocode\"},\"\\\"foo/bar/baz\\\":partition(\\\" \\\")     => {\\\"foo/bar/baz\\\", \\\"\\\", \\\"\\\"}\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:F4540A05A935249C9CBC9E6C8AD0AC9F6DA41DCE";
"-=-=-mxyzptlk-=-=-";
.
#19:20
{sep} = args;
len = length(sep);
if (i = rindex(this, sep))
return {this[^..i - 1], sep, this[i + len..$]};
endif
return {"", "", this};
return;
"{sep} = args;";
"";
"len = length(sep);";
"";
"if ((i = rindex(this, sep)))";
"  return {this[^..i - 1], sep, this[i + len..$]};";
"endif";
"";
"return {\"\", \"\", this};";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:F8599119B8C3D4410E9C47FF5C8EA9F3F7C4BC80";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"LIST\"],\" \",[\"var\",\"string\"],\":\",[\"strong\",\"rpartition\"],\"(\",[\"var\",\"STR separator\"],\")\"]]";
"[\"p\",\"Finds the last occurrence of \",[\"var\",\"separator\"],\" in \",[\"var\",\"string\"],\" and returns a list consisting of the part of the string before the separator, the separator, and the part of the string after the separator. If there is no match, the verb returns two empty strings and the original string.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"\\\"foo/bar/baz\\\":rpartition(\\\"/\\\")    => {\\\"foo/bar\\\", \\\"/\\\", \\\"baz\\\"}\"],[\"code\",{\"class\":\"language-moocode\"},\"\\\"foo/bar/baz\\\":rpartition(\\\" \\\")    => {\\\"\\\", \\\"\\\", \\\"foo/bar/baz\\\"}\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:2A98F10085095D471C15FE84C3AB241EEFA54E98";
"-=-=-mxyzptlk-=-=-";
.
#19:21
result = "";
len = length(this);
while (len)
result = result + this[len];
len = len - 1;
endwhile
return result;
return;
"result = \"\";";
"len = length(this);";
"";
"while (len)";
"  result = result + this[len];";
"  len = len - 1;";
"endwhile";
"";
"return result;";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:00F1352F4CB73C7585455CEDD0CAD83B64A85CEA";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"STR\"],\" \",[\"var\",\"string\"],\":\",[\"strong\",\"reverse\"],\"()\"]]";
"[\"p\",\"Returns a copy of \",[\"var\",\"string\"],\" with the characters reversed.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"\\\"foobar\\\":reverse()     => \\\"raboof\\\"\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:3D6430CD456D349C07547B4037D053CD5F1A9E4F";
"-=-=-mxyzptlk-=-=-";
.
#19:22
{?chars = 0} = args;
result = "";
len = length(this);
last = "";
for i in [1..len]
if ((c = this[i]) == last)
continue;
endif
result = result + c;
if (chars)
if (index(chars, c))
last = c;
else
last = "";
endif
else
last = c;
endif
endfor
return result;
return;
"{?chars = 0} = args;";
"";
"result = \"\";";
"len = length(this);";
"last = \"\";";
"";
"for i in [1..len]";
"  if ((c = this[i]) == last)";
"    continue;";
"  endif";
"  result = result + c;";
"  if (chars)";
"    if (index(chars, c))";
"      last = c;";
"    else";
"      last = \"\";";
"    endif";
"  else";
"    last = c;";
"  endif";
"endfor";
"";
"return result;";
"";
"chunk_length:23";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:B3481038CAE2690A1B889F4514705D53B7695CF4";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"STR\"],\" \",[\"var\",\"string\"],\":\",[\"strong\",\"squeeze\"],\"(\",[\"var\",\"STR other\"],\")\"]]";
"[\"p\",\"Returns a copy of \",[\"var\",\"string\"],\" with runs of the characters in \",[\"var\",\"other\"],\" replaced by a single character. If no argument is specified, all runs of the same characters are replaced by a single character.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"\\\"foo bar baz\\\":squeeze(\\\"oa\\\")     => \\\"fo bar baz\\\"\"],[\"code\",{\"class\":\"language-moocode\"},\"\\\"yellow moon\\\":squeeze()         => \\\"yelow mon\\\"\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:0C7E28BBE62F79B0E4C99518E40B99A6A1FC9170";
"-=-=-mxyzptlk-=-=-";
.
#19:23
len = length(this);
ret = decode_binary(this, 1);
while (len)
r = ret[len];
if ((r > 47) && (r < 57))
ret[len] = r + 1;
break;
elseif (r == 57)
ret[len] = 65;
break;
elseif ((r > 64) && (r < 90))
ret[len] = r + 1;
break;
elseif (r == 90)
ret[len] = 97;
break;
elseif ((r > 96) && (r < 122))
ret[len] = r + 1;
break;
elseif ((r == 122) && (len > 1))
ret[len] = 48;
len = len - 1;
elseif (r == 122)
raise(E_INVARG, "Overflow");
else
len = len - 1;
endif
endwhile
return encode_binary(ret);
return;
"len = length(this);";
"ret = decode_binary(this, 1);";
"";
"while (len)";
"  r = ret[len];";
"  if (r > 47 && r < 57)";
"    ret[len] = r + 1;";
"    break;";
"  elseif (r == 57)";
"    ret[len] = 65;";
"    break;";
"  elseif (r > 64 && r < 90)";
"    ret[len] = r + 1;";
"    break;";
"  elseif (r == 90)";
"    ret[len] = 97;";
"    break;";
"  elseif (r > 96 && r < 122)";
"    ret[len] = r + 1;";
"    break;";
"  elseif (r == 122 && len > 1)";
"    ret[len] = 48;";
"    len = len - 1;";
"  elseif (r == 122)";
"    raise(E_INVARG, \"Overflow\");";
"  else";
"    len = len - 1;";
"  endif";
"endwhile";
"";
"return encode_binary(ret);";
"";
"chunk_length:31";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:8A3D41B8028C48941659E9087689792D1FE3FAAE";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"STR\"],\" \",[\"var\",\"string\"],\":\",[\"strong\",\"next\"],\"()\"]]";
"[\"p\",\"Returns the successor to \",[\"var\",\"string\"],\". The successor is created by incrementing the rightmost alphanumeric through the range [0-9A-Za-z]. If the operation overflows, the process repeats with the next rightmost character until all characters in the string have been incremented. If the leftmost character overflows, the verb raises \",[\"var\",\"E_INVARG\"],\".\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"\\\"abcd\\\":next()        => \\\"abce\\\"\"],[\"code\",{\"class\":\"language-moocode\"},\"\\\"THX1138\\\":next()     => \\\"THX1139\\\"\"],[\"code\",{\"class\":\"language-moocode\"},\"\\\"<<koala>>\\\":next()   => \\\"<<koalb>>\\\"\"],[\"code\",{\"class\":\"language-moocode\"},\"\\\"1999zzz\\\":next()     => \\\"199A000\\\"\"],[\"code\",{\"class\":\"language-moocode\"},\"\\\"zzz\\\":next()         raises E_INVARG \"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:392BBB90EB42E44D916FE481410962F9B8F5C17E";
"-=-=-mxyzptlk-=-=-";
.
#19:24
len = length(this);
ret = decode_binary(this, 1);
while (len)
r = ret[len];
if ((r > 97) && (r < 123))
ret[len] = r - 1;
break;
elseif (r == 97)
ret[len] = 90;
break;
elseif ((r > 65) && (r < 91))
ret[len] = r - 1;
break;
elseif (r == 65)
ret[len] = 57;
break;
elseif ((r > 48) && (r < 58))
ret[len] = r - 1;
break;
elseif ((r == 48) && (len > 1))
ret[len] = 122;
len = len - 1;
elseif ((r == 48) && (len == 1))
raise(E_INVARG, "Underflow");
else
len = len - 1;
endif
endwhile
return encode_binary(ret);
return;
"len = length(this);";
"ret = decode_binary(this, 1);";
"";
"while (len)";
"  r = ret[len];";
"  if (r > 97 && r < 123)";
"    ret[len] = r - 1;";
"    break;";
"  elseif (r == 97)";
"    ret[len] = 90;";
"    break;";
"  elseif (r > 65 && r < 91)";
"    ret[len] = r - 1;";
"    break;";
"  elseif (r == 65)";
"    ret[len] = 57;";
"    break;";
"  elseif (r > 48 && r < 58)";
"    ret[len] = r - 1;";
"    break;";
"  elseif (r == 48 && len > 1)";
"    ret[len] = 122;";
"    len = len - 1;";
"  elseif (r == 48 && len == 1)";
"    raise(E_INVARG, \"Underflow\");";
"  else";
"    len = len - 1;";
"  endif";
"endwhile";
"";
"return encode_binary(ret);";
"";
"chunk_length:31";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:F03034D0022F5AB0E04A0AE64F1360E066259BD8";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"STR\"],\" \",[\"var\",\"string\"],\":\",[\"strong\",\"previous\"],\"()\"]]";
"[\"p\",\"Returns the predecessor to \",[\"var\",\"string\"],\". The predecessor is created by decrementing the rightmost alphanumeric through the ranges [0-9A-Za-z]. If the operation underflows, the process repeats with the next rightmost character until all characters in the string have been decremented. If the leftmost character underflows, the verb raises \",[\"var\",\"E_INVARG\"],\".\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"\\\"abce\\\":previous()        => \\\"abcd\\\"\"],[\"code\",{\"class\":\"language-moocode\"},\"\\\"THX1139\\\":previous()     => \\\"THX1138\\\"\"],[\"code\",{\"class\":\"language-moocode\"},\"\\\"<<koalb>>\\\":previous()   => \\\"<<koala>>\\\"\"],[\"code\",{\"class\":\"language-moocode\"},\"\\\"199A000\\\":previous()     => \\\"1999zzz\\\"\"],[\"code\",{\"class\":\"language-moocode\"},\"\\\"000\\\":previous()         raises E_INVARG \"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:4FCCC69607E453B8179DE84FB754F83AFE0F70C2";
"-=-=-mxyzptlk-=-=-";
.
#19:25
return string_hash(this, @args);
return;
"return string_hash(this, @args);";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:1324D17460EAA1CD90E466F6F52C367D7A309F6B";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"STR\"],\" \",[\"var\",\"string\"],\":\",[\"strong\",\"hash\"],\"([\",[\"var\",\"STR algorithm\"],\"])\"]]";
"[\"p\",\"Returns the hash of \",[\"var\",\"string\"],\" computed with the specified algorithm. \\\"sha256\\\", \\\"sha1\\\" and \\\"md5\\\" are supported. If no algorithm is specified, \\\"sha256\\\" is assumed.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"\\\"foo\\\":hash()         => \\\"2C26B46B68FFC68FF99B453C1D30413413422D706483BFA0F98A5E886266E7AE\\\"\"],[\"code\",{\"class\":\"language-moocode\"},\"\\\"foo\\\":hash(\\\"md5\\\")    => \\\"ACBD18DB4CC2F85CEDEF654FCCC4A4D8\\\"\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:B0445D1CFFF60C35D690EEF134BF5211B185F3A5";
"-=-=-mxyzptlk-=-=-";
.
#19:26
{?maximum = 70, ?omission = "..."} = args;
if (typeof(maximum) == STR)
omission = maximum;
maximum = 70;
endif
length = maximum - length(omission);
if (length(this) > length)
return this[1..length] + omission;
else
return this;
endif
return;
"{?maximum = 70, ?omission = \"...\"} = args;";
"";
"if (typeof(maximum) == STR)";
"  omission = maximum;";
"  maximum = 70;";
"endif";
"";
"length = maximum - length(omission);";
"";
"if (length(this) > length)";
"  return this[1..length] + omission;";
"else";
"  return this;";
"endif";
"";
"chunk_length:14";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:A0C2FBED329595BC491BE129A4231A4656D654E8";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"STR\"],\" \",[\"var\",\"string\"],\":\",[\"strong\",\"truncate\"],\"([\",[\"var\",\"INT maximum\"],\"], [\",[\"var\",\"STR omission\"],\"])\"]]";
"[\"p\",\"Truncates the string to the specified \",[\"var\",\"maximum\"],\" length. If truncated, the last characters will be replaced by \",[\"var\",\"omission\"],\". \",\"If \",[\"var\",\"maximum\"],\" is not specified it defaults to 70 characters. if \",[\"var\",\"omission\"],\" is not specified it defaults to \\\"...\\\".\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"\\\"foobarbaz\\\":truncate(6)            => \\\"foo...\\\"\"],[\"code\",{\"class\":\"language-moocode\"},\"\\\"foobarbaz\\\":truncate(6, \\\"**\\\")      => \\\"foob**\\\"\"],[\"code\",{\"class\":\"language-moocode\"},\"\\\"foobarbaz\\\":truncate()             => \\\"foobarbaz\\\"\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:2921A51B2F20968D82691D8032EFD0508C486606";
"-=-=-mxyzptlk-=-=-";
.
#19:27
return encode_base64(this);
return;
"return encode_base64(this);";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:E960E0508582D776A4DBB4ED333C57F977CB08C3";
"-=-=-mxyzptlk-=-=-";
"[\"pre.usage\",[\"code.language-moocode\",[\"em\",\"STR\"],\" \",[\"var\",\"string\"],\":\",[\"strong\",\"encode_base64\"],\"()\"]]";
"[\"p\",\"Base64 encodes the string.\"]";
"[\"pre.example\",[\"code.language-moocode\",\"\\\"abc\\\":encode_base64()    => \\\"YWJj\\\"\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:BAD8A2A1371AE1E300685B7FF3E49808D6812C98";
"-=-=-mxyzptlk-=-=-";
.
#19:28
return decode_base64(this);
return;
"return decode_base64(this);";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:8C22EC5BF8FA43EAF5A794FEA21188927F16BC3D";
"-=-=-mxyzptlk-=-=-";
"[\"pre.usage\",[\"code.language-moocode\",[\"em\",\"STR\"],\" \",[\"var\",\"string\"],\":\",[\"strong\",\"decode_base64\"],\"()\"]]";
"[\"p\",\"Base64 decodes the string.\"]";
"[\"pre.example\",[\"code.language-moocode\",\"\\\"YWJj\\\":decode_base64()    => \\\"abc\\\"\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:8D012705635B5293F0E0C1D47263D2BBF043252C";
"-=-=-mxyzptlk-=-=-";
.
#19:29
return this:strsub({{"&", "&amp;"}, {"<", "&lt;"}, {">", "&gt;"}, {"\"", "&quot;"}, {"'", "&#x27;"}, {"/", "&#x2F;"}});
return;
"return this:strsub({";
"  {\"&\", \"&amp;\"},";
"  {\"<\", \"&lt;\"},";
"  {\">\", \"&gt;\"},";
"  {\"\\\"\", \"&quot;\"},";
"  {\"'\", \"&#x27;\"},";
"  {\"/\", \"&#x2F;\"}";
"});";
"";
"chunk_length:8";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:69D28EBAD95F1D5DF973E4BEE3DEF5909B243D9D";
"-=-=-mxyzptlk-=-=-";
"[\"pre.usage\",[\"code.language-moocode\",[\"em\",\"STR\"],\" \",[\"var\",\"string\"],\":\",[\"strong\",\"escape_html_element_content\"],\"()\"]]";
"[\"p\",\"Escapes untrusted HTML element content. \",[\"strong\",\"Note:\"],\" this verb is typically not sufficient for escaping HTML attribute content, especially content used in JavaScript or CSS contexts, or in unquoted attributes. \",\"See the \",[\"a\",{\"href\":\"https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet\"},\"OWASP XSS Cheat Sheet\"],\" for more information.\"]";
"[\"pre.example\",[\"code.language-moocode\",\"\\\"<foo>&bar</foo>\\\":escape_html_element_content()    => \\\"&lt;foo&gt;&amp;bar&lt;&#x2F;foo&gt;\\\"\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:61687668CD91AECB700E4E931DE845195A4FAC60";
"-=-=-mxyzptlk-=-=-";
.
#19:30
result = "";
for c, i in (decode_binary(this, 1))
if ((((c >= 48) && (c <= 57)) || ((c >= 65) && (c <= 90))) || ((c >= 97) && (c <= 122)))
result = tostr(result, this[i]);
elseif (c == 38)
result = tostr(result, "&amp;");
elseif (c == 60)
result = tostr(result, "&lt;");
elseif (c == 62)
result = tostr(result, "&gt;");
elseif (c == 34)
result = tostr(result, "&quot;");
else
result = tostr(result, "&#x", c:tostr(16), ";");
endif
endfor
return result;
return;
"result = \"\";";
"";
"for c, i in (decode_binary(this, 1))";
"  if ((c >= 48 && c <= 57) || (c >= 65 && c <= 90) || (c >= 97 && c <= 122))";
"    result = tostr(result, this[i]);";
"  elseif (c == 38)";
"    result = tostr(result, \"&amp;\");";
"  elseif (c == 60)";
"    result = tostr(result, \"&lt;\");";
"  elseif (c == 62)";
"    result = tostr(result, \"&gt;\");";
"  elseif (c == 34)";
"    result = tostr(result, \"&quot;\");";
"  else";
"    result = tostr(result, \"&#x\", c:tostr(16), \";\");";
"  endif";
"endfor";
"";
"return result;";
"";
"chunk_length:19";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:2EE2C8D74FFD51B3EE575FF6145E052DF8D810AB";
"-=-=-mxyzptlk-=-=-";
"[\"pre.usage\",[\"code.language-moocode\",[\"em\",\"STR\"],\" \",[\"var\",\"string\"],\":\",[\"strong\",\"escape_html_attribute_content\"],\"()\"]]";
"[\"p\",\"Escapes untrusted HTML attribute content. \",[\"strong\",\"Note:\"],\" this verb is often not sufficient for escaping HTML attribute content in JavaScript, CSS and URL contexts. \",\"See the \",[\"a\",{\"href\":\"https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet\"},\"OWASP XSS Cheat Sheet\"],\" for more information.\"]";
"[\"pre.example\",[\"code.language-moocode\",\"\\\"</ *&%}0\\\\\\\",_->\\\":escape_html_attribute_content()    => \\\"&lt;&#x2F;&#x20;&#x2A;&amp;&#x25;&#x7D;0&quot;&#x2C;&#x5F;&#x2D;&gt;\\\"\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:85B0AEBA6F180129E3F234F6645F21C8A3984198";
"-=-=-mxyzptlk-=-=-";
.
#19:31
result = "";
hex = "123456789ABCDEF";
while (this && (r = match(this, "&amp;%|&lt;%|&gt;%|&quot;%|&#x[0-9A-F][0-9A-F];%|.")))
that = this[^..r[2]];
this = this[r[2] + 1..$];
if (that[1] == "&")
if (that == "&amp;")
result = tostr(result, "&");
elseif (that == "&lt;")
result = tostr(result, "<");
elseif (that == "&gt;")
result = tostr(result, ">");
elseif (that == "&quot;")
result = tostr(result, "\"");
else
c = (hex:index(that[4]) * 16) + hex:index(that[5]);
result = tostr(result, c:chr());
endif
else
result = tostr(result, that);
endif
endwhile
return result;
return;
"result = \"\";";
"";
"hex = \"123456789ABCDEF\";";
"";
"while (this && (r = match(this, \"&amp;%|&lt;%|&gt;%|&quot;%|&#x[0-9A-F][0-9A-F];%|.\")))";
"  that = this[^ .. r[2]];";
"  this = this[r[2] + 1 .. $];";
"  if (that[1] == \"&\")";
"     if (that == \"&amp;\")";
"       result = tostr(result, \"&\");";
"     elseif (that == \"&lt;\")";
"       result = tostr(result, \"<\");";
"     elseif (that == \"&gt;\")";
"       result = tostr(result, \">\");";
"     elseif (that == \"&quot;\")";
"       result = tostr(result, \"\\\"\");";
"     else";
"       c = hex:index(that[4]) * 16 + hex:index(that[5]);";
"       result = tostr(result, c:chr());";
"     endif";
"  else";
"    result = tostr(result, that);";
"  endif";
"endwhile";
"";
"return result;";
"";
"chunk_length:26";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:D6683F30FE49619DFB34B6D7A5231119EBF4717C";
"-=-=-mxyzptlk-=-=-";
"[\"pre.usage\",[\"code.language-moocode\",[\"em\",\"STR\"],\" \",[\"var\",\"string\"],\":\",[\"strong\",\"unescape_html\"],\"()\"]]";
"[\"p\",\"Unescapes HTML content. Intended as a compliment to \",[\"strong\",\"escape_html_element_content()\"],\" and \",[\"strong\",\"escape_html_attribute_content()\"],\".\"]";
"[\"pre.example\",[\"code.language-moocode\",\"\\\"&lt;foo&gt;&amp;bar&lt;&#x2F;foo&gt;\\\":unescape_html()                                    => \\\"<foo>&bar</foo>\\\"\"],[\"code.language-moocode\",\"\\\"&lt;&#x2F;&#x20;&#x2A;&amp;&#x25;&#x7D;0&quot;&#x2C;&#x5F;&#x2D;&gt;\\\":unescape_html()    => \\\"</ *&%}0\\\\\\\",_->\\\"\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:84601161CD2A56281FBE7BF2CCF87DA196B4D221";
"-=-=-mxyzptlk-=-=-";
.
#19:32
return decode_binary(this[1], 1)[1];
return;
"return decode_binary(this[1], 1)[1];";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:6C0C4D31CBD5F0DF80343D1A973E38DB8AE35B63";
"-=-=-mxyzptlk-=-=-";
"[\"pre.usage\",[\"code.language-moocode\",[\"em\",\"INT\"],\" \",[\"var\",\"char\"],\":\",[\"strong\",\"asc\"],\"()\"]]";
"[\"p\",\"Returns the index of the character \",[\"var\",\"chr\"],\" in the ASCII character set.\"]";
"[\"pre.example\",[\"code.language-moocode\",\"\\\",\\\":asc()    => 44\"],[\"code.language-moocode\",\"\\\"^\\\":asc()    => 94\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:90C6F2D8E039DAD85C8720F550AFB9E88390A129";
"-=-=-mxyzptlk-=-=-";
.
#21:0
return this:_lambdafy();
return;
"return this:_lambdafy();";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:959EB05A85FBF2BC337FC649BA3AC422156EFF93";
"-=-=-mxyzptlk-=-=-";
.
#21:1
set_task_perms(caller_perms());
return this:_lambdafy():call(@args);
return;
"set_task_perms(caller_perms());";
"";
"return this:_lambdafy():call(@args);";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:3723F4F2B0BD8DA95790F583FDBFBBFC4E7A778E";
"-=-=-mxyzptlk-=-=-";
.
#21:2
return setadd(this, @args);
return;
"return setadd(this, @args);";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:CE7621ACACF94FCC88B65B17F7158B58DE71DA91";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"LIST\"],\" \",[\"var\",\"list\"],\":\",[\"strong\",\"setadd\"],\"(\",[\"var\",\"value\"],\")\"]]";
"[\"p\",\"Returns a copy of \",[\"var\",\"list\"],\" with \",[\"var\",\"value\"],\" added. Only adds the value if it is not already an element of the list; the list is thus treated as a mathematical set. The value is added at the end of the resulting list.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"{1, 2, 3}:setadd(3)        => {1, 2, 3}\"],[\"code\",{\"class\":\"language-moocode\"},\"{1, 2, 3}:setadd(4)        => {1, 2, 3, 4}\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:57E59B0AD91078788C4F37D7508A44222F543439";
"-=-=-mxyzptlk-=-=-";
.
#21:3
return setremove(this, @args);
return;
"return setremove(this, @args);";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:D11EF59399D367FDF9581B5F3F840CD0525D6740";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"LIST\"],\" \",[\"var\",\"list\"],\":\",[\"strong\",\"setremove\"],\"(\",[\"var\",\"value\"],\")\"]]";
"[\"p\",\"Returns a copy of \",[\"var\",\"list\"],\" with \",[\"var\",\"value\"],\" removed. If the value appears more than once in the list, only the first occurrence is removed in the returned copy.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"{1, 2, 3}:setremove(3)        => {1, 2}\"],[\"code\",{\"class\":\"language-moocode\"},\"{1, 2, 3}:setremove(4)        => {1, 2, 3}\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:BA8E94517D5A5DE450636978B772B4A2401CBCEB";
"-=-=-mxyzptlk-=-=-";
.
#21:4
{LIST} = args;
for i in (LIST)
this:_suspend_if_necessary();
this = setadd(this, i);
endfor
return this;
return;
"{list} = args;";
"";
"for i in (list)";
"  this:_suspend_if_necessary();";
"  this = setadd(this, i);";
"endfor";
"";
"return this;";
"";
"chunk_length:8";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:8093E1F1B5AE3659A8640604A77593E00B6B0B0B";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"LIST\"],\" \",[\"var\",\"list\"],\":\",[\"strong\",\"union\"],\"(\",[\"var\",\"LIST other\"],\")\"]]";
"[\"p\",\"Returns a set constructed from the union of the elements in \",[\"var\",\"list\"],\" and \",[\"var\",\"other\"],\".\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"{1, 2, 3}:union({1, 4})      => {1, 2, 3, 4}\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:768F8CF9A2F89B5EBB6C82F7F78D34E67623A9A6";
"-=-=-mxyzptlk-=-=-";
.
#21:5
{LIST} = args;
result = {};
for i in (LIST)
this:_suspend_if_necessary();
if (i in this)
result = setadd(result, i);
endif
endfor
return result;
return;
"{list} = args;";
"";
"result = {};";
"";
"for i in (list)";
"  this:_suspend_if_necessary();";
"  if (i in this)";
"    result = setadd(result, i);";
"  endif";
"endfor";
"";
"return result;";
"";
"chunk_length:12";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:03B3C8BB2D0698F44CF4653FB5EFA39DAE32B648";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"LIST\"],\" \",[\"var\",\"list\"],\":\",[\"strong\",\"intersection\"],\"(\",[\"var\",\"LIST other\"],\")\"]]";
"[\"p\",\"Returns a set constructed from the intersection of the elements in \",[\"var\",\"list\"],\" and \",[\"var\",\"other\"],\".\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"{1, 2, 3}:intersection({1, 4})      => {1}\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:DDCD2D6A9E669DF871257DAF5EDF2D16A1E7EE59";
"-=-=-mxyzptlk-=-=-";
.
#21:6
{LIST} = args;
for i in (LIST)
this:_suspend_if_necessary();
this = setremove(this, i);
endfor
return this;
return;
"{list} = args;";
"";
"for i in (list)";
"  this:_suspend_if_necessary();";
"  this = setremove(this, i);";
"endfor";
"";
"return this;";
"";
"chunk_length:8";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:488B8E756A8AFEB64308138FC3C8DE99BF9540D1";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"LIST\"],\" \",[\"var\",\"list\"],\":\",[\"strong\",\"difference\"],\"(\",[\"var\",\"LIST other\"],\")\"]]";
"[\"p\",\"Returns a set constructed from the elements in \",[\"var\",\"list\"],\" that are not in \",[\"var\",\"other\"],\".\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"{1, 2, 3}:difference({1, 4})      => {2, 3}\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:BAD7FED5F5BCCEB0E8EBA292B6DF4B8319BA3EEF";
"-=-=-mxyzptlk-=-=-";
.
#21:7
{?sep = " "} = args;
res = "";
for i in (this)
this:_suspend_if_necessary();
i = tostr(i);
res = res + (res ? sep + i | i);
endfor
return res;
return;
"{?sep = \" \"} = args;";
"";
"res = \"\";";
"";
"for i in (this)";
"  this:_suspend_if_necessary();";
"  i = tostr(i);";
"  res = res + (res ? sep + i | i);";
"endfor";
"";
"return res;";
"";
"chunk_length:11";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:D4406C542915510EDFBD3BFEEAFDD7C1B9079ED4";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"STR\"],\" \",[\"var\",\"list\"],\":\",[\"strong\",\"join\"],\"([\",[\"var\",\"STR separator\"],\"])\"]]";
"[\"p\",\"Returns a string constructed from the elements in \",[\"var\",\"list\"],\" coverted to strings and joined by copies of \",[\"var\",\"separator\"],\". If a separator is not specified it defaults to a single space character.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"{1, 2, 3}:join(\\\"-\\\")      => \\\"1-2-3\\\"\"],[\"code\",{\"class\":\"language-moocode\"},\"{1, 2, 3}:join()         => \\\"1 2 3\\\"\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:1B0A115F7FCF07FCD81E3E924D49C326CCAD1934";
"-=-=-mxyzptlk-=-=-";
.
#21:8
args && raise(E_ARGS);
l = length(this);
i = 1;
while (i <= l)
v = this[i];
j = i - 1;
while (j > 0)
this:_suspend_if_necessary();
if (this[j] <= v)
break;
endif
this[j + 1] = this[j];
j = j - 1;
endwhile
this[j + 1] = v;
i = i + 1;
endwhile
return this;
return;
"args && raise(E_ARGS);";
"";
"l = length(this);";
"i = 1;";
"while (i <= l)";
"  v = this[i];";
"  j = i - 1;";
"  while (j > 0)";
"    this:_suspend_if_necessary();";
"    if (this[j] <= v)";
"      break;";
"    endif";
"    this[j + 1] = this[j];";
"    j = j - 1;";
"  endwhile";
"  this[j + 1] = v;";
"  i = i + 1;";
"endwhile";
"";
"return this;";
"";
"chunk_length:20";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:B81C52D295D77B5B6F3277DADF44FEFFAFBFFA0D";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"LIST\"],\" \",[\"var\",\"list\"],\":\",[\"strong\",\"sort\"],\"()\"]]";
"[\"p\",\"Returns a copy of \",[\"var\",\"list\"],\" with the elements sorted. Tries to pick the best algorithm based on the size of the list (which is currently always an insertion sort).\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"{4, 2, 3, 1}:sort()         => {1, 2, 3, 4}\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:CF6CC54132F414F6D7307BDB0C9FB22B0D816B10";
"-=-=-mxyzptlk-=-=-";
.
#21:9
args && raise(E_ARGS);
l = length(this);
i = 1;
while (i <= (l / 2))
this:_suspend_if_necessary();
t = this[i];
this[i] = this[($ - i) + 1];
this[($ - i) + 1] = t;
i = i + 1;
endwhile
return this;
return;
"args && raise(E_ARGS);";
"";
"l = length(this);";
"i = 1;";
"while (i <= l / 2)";
"  this:_suspend_if_necessary();";
"  t = this[i];";
"  this[i] = this[$ - i + 1];";
"  this[$ - i + 1] = t;";
"  i = i + 1;";
"endwhile";
"";
"return this;";
"";
"chunk_length:13";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:138A432FDF55E23108C799F02D3A15516F48B2B1";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"LIST\"],\" \",[\"var\",\"list\"],\":\",[\"strong\",\"reverse\"],\"()\"]]";
"[\"p\",\"Returns a copy of \",[\"var\",\"list\"],\" with the elements reversed.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"{4, 3, 2, 1}:reverse()      => {1, 2, 3, 4}\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:13FD0D34D3AB1AB1F38A3C13FF413807FA8E5970";
"-=-=-mxyzptlk-=-=-";
.
#21:10
nth = args ? (length(args) > 1) ? args | args[1] | 1;
res = {};
if (typeof(nth) == LIST)
for i in (this)
out = {};
for n in (nth)
this:_suspend_if_necessary();
out = {@out, i[n]};
endfor
res = {@res, out};
endfor
else
for i in (this)
this:_suspend_if_necessary();
res = {@res, i[nth]};
endfor
endif
return res;
return;
"nth = args ? length(args) > 1 ? args | args[1] | 1;";
"";
"res = {};";
"";
"if (typeof(nth) == LIST)";
"  for i in (this)";
"    out = {};";
"    for n in (nth)";
"      this:_suspend_if_necessary();";
"      out = {@out, i[n]};";
"    endfor";
"    res = {@res, out};";
"  endfor";
"else";
"  for i in (this)";
"    this:_suspend_if_necessary();";
"    res = {@res, i[nth]};";
"  endfor";
"endif";
"";
"return res;";
"";
"chunk_length:21";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:C332694FE2E63092AEAC24BD016B449B87054AAA";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"LIST\"],\" \",[\"var\",\"list\"],\":\",[\"strong\",\"slice\"],\"(\",[\"var\",\"index\"],\", ...)\"],[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"LIST\"],\" \",[\"var\",\"list\"],\":\",[\"strong\",\"slice\"],\"({\",[\"var\",\"index\"],\", ...})\"]]";
"[\"p\",\"Assumes \",[\"var\",\"list\"],\" is a list of lists. Returns a list of the elements at the specified indexes of the elements of \",[\"var\",\"list\"],\". Note, \",[\"strong\",\"slice()\"],\" also works on lists of maps and lists of strings.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"{{\\\"one\\\", 1, #1}, {\\\"two\\\", 2, #2}, {\\\"three\\\", 3, #3}}:slice(2, 3)      => {{1, #1}, {2, #2}, {3, #3}}\"],[\"code\",{\"class\":\"language-moocode\"},\"{{\\\"one\\\", 1, #1}, {\\\"two\\\", 2, #2}, {\\\"three\\\", 3, #3}}:slice({2, 3})    => {{1, #1}, {2, #2}, {3, #3}}\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:948DA4E7B15874039F4345F947906ECC8E0BDBD2";
"-=-=-mxyzptlk-=-=-";
.
#21:11
{?depth = 2147483647} = args;
new = {};
for item in (this)
this:_suspend_if_necessary();
if ((typeof(item) == LIST) && depth)
new = {@new, @item:flatten(depth - 1)};
else
new = {@new, item};
endif
endfor
return new;
return;
"{?depth = 2147483647} = args;";
"";
"new = {};";
"";
"for item in (this)";
"  this:_suspend_if_necessary();";
"  if (typeof(item) == LIST && depth)";
"    new = {@new, @item:flatten(depth - 1)};";
"  else";
"    new = {@new, item};";
"  endif";
"endfor";
"";
"return new;";
"";
"chunk_length:14";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:EC6B518FEDA2CFC6C8057D094A5AB143573A2310";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"LIST\"],\" \",[\"var\",\"list\"],\":\",[\"strong\",\"flatten\"],\"([\",[\"var\",\"INT depth\"],\"])\"]]";
"[\"p\",\"Returns a copy of \",[\"var\",\"list\"],\" flattened to the specified depth. If \",[\"var\",\"depth\"],\" is not specified, the list of fully flattened.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"{{1, 2}, {3, {4}}}:flatten()      => {1, 2, 3, 4}\"],[\"code\",{\"class\":\"language-moocode\"},\"{{1, 2}, {3, {4}}}:flatten(1)     => {1, 2, 3, {4}}\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:8C0B3B2C679E1035B450FED576676AE2A7D0D86A";
"-=-=-mxyzptlk-=-=-";
.
#21:12
result = {};
for e in (this)
result = setadd(result, e);
endfor
return result;
return;
"result = {};";
"";
"for e in (this)";
"  result = setadd(result, e);";
"endfor";
"";
"return result;";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:F92B516AA7EE3D141BE2F543E1BBF28A2C54B64E";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"LIST\"],\" \",[\"var\",\"list\"],\":\",[\"strong\",\"dedup\"],\"()\"]]";
"[\"p\",\"Returns a copy of \",[\"var\",\"list\"],\" with duplicate elements removed.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"{1, 2, 3, 2, 2}:dedup()     => {1, 2, 3}\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:2C2F19F6B80B3C278AA3575063BEB698700B95B2";
"-=-=-mxyzptlk-=-=-";
.
#21:13
result = {};
for e in (this)
if (`e == last ! E_VARNF => 0')
continue;
endif
result = {@result, e};
last = e;
endfor
return result;
return;
"result = {};";
"";
"for e in (this)";
"  if (`e == last ! E_VARNF => 0')";
"    continue;";
"  endif";
"  result = {@result, e};";
"  last = e;";
"endfor";
"";
"return result;";
"";
"chunk_length:11";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:C9CADB95BFDEE0C8E957A890AA53408CEE3008F0";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"LIST\"],\" \",[\"var\",\"list\"],\":\",[\"strong\",\"compress\"],\"()\"]]";
"[\"p\",\"Returns a copy of \",[\"var\",\"list\"],\" with runs of duplicate elements replaced by a single element.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"{1, 2, 3, 2, 2}:compress()     => {1, 2, 3, 2}\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:F9C80F182C8E5CF662B499D704F94829D50D4BCB";
"-=-=-mxyzptlk-=-=-";
.
#21:14
{el} = args;
while (i = el in this)
this = listdelete(this, i);
endwhile
return this;
return;
"{el} = args;";
"";
"while (i = (el in this))";
"  this = listdelete(this, i);";
"endwhile";
"";
"return this;";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:6EA8F8BFCBB606959B60224F53F4DB14E75ED9A9";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"LIST\"],\" \",[\"var\",\"list\"],\":\",[\"strong\",\"remove_all\"],\"(\",[\"var\",\"element\"],\")\"]]";
"[\"p\",\"Returns a copy of \",[\"var\",\"list\"],\" with \",[\"var\",\"element\"],\" removed.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"{1, 2, 3, 2, 2}:remove_all(2)     => {1, 3}\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:F5B638F82A2BB3EC81E4E264E9D39BA28E89D431";
"-=-=-mxyzptlk-=-=-";
.
#21:15
{length} = args;
result = {};
for i in [1..length]
result = {@result, @this};
endfor
return result;
return;
"{length} = args;";
"";
"result = {};";
"for i in [1..length]";
"  result = {@result, @this};";
"endfor";
"";
"return result;";
"";
"chunk_length:8";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:9737EB1FF7CF6F7474771F3F440ABE614298FAED";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"LIST\"],\" \",[\"var\",\"list\"],\":\",[\"strong\",\"repeat\"],\"(\",[\"var\",\"INT number\"],\")\"]]";
"[\"p\",\"Returns a list with \",[\"var\",\"list\"],\" repeated \",[\"var\",\"number\"],\" times.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"{1, 2}:repeat(2)     => {1, 2, 1, 2}\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:B8C655BB9ABAEFB72F12382A46234B76F5B31A4B";
"-=-=-mxyzptlk-=-=-";
.
#21:16
{el} = args;
count = 0;
while (i = el in this)
count = count + 1;
this = this[i + 1..$];
endwhile
return count;
return;
"{el} = args;";
"";
"count = 0;";
"";
"while (i = (el in this))";
"  count = count + 1;";
"  this = this[i + 1..$];";
"endwhile";
"";
"return count;";
"";
"chunk_length:10";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:E6CEBBF3C5FE9698B7A7456838C8932D107499FB";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"INT\"],\" \",[\"var\",\"list\"],\":\",[\"strong\",\"count\"],\"(\",[\"var\",\"element\"],\")\"]]";
"[\"p\",\"Returns the number of times \",[\"var\",\"element\"],\" appears in \",[\"var\",\"list\"],\".\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"{1, 2, 3, 2, 2}:count(2)     => 3\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:1B702FE3B4FC68326BFA9F02F32AFE5B62069F88";
"-=-=-mxyzptlk-=-=-";
.
#21:17
return !this;
return;
"return !this;";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:4C0E259F2F9CF9F35B2B07B8BEB597C440B4051C";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"INT\"],\" \",[\"var\",\"list\"],\":\",[\"strong\",\"is_empty\"],\"()\"]]";
"[\"p\",\"Returns true if \",[\"var\",\"list\"],\" contains no elements.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"{1, 2}:is_empty()     => 0\"],[\"code\",{\"class\":\"language-moocode\"},\"{}:is_empty()         => 1\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:6C062C740A0F98C13F5937C78B6DB889947CF337";
"-=-=-mxyzptlk-=-=-";
.
#21:18
{length} = args;
this:_suspend_if_necessary();
if (length > length(this))
return {};
elseif (length == 0)
return {{}};
elseif (length == 1)
result = {};
for e in (this)
result = {@result, {e}};
endfor
return result;
else
result = {};
{e, @rest} = this;
for r in (rest:combinations(length - 1))
result = {@result, {e, @r}};
endfor
return {@result, @rest:combinations(length)};
endif
return;
"{length} = args;";
"";
"this:_suspend_if_necessary();";
"";
"if (length > length(this))";
"  return {};";
"elseif (length == 0)";
"  return {{}};";
"elseif (length == 1)";
"  result = {};";
"  for e in (this)";
"    result = {@result, {e}};";
"  endfor";
"  return result;";
"else";
"  result = {};";
"  {e, @rest} = this;";
"  for r in (rest:combinations(length - 1))";
"    result = {@result, {e, @r}};";
"  endfor";
"  return {@result, @rest:combinations(length)};";
"endif";
"";
"chunk_length:22";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:992F306D251624E202D17BDB5BC7CFDE3D8BA266";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"LIST\"],\" \",[\"var\",\"list\"],\":\",[\"strong\",\"combinations\"],\"(\",[\"var\",\"INT number\"],\")\"]]";
"[\"p\",\"Returns all combinations of length \",[\"var\",\"number\"],\" for \",[\"var\",\"list\"],\".\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"{1, 2, 3}:combinations(1)     => {{1}, {2}, {3}}\"],[\"code\",{\"class\":\"language-moocode\"},\"{1, 2, 3}:combinations(2)     => {{1, 2}, {1, 3}, {2, 3}}\"],[\"code\",{\"class\":\"language-moocode\"},\"{1, 2, 3}:combinations(3)     => {{1, 2, 3}}\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:C4747932371EE4BD1AF811AD75BF7D780A195488";
"-=-=-mxyzptlk-=-=-";
.
#21:19
{length} = args;
this:_suspend_if_necessary();
if (length > length(this))
return {};
elseif (length == 0)
return {{}};
elseif (length == 1)
result = {};
for e in (this)
result = {@result, {e}};
endfor
return result;
else
result = {};
for i in [1..length(this)]
e = this[i];
rest = listdelete(this, i);
for r in (rest:permutations(length - 1))
result = {@result, {e, @r}};
endfor
endfor
return result;
endif
return;
"{length} = args;";
"";
"this:_suspend_if_necessary();";
"";
"if (length > length(this))";
"  return {};";
"elseif (length == 0)";
"  return {{}};";
"elseif (length == 1)";
"  result = {};";
"  for e in (this)";
"    result = {@result, {e}};";
"  endfor";
"  return result;";
"else";
"  result = {};";
"  for i in [1..length(this)]";
"    e = this[i];";
"    rest = listdelete(this, i);";
"    for r in (rest:permutations(length - 1))";
"      result = {@result, {e, @r}};";
"    endfor";
"  endfor";
"  return result;";
"endif";
"";
"chunk_length:25";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:3D2EED80CA17D9C00F29C48ECE44EE30154AE9F4";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"LIST\"],\" \",[\"var\",\"list\"],\":\",[\"strong\",\"permutations\"],\"(\",[\"var\",\"INT number\"],\")\"]]";
"[\"p\",\"Returns all permutations of length \",[\"var\",\"number\"],\" for \",[\"var\",\"list\"],\".\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"{1, 2, 3}:permutations(1)     => {{1}, {2}, {3}}\"],[\"code\",{\"class\":\"language-moocode\"},\"{1, 2, 3}:permutations(2)     => {{1, 2}, {1, 3}, {2, 1}, {2, 3}, {3, 1}, {3, 2}}\"],[\"code\",{\"class\":\"language-moocode\"},\"{1, 2, 3}:permutations(3)     => {{1, 2, 3}, {1, 3, 2}, {2, 1, 3}, {2, 3, 1}, {3, 1, 2}, {3, 2, 1}}\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:B92C66D438AE495C2FBD04C8A17D2EA964DD43F9";
"-=-=-mxyzptlk-=-=-";
.
#21:20
{other} = args;
result = {};
for i in (this)
for j in (other)
this:_suspend_if_necessary();
result = {@result, {i, j}};
endfor
endfor
return result;
return;
"{other} = args;";
"";
"result = {};";
"";
"for i in (this)";
"  for j in (other)";
"    this:_suspend_if_necessary();";
"    result = {@result, {i, j}};";
"  endfor";
"endfor";
"";
"return result;";
"";
"chunk_length:12";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:352238C906053AF2346862E8C758A2B9A6F5C504";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"LIST\"],\" \",[\"var\",\"list\"],\":\",[\"strong\",\"product\"],\"(\",[\"var\",\"LIST other\"],\")\"]]";
"[\"p\",\"Returns the cartesian product of lists \",[\"var\",\"list\"],\" and \",[\"var\",\"other\"],\".\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"{1, 2, 3}:product({4, 5})     => {{1, 4}, {1, 5}, {2, 4}, {2, 5}, {3, 4}, {3, 5}}\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:DE3954516865BA168C64989A0AE7B9F3A4401CFF";
"-=-=-mxyzptlk-=-=-";
.
#21:21
{?count = 1} = args;
count = count % length(this);
if (count > 0)
return {@this[count + 1..$], @this[^..count]};
elseif (count < 0)
return {@this[($ + count) + 1..$], @this[^..$ + count]};
else
return this;
endif
return;
"{?count = 1} = args;";
"";
"count = count % length(this);";
"";
"if (count > 0)";
"  return {@this[count + 1..$], @this[^..count]};";
"elseif (count < 0)";
"  return {@this[$ + count + 1..$], @this[^..$ + count]};";
"else";
"  return this;";
"endif";
"";
"chunk_length:11";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:EABCD5EA5CBECD80475F30B97794A5CB04BFD936";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"LIST\"],\" \",[\"var\",\"list\"],\":\",[\"strong\",\"rotate\"],\"([\",[\"var\",\"INT number\"],\"])\"]]";
"[\"p\",\"Returns a copy of \",[\"var\",\"list\"],\" which has been rotated \",[\"var\",\"number\"],\" positions to the left (if \",[\"var\",\"number\"],\" is positive) or right (if \",[\"var\",\"number\"],\" is negative). If omitted, \",[\"var\",\"number\"],\" defaults to 1.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"{1, 2, 3, 4, 5}:rotate(1)      => {2, 3, 4, 5, 1}\"],[\"code\",{\"class\":\"language-moocode\"},\"{1, 2, 3, 4, 5}:rotate(-1)     => {5, 1, 2, 3, 4}\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:032DB75DB388C58E05F5C324DE0D22FAFD538977";
"-=-=-mxyzptlk-=-=-";
.
#21:22
result = {};
while (this)
l = length(this);
i = random(l);
result = {@result, this[i]};
this = listdelete(this, i);
endwhile
return result;
return;
"result = {};";
"";
"while (this)";
"  l = length(this);";
"  i = random(l);";
"  result = {@result, this[i]};";
"  this = listdelete(this, i);";
"endwhile";
"";
"return result;";
"";
"chunk_length:10";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:B8DB876B98F2948711D6C5B2CCF39271973180BE";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"LIST\"],\" \",[\"var\",\"list\"],\":\",[\"strong\",\"shuffle\"],\"()\"]]";
"[\"p\",\"Returns a copy of \",[\"var\",\"list\"],\" with all elements randomly shuffled.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"{1, 2, 3, 4, 5}:shuffle()     => {3, 4, 5, 1, 2}\"],[\"code\",{\"class\":\"language-moocode\"},\"{1, 2, 3, 4, 5}:shuffle()     => {3, 1, 4, 2, 5}\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:3A50B8F9D96812035A10E65954E2B7AC6B65A83A";
"-=-=-mxyzptlk-=-=-";
.
#21:23
{?length = 1} = args;
return this:shuffle()[1..length];
return;
"{?length = 1} = args;";
"";
"return this:shuffle()[1..length];";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:A3288483A92BF630845BDAA5A49DF0E190D86A22";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"LIST\"],\" \",[\"var\",\"list\"],\":\",[\"strong\",\"sample\"],\"([\",[\"var\",\"INT number\"],\"])\"]]";
"[\"p\",\"Returns a list of \",[\"var\",\"number\"],\" elements selected at random from \",[\"var\",\"list\"],\". If \",[\"var\",\"number\"],\" is not specified, it defaults to 1.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"{1, 2, 3, 4, 5}:sample(2)     => {4, 5}\"],[\"code\",{\"class\":\"language-moocode\"},\"{1, 2, 3, 4, 5}:sample(3)     => {3, 1, 4}\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:E7369F4A20D2E487DA11385AA47DCEC446ACFD82";
"-=-=-mxyzptlk-=-=-";
.
#21:24
result = [];
for pair in (this)
result[pair[1]] = pair[2];
endfor
return result;
return;
"result = [];";
"";
"for pair in (this)";
"  result[pair[1]] = pair[2];";
"endfor";
"";
"return result;";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:4ABFD312B6D48D9A2205DD94798EA17E127BE8ED";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"MAP\"],\" \",[\"var\",\"list\"],\":\",[\"strong\",\"to_map\"],\"()\"]]";
"[\"p\",\"Assumes \",[\"var\",\"list\"],\" is a list of two element lists.  Returns a map constructed from the elements, using the first element in the pair as the key and the second as the value.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"{{1, 2}, {3, 4}}:to_map()     => [1 -> 2, 3 -> 4]\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:DA57978526CEBB5D3207DDB74FBC0AAF51681C23";
"-=-=-mxyzptlk-=-=-";
.
#21:25
if (args)
{n} = args;
return this[^..(^ + n) - 1];
else
return this[^];
endif
return;
"if (args)";
"  {n} = args;";
"  return this[^ .. (^ + n - 1)];";
"else";
"  return this[^];";
"endif";
"";
"chunk_length:6";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:A55D75A8BEB44138FFF361AACC31163F4B445514";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"any\"],\" \",[\"var\",\"list\"],\":\",[\"strong\",\"first\"],\"()\"]]";
"[\"p\",\"Returns the first element of \",[\"var\",\"list\"],\".\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"{1, 2, 3, 4, 5}:first()     => 1\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:6D7B0DD5D8EB2AA65A07D3F5A57580D6891C3E8A";
"-=-=-mxyzptlk-=-=-";
.
#21:26
if (args)
{n} = args;
return this[($ - n) + 1..$];
else
return this[$];
endif
return;
"if (args)";
"  {n} = args;";
"  return this[($ - n + 1) .. $];";
"else";
"  return this[$];";
"endif";
"";
"chunk_length:6";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:65A81226F4611739AE2F087089F0C81DD4BFE54A";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"any\"],\" \",[\"var\",\"list\"],\":\",[\"strong\",\"last\"],\"()\"]]";
"[\"p\",\"Returns the last element of \",[\"var\",\"list\"],\".\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"{1, 2, 3, 4, 5}:last()      => 5\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:707CC9B47F7BFF3947B22FCEE7087C9F2B45C8E6";
"-=-=-mxyzptlk-=-=-";
.
#22:0
return mapkeys(this);
return;
"return mapkeys(this);";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:9354D8C0778D6BDE7497E321636C58BEDF4AEFD2";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"LIST\"],\" \",[\"var\",\"map\"],\":\",[\"strong\",\"keys\"],\"()\"]]";
"[\"p\",\"Returns the keys in \",[\"var\",\"map\"],\".\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"[1 -> #1, 2 -> #2, 3 -> #3]:keys()      => {1, 2, 3}\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:40E66CA7AD4A7C3FC13DDFC3E8ABC041B44E766D";
"-=-=-mxyzptlk-=-=-";
.
#22:1
return mapvalues(this);
return;
"return mapvalues(this);";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:86EC57648206C350FB011EA997EB935E8FB8875C";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"LIST\"],\" \",[\"var\",\"map\"],\":\",[\"strong\",\"values\"],\"()\"]]";
"[\"p\",\"Returns the values in \",[\"var\",\"map\"],\".\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"[1 -> #1, 2 -> #2, 3 -> #3]:values()      => {#1, #2, #3}\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:6DB43A435B10A71DE1974F848B2A19D7E494C189";
"-=-=-mxyzptlk-=-=-";
.
#22:2
for arg in (args)
this:_suspend_if_necessary();
this = mapdelete(this, arg);
endfor
return this;
return;
"for arg in (args)";
"  this:_suspend_if_necessary();";
"  this = mapdelete(this, arg);";
"endfor";
"";
"return this;";
"";
"chunk_length:6";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:369BE6E36CD5566ACD55F3FF34AED7DF99FA8052";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"MAP\"],\" \",[\"var\",\"map\"],\":\",[\"strong\",\"delete\"],\"(\",[\"var\",\"key\"],\", ...)\"]]";
"[\"p\",\"Deletes the specified keys/values from \",[\"var\",\"map\"],\".\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"[1 -> #1, 2 -> #2, 3 -> #3]:delete(2, 3)      => [1 -> #1]\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:64B156C5E84C71BA1FEB67B49664A1AB2F138FE5";
"-=-=-mxyzptlk-=-=-";
.
#22:3
{p, ?d = E_RANGE} = args;
{f, @r} = p;
v = `r ? (typeof(this[f]) == MAP) ? this[f]:value_by_path(r) | E_RANGE | this[f] ! E_RANGE => d';
return v;
return;
"{p, ?d = E_RANGE} = args;";
"";
"{f, @r} = p;";
"";
"v = `r ? typeof(this[f]) == MAP ? this[f]:value_by_path(r) | E_RANGE | this[f] ! E_RANGE => d';";
"";
"return v;";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:A2DABC4108AE2E5D73D8C3E7A55F42778DBEF074";
"-=-=-mxyzptlk-=-=-";
.
#22:4
{p, v} = args;
{f, @r} = p;
this[f] = r ? `(typeof(this[f]) == MAP) ? this[f] | ([]) ! E_RANGE => []':set_value_by_path(r, v) | v;
return this;
return;
"{p, v} = args;";
"";
"{f, @r} = p;";
"";
"this[f] = r ? `typeof(this[f]) == MAP ? this[f] | [] ! E_RANGE => []':set_value_by_path(r, v) | v;";
"";
"return this;";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:5381C2F8F679EE2FEA399FE9FC24331EA02468A7";
"-=-=-mxyzptlk-=-=-";
.
#22:5
{MAP} = args;
for value, key in (MAP)
this:_suspend_if_necessary();
this[key] = value;
endfor
return this;
return;
"{map} = args;";
"for value, key in (map)";
"  this:_suspend_if_necessary();";
"  this[key] = value;";
"endfor";
"return this;";
"";
"chunk_length:6";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:7AE99586C027B648096509215D1DBDB6D3009054";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"MAP\"],\" \",[\"var\",\"map\"],\":\",[\"strong\",\"merge\"],\"(\",[\"var\",\"MAP other\"],\")\"]]";
"[\"p\",\"Returns a new map constructed from the elements in \",[\"var\",\"map\"],\" and \",[\"var\",\"other\"],\". If there are duplicate keys, the keys/values in \",[\"var\",\"other\"],\" replace the keys/values in \",[\"var\",\"map\"],\".\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"[1 -> #1, 2 -> #2, 3 -> #3]:merge([0 -> \\\"hello\\\", 1 -> \\\"there\\\"])      => [0 -> \\\"hello\\\", 1 -> \\\"there\\\", 2 -> #2, 3 -> #3]\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:F9DF383358B5BCD3D0B1BA8AFE05ACABEDF45BA3";
"-=-=-mxyzptlk-=-=-";
.
#22:6
return !this;
return;
"return !this;";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:4C0E259F2F9CF9F35B2B07B8BEB597C440B4051C";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"INT\"],\" \",[\"var\",\"map\"],\":\",[\"strong\",\"is_empty\"],\"()\"]]";
"[\"p\",\"Returns true if \",[\"var\",\"map\"],\" contains no elements.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"[1 -> 2]:is_empty()     => 0\"],[\"code\",{\"class\":\"language-moocode\"},\"[]:is_empty()           => 1\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:CF65245E7F21F6BF0703A73C121F8D54636FDFB8";
"-=-=-mxyzptlk-=-=-";
.
#22:7
{key} = args;
return `(!(!this[key])) || 1 ! E_RANGE => 0';
return;
"{key} = args;";
"";
"return `!!this[key] || 1 ! E_RANGE => 0';";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:9101D22DD497F48848F98FC706704A041E95126B";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"INT\"],\" \",[\"var\",\"map\"],\":\",[\"strong\",\"has_key\"],\"(\",[\"var\",\"key\"],\")\"]]";
"[\"p\",\"Returns true if \",[\"var\",\"map\"],\" contains key \",[\"var\",\"key\"],\".\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"[1 -> #1, 2 -> #2, 3 -> #3]:has_key(2)      => 1\"],[\"code\",{\"class\":\"language-moocode\"},\"[1 -> #1, 2 -> #2, 3 -> #3]:has_key(4)      => 0\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:91484CE31BECD663CEBF1C869AF2CFB3FA55A8CD";
"-=-=-mxyzptlk-=-=-";
.
#22:8
{value} = args;
return !(!(value in this));
return;
"{value} = args;";
"";
"return !!(value in this);";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:E1F1C80AE4C5FE78B47D4953F5EB2BB91421EE5B";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"INT\"],\" \",[\"var\",\"map\"],\":\",[\"strong\",\"has_value\"],\"(\",[\"var\",\"value\"],\")\"]]";
"[\"p\",\"Returns true if \",[\"var\",\"map\"],\" contains value \",[\"var\",\"value\"],\".\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"[1 -> #1, 2 -> #2, 3 -> #3]:has_value(#2)      => 1\"],[\"code\",{\"class\":\"language-moocode\"},\"[1 -> #1, 2 -> #2, 3 -> #3]:has_value(#4)      => 0\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:06D345F2A815A04D54654F2D31154D40C4C2E93F";
"-=-=-mxyzptlk-=-=-";
.
#22:9
result = [];
for v, k in (this)
result[v] = k;
endfor
return result;
return;
"result = [];";
"";
"for v, k in (this)";
"  result[v] = k;";
"endfor";
"";
"return result;";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:FAEC89998AEB147CDBA3D84A4ECF6B56398741C0";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"MAP\"],\" \",[\"var\",\"map\"],\":\",[\"strong\",\"invert\"],\"()\"]]";
"[\"p\",\"Returns a copy of \",[\"var\",\"map\"],\" with the keys and values swapped.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"[1 -> #1, 2 -> #2, 3 -> #3]:invert()      => [#1 -> 1, #2 -> 2, #3 -> 3]\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:9D802D7EF067EE1E39878EFCFAC5C21CC6EA4977";
"-=-=-mxyzptlk-=-=-";
.
#22:10
if (args && (typeof(args[1]) == LIST))
{keys} = args;
else
keys = args;
endif
result = [];
for key in (keys)
`result[key] = this[key] ! E_RANGE';
endfor
return result;
return;
"if (args && typeof(args[1]) == LIST)";
"  {keys} = args;";
"else";
"  keys = args;";
"endif";
"";
"result = [];";
"";
"for key in (keys)";
"  `result[key] = this[key] ! E_RANGE';";
"endfor";
"";
"return result;";
"";
"chunk_length:13";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:F2EC401E8D12D78DEB0078970A88E65234962E5C";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"MAP\"],\" \",[\"var\",\"map\"],\":\",[\"strong\",\"slice\"],\"(\",[\"var\",\"key\"],\", ...)\"]]";
"[\"p\",\"Returns a copy of \",[\"var\",\"map\"],\" with only the keys/values represented by the specified keys included.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"[1 -> #1, 2 -> #2, 3 -> #3]:slice(2, 3)      => [2 -> #2, 3 -> #3]\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:2B233B98E805C893C4191010DA5F08037ECC9914";
"-=-=-mxyzptlk-=-=-";
.
#22:11
result = {};
for value, key in (this)
result = {@result, {key, value}};
endfor
return result;
return;
"result = {};";
"";
"for value, key in (this)";
"  result = {@result, {key, value}};";
"endfor";
"";
"return result;";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:EE280278088C02E59BE7A70BF96E163377A0CD9C";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"LIST\"],\" \",[\"var\",\"map\"],\":\",[\"strong\",\"to_list\"],\"()\"]]";
"[\"p\",\"Returns a list of lists constructed from the elements in \",[\"var\",\"map\"],\", using the key as the first element in the pair and the value as the second.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"[1 -> 2, 3 -> 4]:to_list()     => {{1, 2}, {3, 4}}\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:CB3F38EF596FD47FD62F433889BD93E841B54BD5";
"-=-=-mxyzptlk-=-=-";
.
#23:0
(this == $lambda_proto) || raise(E_VERBNF);
return $lambda(@args);
return;
"this == $lambda_proto || raise(E_VERBNF);";
"return $lambda(@args);";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:77F339663AA8C1DF0EBDBBC1BC629559F6FC15BA";
"-=-=-mxyzptlk-=-=-";
.
#23:1
return this;
return;
"return this;";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:58CFE4977A49A7695FEE4D2F29BB87606D70E92F";
"-=-=-mxyzptlk-=-=-";
.
#23:2
return caller;
return;
"return caller;";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:ABE6F07484C492170E9B7C2F68E0552B0D80DCCE";
"-=-=-mxyzptlk-=-=-";
.
#23:3
{args} = args;
if ((l = length(args)) > 1)
return {args[2..l - 1], args[$]};
else
return {{}, ""};
endif
return;
"{args} = args;";
"";
"if ((l = length(args)) > 1)";
"  return {args[2..l - 1], args[$]};";
"else";
"  return {{}, \"\"};";
"endif";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:995FD2218B9314F5C19EFC6D82D8018EF9AF398D";
"-=-=-mxyzptlk-=-=-";
.
#23:4
{MAP, params, body} = args;
for value, key in (MAP)
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
if (key in params)
params = setremove(params, key);
else
raise(E_INVARG, tostr("Not a formal parameter:  ", key));
endif
body = tostr(key, " = ", toliteral(value), "; ", body);
endfor
return {params, body};
return;
"{map, params, body} = args;";
"";
"for value, key in (map)";
"  (ticks_left() < 10000 || seconds_left() < 2) && suspend(0);";
"  if (key in params)";
"    params = setremove(params, key);";
"  else";
"    raise(E_INVARG, tostr(\"Not a formal parameter:  \", key));";
"  endif";
"  body = tostr(key, \" = \", toliteral(value), \"; \", body);";
"endfor";
"";
"return {params, body};";
"";
"chunk_length:13";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:71D73EBA75C8973EC7663FC1EF7AC1A7BF2ED075";
"-=-=-mxyzptlk-=-=-";
.
#23:5
{?MAP = []} = args;
{params, body} = this:_params_and_body(caller);
{params, body} = this:_prepend_assignments(MAP, params, body);
return $lambda(@params, body);
return;
"{?map = []} = args;";
"";
"{params, body} = this:_params_and_body(caller);";
"";
"{params, body} = this:_prepend_assignments(map, params, body);";
"";
"return $lambda(@params, body);";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:B261DE92E9B55AFED2085388539CAF1B038EF98F";
"-=-=-mxyzptlk-=-=-";
.
#23:6
{object, ?MAP = []} = args;
{params, body} = this:_params_and_body(caller);
{params, body} = this:_prepend_assignments(MAP, params, body);
body = tostr("this = ", toliteral(object), "; ", body);
return $lambda(@params, body);
return;
"{object, ?map = []} = args;";
"";
"{params, body} = this:_params_and_body(caller);";
"";
"{params, body} = this:_prepend_assignments(map, params, body);";
"";
"body = tostr(\"this = \", toliteral(object), \"; \", body);";
"";
"return $lambda(@params, body);";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:EA2B3A9B04DF3AD881675E728160DFD504406DEB";
"-=-=-mxyzptlk-=-=-";
.
#23:7
set_task_perms(caller_perms());
{params, body} = this:_params_and_body(caller);
if (length(args) < (l = length(params)))
raise(E_ARGS, tostr("Too few arguments:  ", params:join(", "), " required"));
endif
for i in [1..l]
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
body = tostr(params[i], " = ", toliteral(args[i]), "; ", body);
endfor
result = eval(body);
result[1] || raise("E_SYNTAX", "Syntax error", result[2]);
return result[2];
return;
"set_task_perms(caller_perms());";
"";
"{params, body} = this:_params_and_body(caller);";
"";
"if (length(args) < (l = length(params)))";
"  raise(E_ARGS, tostr(\"Too few arguments:  \", params:join(\", \"), \" required\"));";
"endif";
"";
"for i in [1..l]";
"  (ticks_left() < 10000 || seconds_left() < 2) && suspend(0);";
"  body = tostr(params[i], \" = \", toliteral(args[i]), \"; \", body);";
"endfor";
"";
"result = eval(body);";
"";
"result[1] || raise(\"E_SYNTAX\", \"Syntax error\", result[2]);";
"";
"return result[2];";
"";
"chunk_length:18";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:36A490B9D5E231CB51F4D5EE750D79D80FB39E0D";
"-=-=-mxyzptlk-=-=-";
.
#24:0
set_task_perms(caller_perms());
(typeof(this) == LIST) || raise(E_INVIND, "Only type list");
{_, name, programmer, location, _} = callers()[1];
if ((name && (programmer == $nothing)) && (location == $nothing))
return;
endif
if (this && ((prototype = this[1]) in $frobs))
return prototype:(verb)(@args);
endif
return pass(@args);
return;
"set_task_perms(caller_perms());";
"";
"/* only lists */";
"typeof(this) == LIST || raise(E_INVIND, \"Only type list\");";
"";
"/* don't respond to calls from built-ins */";
"{_, name, programmer, location, _} = callers()[1];";
"if (name && programmer == $nothing && location == $nothing)";
"  return;";
"endif";
"";
"if (this && (prototype = this[1]) in $frobs)";
"  return prototype:(verb)(@args);";
"endif";
"";
"return pass(@args);";
"";
"chunk_length:16";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:0E68D8B527E7823629D3B988205F34F46FF127B4";
"-=-=-mxyzptlk-=-=-";
.
#25:0
set_task_perms(caller_perms());
(typeof(this) == MAP) || raise(E_INVIND, "Only type map");
{_, name, programmer, location, _} = callers()[1];
if ((name && (programmer == $nothing)) && (location == $nothing))
return;
endif
if (this && (`prototype = this["prototype"] ! E_RANGE' in $frobs))
return prototype:(verb)(@args);
endif
return pass(@args);
return;
"set_task_perms(caller_perms());";
"";
"/* only maps */";
"typeof(this) == MAP || raise(E_INVIND, \"Only type map\");";
"";
"/* don't respond to calls from built-ins */";
"{_, name, programmer, location, _} = callers()[1];";
"if (name && programmer == $nothing && location == $nothing)";
"  return;";
"endif";
"";
"if (this && `prototype = this[\"prototype\"] ! E_RANGE' in $frobs)";
"  return prototype:(verb)(@args);";
"endif";
"";
"return pass(@args);";
"";
"chunk_length:16";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:8487D577477B3464C8E36F9AA0C8926B0A61EDB4";
"-=-=-mxyzptlk-=-=-";
.
#27:0
{what} = args;
valid(what) || raise(E_INVARG);
((caller_perms = caller_perms()).wizard || (caller_perms == what.owner)) || raise(E_PERM);
return what.owner == this.owner;
.
#31:0
{r} = args;
return r[4];
return;
"{r} = args;";
"";
"return r[4];";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:71706F2F64CAC53C5D73E12753B459D8A68C759A";
"-=-=-mxyzptlk-=-=-";
.
#31:1
{r} = args;
return r[4][r[1]..r[2]];
return;
"{r} = args;";
"";
"return r[4][r[1]..r[2]];";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:E7F4D3D33F824CB6370BA48753A1560F27B9BF7A";
"-=-=-mxyzptlk-=-=-";
.
#31:2
{r} = args;
return `r[5] ! E_RANGE => raise(E_INVARG, "Does not include the source")';
return;
"{r} = args;";
"";
"return `r[5] ! E_RANGE => raise(E_INVARG, \"Does not include the source\")';";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:88B478B1B7708B508B4690A7182D366A9BE3964D";
"-=-=-mxyzptlk-=-=-";
.
#31:3
{r} = args;
return this:at(r, {1, 2, 3, 4, 5, 6, 7, 8, 9});
return;
"{r} = args;";
"";
"return this:at(r, {1, 2, 3, 4, 5, 6, 7, 8, 9});";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:68779F16ACC76965966386EC6014D41D63AA38E7";
"-=-=-mxyzptlk-=-=-";
.
#31:4
{r, i} = args;
if (typeof(i) == LIST)
results = {};
for j in (i)
{b, e} = r[3][j];
results = {@results, (e >= b) ? r[4][b..e] | 0};
endfor
else
{b, e} = r[3][i];
results = (e >= b) ? r[4][b..e] | 0;
endif
return results;
return;
"{r, i} = args;";
"";
"if (typeof(i) == LIST)";
"  results = {};";
"  for j in (i)";
"    {b, e} = r[3][j];";
"    results = {@results, (e >= b) ? r[4][b..e] | 0};";
"  endfor";
"else";
"  {b, e} = r[3][i];";
"  results = (e >= b) ? r[4][b..e] | 0;";
"endif";
"";
"return results;";
"";
"chunk_length:14";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:4CC956ECA7BEF7AC86CB0AAC0A74B5C1F760A4CD";
"-=-=-mxyzptlk-=-=-";
.
#31:5
{r, ?i} = args;
if (length(args) > 1)
if (typeof(i) == LIST)
results = {};
for j in (i)
{b, e} = r[3][j];
results = {@results, (verb == "begin") ? b | e};
endfor
else
{b, e} = r[3][i];
results = (verb == "begin") ? b | e;
endif
else
return (verb == "begin") ? r[1] | r[2];
endif
return results;
return;
"{r, ?i} = args;";
"";
"if (length(args) > 1)";
"  if (typeof(i) == LIST)";
"    results = {};";
"    for j in (i)";
"      {b, e} = r[3][j];";
"      results = {@results, (verb == \"begin\") ? b | e};";
"    endfor";
"  else";
"    {b, e} = r[3][i];";
"    results = (verb == \"begin\") ? b | e;";
"  endif";
"else";
"  return (verb == \"begin\") ? r[1] | r[2];";
"endif";
"";
"return results;";
"";
"chunk_length:18";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:05F1E47E6A99D4A28441B50A11995278DF6C208C";
"-=-=-mxyzptlk-=-=-";
.
#31:6
{r, ?i} = args;
if (length(args) > 1)
if (typeof(i) == LIST)
results = {};
for j in (i)
o = r[3][j];
results = {@results, o};
endfor
else
o = r[3][i];
results = o;
endif
else
return {r[1], r[2]};
endif
return results;
return;
"{r, ?i} = args;";
"";
"if (length(args) > 1)";
"  if (typeof(i) == LIST)";
"    results = {};";
"    for j in (i)";
"      o = r[3][j];";
"      results = {@results, o};";
"    endfor";
"  else";
"    o = r[3][i];";
"    results = o;";
"  endif";
"else";
"  return {r[1], r[2]};";
"endif";
"";
"return results;";
"";
"chunk_length:18";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:63376020551180DC974E40634FEA71543B164776";
"-=-=-mxyzptlk-=-=-";
.
#31:7
{r} = args;
if (verb == "post_match")
return r[4][r[2] + 1..$];
else
return r[4][^..r[1] - 1];
endif
return;
"{r} = args;";
"";
"if (verb == \"post_match\")";
"  return r[4][r[2] + 1..$];";
"else";
"  return r[4][^..r[1] - 1];";
"endif";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:7D30EA3EBA0A6BE1E9639E7E77AF6632AEFDC435";
"-=-=-mxyzptlk-=-=-";
.
#31:8
{r} = args;
count = 0;
for c in (r[3])
{b, e} = c;
if (e >= b)
count = count + 1;
endif
endfor
return count;
return;
"{r} = args;";
"";
"count = 0;";
"";
"for c in (r[3])";
"  {b, e} = c;";
"  if (e >= b)";
"    count = count + 1;";
"  endif";
"endfor";
"";
"return count;";
"";
"chunk_length:12";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:A7E792E91A6833BCD44F27BD3F8050504E8A5120";
"-=-=-mxyzptlk-=-=-";
.
#32:0
{year, month, day, hour, minute, second, zone} = args;
year = year + ((month - 1) / 12);
month = ((month - 1) % 12) + 1;
d = ({-1, 30, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334}[month] + day) + (year * 366);
d = ((((((d - ((d + 1038) / 1464)) - ((d + 672) / 1464)) - ((d + 306) / 1464)) - ((d + 109740) / 146400)) - ((d + 73140) / 146400)) - ((d + 36540) / 146400)) - 719528;
return ((((((d * 24) + hour) * 60) - toint(tofloat(zone) * 60.0)) + minute) * 60) + second;
return;
"{year, month, day, hour, minute, second, zone} = args;";
"";
"year = year + (month - 1) / 12;";
"month = (month - 1) % 12 + 1;";
"";
"d = {-1, 30, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334}[month] + day + year * 366;";
"";
"d = d - ((d + 1038) / 1464) - ((d + 672) / 1464) - ((d + 306) / 1464) - ((d + 109740) / 146400) - ((d + 73140) / 146400) - ((d + 36540) / 146400) - 719528;";
"";
"return ((d * 24 + hour) * 60 - toint(tofloat(zone) * 60.0) + minute) * 60 + second;";
"";
"chunk_length:10";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:88ED272372F4856C4490F6D95251D0B425DEE9A4";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"INT\"],\" \",[\"var\",\"$core.utility.time\"],\":\",[\"strong\",\"make_time\"],\"(\",[\"var\",\"INT year\"],\", \",[\"var\",\"INT month\"],\", \",[\"var\",\"INT day\"],\", \",[\"var\",\"INT hour\"],\", \",[\"var\",\"INT minute\"],\", \",[\"var\",\"INT second\"],\", \",[\"var\",\"INT|FLOAT zone\"],\")\"]]";
"[\"p\",\"Makes an epoch time from time components. The timezone, \",[\"var\",\"zone\"],\", is specified as offset from UTC (for example, EST is -5). Fractional timezones are supported.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"$core.utility.time:make_time(2012, 11, 10, 09, 08, 07, -6)     => 1352560087\"],[\"code\",{\"class\":\"language-moocode\"},\"$core.utility.time:make_time(1970, 01, 01, 00, 00, 00, 0)      => 0\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:DB11C992588E083A2BA4F541905E3D6689213956";
"-=-=-mxyzptlk-=-=-";
.
#32:1
{time} = args;
{_, month, day, hhmmss, year, zone} = time:split();
{hour, minute, second} = hhmmss:split(":");
month = month in this.months_short;
zone = this.time_zones[zone];
return this:make_time(toint(year), toint(month), toint(day), toint(hour), toint(minute), toint(second), tofloat(zone));
return;
"{time} = args;";
"";
"{_, month, day, hhmmss, year, zone} = time:split();";
"{hour, minute, second} = hhmmss:split(\":\");";
"month = month in this.months_short;";
"zone = this.time_zones[zone];";
"";
"return this:make_time(toint(year), toint(month), toint(day), toint(hour), toint(minute), toint(second), tofloat(zone));";
"";
"chunk_length:8";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:2A9C62CF4C3E0CF6079B46B0B089F0A24D31C186";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"INT\"],\" \",[\"var\",\"$core.utility.time\"],\":\",[\"strong\",\"parse_ctime\"],\"(\",[\"var\",\"STR time\"],\")\"]]";
"[\"p\",\"Parses ctime format \",[\"var\",\"time\"],\" string and returns an epoch time.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"$core.utility.time:parse_ctime(\\\"Sun Nov 11 06:18:32 1990 EST\\\")     => 658322312\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:CA67D2E42FA9B1540852F2F3553A6A026FD9A95F";
"-=-=-mxyzptlk-=-=-";
.
#32:2
{time} = args;
{date, _, time} = time:partition("T");
if (date && (!time))
{year, ?month = 1, ?day = 1} = date:split("-");
return this:make_time(toint(year), toint(month), toint(day), 0, 0, 0, 0);
elseif (date && time)
{year, ?month = 1, ?day = 1} = date:split("-");
if (time[$] == "Z")
time = (c = rindex(time, ".")) ? time[1..c - 1] | time[1..$ - 1];
{hour, minute, ?second = 0} = time:split(":");
return this:make_time(toint(year), toint(month), toint(day), toint(hour), toint(minute), toint(second), 0);
elseif (i = rindex(time, "+") || rindex(time, "-"))
{hh, mm} = time[i + 1..$]:split(":");
time = (c = rindex(time, ".")) ? time[1..c - 1] | time[1..i - 1];
{hour, minute, ?second = 0} = time:split(":");
return this:make_time(toint(year), toint(month), toint(day), toint(hour) + toint(hh), toint(minute) + toint(mm), toint(second), 0);
endif
endif
raise(E_INVARG);
return;
"{time} = args;";
"";
"{date, _, time} = time:partition(\"T\");";
"";
"if (date && !time)";
"  {year, ?month = 1, ?day = 1} = date:split(\"-\");";
"  return this:make_time(toint(year), toint(month), toint(day), 0, 0, 0, 0);";
"elseif (date && time)";
"  {year, ?month = 1, ?day = 1} = date:split(\"-\");";
"  if (time[$] == \"Z\")";
"    time = (c = rindex(time, \".\")) ? time[1..c - 1] | time[1..$ - 1];";
"    {hour, minute, ?second = 0} = time:split(\":\");";
"    return this:make_time(toint(year), toint(month), toint(day), toint(hour), toint(minute), toint(second), 0);";
"  elseif ((i = (rindex(time, \"+\") || rindex(time, \"-\"))))";
"    {hh, mm} = time[i + 1..$]:split(\":\");";
"    time = (c = rindex(time, \".\")) ? time[1..c - 1] | time[1..i - 1];";
"    {hour, minute, ?second = 0} = time:split(\":\");";
"    return this:make_time(toint(year), toint(month), toint(day), toint(hour) + toint(hh), toint(minute) + toint(mm), toint(second), 0);";
"  endif";
"endif";
"";
"raise(E_INVARG);";
"";
"chunk_length:22";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:46174B176D1E847C1A39F25A59A6E46590DF05E4";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"INT\"],\" \",[\"var\",\"$core.utility.time\"],\":\",[\"strong\",\"parse_w3c_time\"],\"(\",[\"var\",\"STR time\"],\")\"]]";
"[\"p\",\"Parses W3C format \",[\"var\",\"time\"],\" string and returns an epoch time.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"$core.utility.time:parse_w3c_time(\\\"2008-09-15T15:53:01+05:30\\\")     => 1221513781\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:42F00627D4BA4A88EFD9D911D2814BAC3C1338E3";
"-=-=-mxyzptlk-=-=-";
.
#32:3
{value, unit} = args;
phrase = tostr(value, " ", unit, ((value != 1) && "s") || "");
return phrase;
return;
"{value, unit} = args;";
"";
"phrase = tostr(value, \" \", unit, (value != 1) && \"s\" || \"\");";
"";
"return phrase;";
"";
"chunk_length:5";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:21C8E8FAA538140B3A801C6D8A1F26A0BEF45EC4";
"-=-=-mxyzptlk-=-=-";
.
#32:4
{?time = time(), ?reference = 0} = args;
if (!(delta = time - reference))
return "0 seconds";
endif
parts = {};
r = ctime(reference);
y = toint(r[21..24]);
m = is_member(r[5..7], this.months_short);
years = 0;
while (delta > ((temp = (365 + ((!(y % 4)) && (!((y % 400) in {100, 200, 300})))) * 86400) - 1))
years = years + 1;
delta = delta - temp;
y = y + 1;
endwhile
if (years)
parts = {@parts, this:_pluralize(years, "year")};
endif
monthdays = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
leapdays = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
months = 0;
while (delta > ((temp = (((!(y % 4)) && (!((y % 400) in {100, 200, 300}))) ? leapdays[m] | monthdays[m]) * 86400) - 1))
months = months + 1;
delta = delta - temp;
m = (m < 12) ? m + 1 | 1;
y = y + (m == 1);
endwhile
if (months)
parts = {@parts, this:_pluralize(months, "month")};
endif
if (delta > 86399)
days = delta / 86400;
delta = delta % 86400;
parts = {@parts, this:_pluralize(days, "day")};
endif
if (delta > 3599)
hours = delta / 3600;
delta = delta % 3600;
parts = {@parts, this:_pluralize(hours, "hour")};
endif
if (delta > 59)
minutes = delta / 60;
delta = delta % 60;
parts = {@parts, this:_pluralize(minutes, "minute")};
endif
if (delta > 0)
seconds = delta;
parts = {@parts, this:_pluralize(seconds, "second")};
endif
if (length(parts) > 2)
return {parts[1..$ - 1]:join(", "), parts[$]}:join(" and ");
else
return parts:join(" and ");
endif
return;
"{?time = time(), ?reference = 0} = args;";
"";
"if (!(delta = time - reference))";
"  return \"0 seconds\";";
"endif";
"";
"parts = {};";
"";
"r = ctime(reference);";
"y = toint(r[21..24]);";
"m = is_member(r[5..7], this.months_short);";
"";
"years = 0;";
"while (delta > (temp = ((365 + (!(y % 4) && !(y % 400 in {100, 200, 300}))) * 86400)) - 1)";
"  years = years + 1;";
"  delta = delta - temp;";
"  y = y + 1;";
"endwhile";
"if (years)";
"  parts = {@parts, this:_pluralize(years, \"year\")};";
"endif";
"";
"monthdays = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};";
"leapdays = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};";
"";
"months = 0;";
"while (delta > (temp = (((!(y % 4) && !(y % 400 in {100, 200, 300})) ? leapdays[m] | monthdays[m]) * 86400)) - 1)";
"  months = months + 1;";
"  delta = delta - temp;";
"  m = (m < 12) ? m + 1 | 1;";
"  y = y + (m == 1);";
"endwhile";
"if (months)";
"  parts = {@parts, this:_pluralize(months, \"month\")};";
"endif";
"";
"if (delta > 86399)";
"  days = delta / 86400;";
"  delta = delta % 86400;";
"  parts = {@parts, this:_pluralize(days, \"day\")};";
"endif";
"";
"if (delta > 3599)";
"  hours = delta / 3600;";
"  delta = delta % 3600;";
"  parts = {@parts, this:_pluralize(hours, \"hour\")};";
"endif";
"";
"if (delta > 59)";
"  minutes = delta / 60;";
"  delta = delta % 60;";
"  parts = {@parts, this:_pluralize(minutes, \"minute\")};";
"endif";
"";
"if (delta > 0)";
"  seconds = delta;";
"  parts = {@parts, this:_pluralize(seconds, \"second\")};";
"endif";
"";
"if (length(parts) > 2)";
"  return {parts[1..$ - 1]:join(\", \"), parts[$]}:join(\" and \");";
"else";
"  return parts:join(\" and \");";
"endif";
"";
"chunk_length:64";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:7B18C9CE1FFE8CCFFFB1492A6060326FEA043F9A";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"STR\"],\" \",[\"var\",\"$core.utility.time\"],\":\",[\"strong\",\"english_time\"],\"([\",[\"var\",\"INT time\"],\" [, \",[\"var\",\"INT reference\"],\"]])\"]]";
"[\"p\",\"Returns an English language description of the difference in time between \",[\"var\",\"time\"],\" and \",[\"var\",\"reference\"],\". \",\"If \",[\"var\",\"time\"],\" is not specified it defaults to the current time. If \",[\"var\",\"reference\"],\" is not specified it defaults to zero (the epoch).\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"$core.utility.time:english_time()                         => \\\"43 years, 20 days, 41 minutes and 16 seconds\\\"\"],[\"code\",{\"class\":\"language-moocode\"},\"$core.utility.time:english_time(658322312)                => \\\"20 years, 10 months, 10 days, 11 hours, 18 minutes and 32 seconds\\\"\"],[\"code\",{\"class\":\"language-moocode\"},\"$core.utility.time:english_time(658322312, 658322311)     => \\\"1 second\\\"\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:D6BB7A23EBCBE886D50E913EE11FC2CD0BC06D13";
"-=-=-mxyzptlk-=-=-";
.
#32:5
return time();
return;
"return time();";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:C651F0649B662C3427C380CA47C4FBE6CBF312EB";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"INT\"],\" \",[\"var\",\"$core.utility.time\"],\":\",[\"strong\",\"now\"],\"()\"]]";
"[\"p\",\"Returns the current time.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"$core.utility.time:now()     => 1363708535\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:DD2F71FD0BD65E4661E42F613942CB86E7371966";
"-=-=-mxyzptlk-=-=-";
.
#32:6
{?time = time()} = args;
month = ctime(time)[5..7] in this.months_short;
return this.months[month];
return;
"{?time = time()} = args;";
"";
"month = ctime(time)[5..7] in this.months_short;";
"";
"return this.months[month];";
"";
"chunk_length:5";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:0F8E992F8196BCE58F368B4904FEBDE8EFD3EC3A";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"STR\"],\" \",[\"var\",\"$core.utility.time\"],\":\",[\"strong\",\"string_month\"],\"([\",[\"var\",\"INT time\"],\"])\"]]";
"[\"p\",\"Returns the name of the current month, or the month for the specified \",[\"var\",\"time\"],\".\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"$core.utility.time:string_month(1363708535)     => \\\"March\\\"\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:3CB6D4DE0415AC52B8CB88B30DCE2BCDDE2A80CF";
"-=-=-mxyzptlk-=-=-";
.
#32:7
{?time = time()} = args;
day = ctime(time)[1..3] in this.days_short;
return this.days[day];
return;
"{?time = time()} = args;";
"";
"day = ctime(time)[1..3] in this.days_short;";
"";
"return this.days[day];";
"";
"chunk_length:5";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:D5F2FFEA15B6472AB74EDD14E862941EDCD8B201";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"STR\"],\" \",[\"var\",\"$core.utility.time\"],\":\",[\"strong\",\"string_day\"],\"([\",[\"var\",\"INT time\"],\"])\"]]";
"[\"p\",\"Returns the name of the current day of the week, or the day for the specified \",[\"var\",\"time\"],\".\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"$core.utility.time:string_day(1363708535)     => \\\"Tuesday\\\"\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:904AE0F1C82F9500E0656E79F0D960E70E5A7B3E";
"-=-=-mxyzptlk-=-=-";
.
#32:8
{?time = time()} = args;
if (verb == "year")
return toint(ctime(time)[21..24]);
elseif (verb == "month")
return is_member(ctime(time)[5..7], this.months_short);
elseif (verb == "day")
return toint(ctime(time)[9..10]);
elseif (verb == "hour")
return toint(ctime(time)[12..13]);
elseif (verb == "minute")
return toint(ctime(time)[15..16]);
elseif (verb == "second")
return toint(ctime(time)[18..19]);
endif
return;
"{?time = time()} = args;";
"";
"if (verb == \"year\")";
"  return toint(ctime(time)[21..24]);";
"elseif (verb == \"month\")";
"  return is_member(ctime(time)[5..7], this.months_short);";
"elseif (verb == \"day\")";
"  return toint(ctime(time)[9..10]);";
"elseif (verb == \"hour\")";
"  return toint(ctime(time)[12..13]);";
"elseif (verb == \"minute\")";
"  return toint(ctime(time)[15..16]);";
"elseif (verb == \"second\")";
"  return toint(ctime(time)[18..19]);";
"endif";
"";
"chunk_length:15";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:ADB4D59AF39F4F617C1D405786B0CED20466956C";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"INT\"],\" \",[\"var\",\"$core.utility.time\"],\":\",[\"strong\",\"year\"],\"([\",[\"var\",\"INT time\"],\"])\"],[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"INT\"],\" \",[\"var\",\"$core.utility.time\"],\":\",[\"strong\",\"month\"],\"([\",[\"var\",\"INT time\"],\"])\"],[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"INT\"],\" \",[\"var\",\"$core.utility.time\"],\":\",[\"strong\",\"day\"],\"([\",[\"var\",\"INT time\"],\"])\"],[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"INT\"],\" \",[\"var\",\"$core.utility.time\"],\":\",[\"strong\",\"hour\"],\"([\",[\"var\",\"INT time\"],\"])\"],[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"INT\"],\" \",[\"var\",\"$core.utility.time\"],\":\",[\"strong\",\"minute\"],\"([\",[\"var\",\"INT time\"],\"])\"],[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"INT\"],\" \",[\"var\",\"$core.utility.time\"],\":\",[\"strong\",\"second\"],\"([\",[\"var\",\"INT time\"],\"])\"]]";
"[\"p\",\"Returns the numeric representation of the current time component (year, month, etc.), or the component for the specified \",[\"var\",\"time\"],\".\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"$core.utility.time:year(1363708535)     => 2013\"],[\"code\",{\"class\":\"language-moocode\"},\"$core.utility.time:day(1363708535)      => 19\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:6E5EA87905978BEC00067810392468E8E1E5454A";
"-=-=-mxyzptlk-=-=-";
.
#32:9
{?time = time()} = args;
hour = toint(ctime(time)[12..13]);
if (verb == "is_am")
return hour < 12;
else
return hour > 11;
endif
return;
"{?time = time()} = args;";
"";
"hour = toint(ctime(time)[12..13]);";
"";
"if (verb == \"is_am\")";
"  return hour < 12;";
"else";
"  return hour > 11;";
"endif";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:EEC313FDCDB400C072269E3611931A932239DFE2";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"INT\"],\" \",[\"var\",\"$core.utility.time\"],\":\",[\"strong\",\"is_am\"],\"([\",[\"var\",\"INT time\"],\"])\"],[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"INT\"],\" \",[\"var\",\"$core.utility.time\"],\":\",[\"strong\",\"is_pm\"],\"([\",[\"var\",\"INT time\"],\"])\"]]";
"[\"p\",\"Returns true if the specified \",[\"var\",\"time\"],\" is AM or PM, as appropriate. If \",[\"var\",\"time\"],\" is not specified, it defaults to the current time.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"$core.utility.time:is_am(1363708535)     => 1\"],[\"code\",{\"class\":\"language-moocode\"},\"$core.utility.time:is_pm(1363708535)     => 0\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:959D8D41B65A7893CD82C66CC02D02CFB33500D7";
"-=-=-mxyzptlk-=-=-";
.
#32:10
{?time = time()} = args;
return ctime(time)[26..28];
return;
"{?time = time()} = args;";
"";
"return ctime(time)[26..28];";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:9527ABA4513B6A874478C2C9E4701AE7153EC58D";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"STR\"],\" \",[\"var\",\"$core.utility.time\"],\":\",[\"strong\",\"zone\"],\"([\",[\"var\",\"INT time\"],\"])\"]]";
"[\"p\",\"Returns the abbreviation of the current time zone, or of the time zone for the specified \",[\"var\",\"time\"],\".\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"$core.utility.time:zone()    => \\\"EDT\\\"\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:B3128D45347277657EE0B7F15241BC54BC33B2A3";
"-=-=-mxyzptlk-=-=-";
.
#32:11
{?time = time()} = args;
return ctime(time)[26..28] in this.dst_zones;
return;
"{?time = time()} = args;";
"";
"return ctime(time)[26..28] in this.dst_zones;";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:A3A42DEA9541742127F1E635A662784B9F169625";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"INT\"],\" \",[\"var\",\"$core.utility.time\"],\":\",[\"strong\",\"is_dst\"],\"([\",[\"var\",\"INT time\"],\"])\"]]";
"[\"p\",\"Returns true if daylight savings time is in effect for the specified \",[\"var\",\"time\"],\". If \",[\"var\",\"time\"],\" is not specified, it defaults to the current time.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"$core.utility.time:is_dst(1363708535)     => 1\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:37ED26E995E91655548F93ADF86470FCB3CBCBD6";
"-=-=-mxyzptlk-=-=-";
.
#32:12
{?time = time()} = args;
return verb[4..6] == ctime(time)[1..3];
return;
"{?time = time()} = args;";
"";
"return verb[4..6] == ctime(time)[1..3];";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:166CD5D85023CE64C3E858D95B524F801ACEDEC4";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"INT\"],\" \",[\"var\",\"$core.utility.time\"],\":\",[\"strong\",\"is_sunday\"],\"([\",[\"var\",\"INT time\"],\"])\"],[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"INT\"],\" \",[\"var\",\"$core.utility.time\"],\":\",[\"strong\",\"is_monday\"],\"([\",[\"var\",\"INT time\"],\"])\"],[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"INT\"],\" \",[\"var\",\"$core.utility.time\"],\":\",[\"strong\",\"is_tuesday\"],\"([\",[\"var\",\"INT time\"],\"])\"],[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"INT\"],\" \",[\"var\",\"$core.utility.time\"],\":\",[\"strong\",\"is_wednesday\"],\"([\",[\"var\",\"INT time\"],\"])\"],[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"INT\"],\" \",[\"var\",\"$core.utility.time\"],\":\",[\"strong\",\"is_thursday\"],\"([\",[\"var\",\"INT time\"],\"])\"],[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"INT\"],\" \",[\"var\",\"$core.utility.time\"],\":\",[\"strong\",\"is_friday\"],\"([\",[\"var\",\"INT time\"],\"])\"],[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"INT\"],\" \",[\"var\",\"$core.utility.time\"],\":\",[\"strong\",\"is_saturday\"],\"([\",[\"var\",\"INT time\"],\"])\"]]";
"[\"p\",\"Returns true if the specified \",[\"var\",\"time\"],\" is the indicated day of week, as appropriate. If \",[\"var\",\"time\"],\" is not specified, it defaults to the current time.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"$core.utility.time:is_sunday(1363708535)     => 0\"],[\"code\",{\"class\":\"language-moocode\"},\"$core.utility.time:is_tuesday(1363708535)    => 1\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:E51615465676FF61A2A58471A613374179E12FF5";
"-=-=-mxyzptlk-=-=-";
.
#32:13
{template, ?time = time(), ?gmt = 0} = args;
if (!template)
return "";
endif
ctime = ctime(time);
if (gmt)
zone = ctime[26..$];
time = time - toint(tofloat(this.time_zones[zone]) * 3600.0);
ctime = ctime(time);
endif
monthdays = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
leapdays = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
result = "";
while (template && (i = index(template, "$")))
value = "";
if (length(template) > i)
if ((c = template[i + 1]) == "$")
value = "$";
elseif (equal(c, "H"))
value = ctime[12..13];
elseif (equal(c, "h"))
value = tostr(toint(ctime[12..13]));
elseif (equal(c, "M"))
value = ctime[15..16];
elseif (equal(c, "m"))
value = tostr(toint(ctime[15..16]));
elseif (equal(c, "S"))
value = ctime[18..19];
elseif (equal(c, "s"))
value = tostr(toint(ctime[18..19]));
elseif (equal(c, "O"))
h = ((toint(ctime[12..13]) + 11) % 12) + 1;
value = (h < 10) ? tostr("0", h) | tostr(h);
elseif (equal(c, "o"))
h = ((toint(ctime[12..13]) + 11) % 12) + 1;
value = tostr(h);
elseif (equal(c, "Y"))
value = ctime[21..24];
elseif (equal(c, "y"))
value = ctime[23..24];
elseif (equal(c, "N"))
value = this.months[ctime[5..7] in this.months_short];
elseif (equal(c, "n"))
value = ctime[5..7];
elseif (equal(c, "B"))
m = ctime[5..7] in this.months_short;
value = (m < 10) ? tostr("0", m) | tostr(m);
elseif (equal(c, "b"))
m = ctime[5..7] in this.months_short;
value = tostr(m);
elseif (equal(c, "C"))
m = ctime[5..7] in this.months_short;
value = (m < 10) ? tostr(" ", m) | tostr(m);
elseif (equal(c, "c"))
m = ctime[5..7] in this.months_short;
value = tostr(m);
elseif (equal(c, "D"))
value = this.days[ctime[1..3] in this.days_short];
elseif (equal(c, "d"))
value = ctime[1..3];
elseif (equal(c, "T"))
d = toint(ctime[9..10]);
value = (d < 10) ? tostr("0", d) | tostr(d);
elseif (equal(c, "t"))
d = toint(ctime[9..10]);
value = tostr(d);
elseif (equal(c, "U"))
d = toint(ctime[9..10]);
value = (d < 10) ? tostr(" ", d) | tostr(d);
elseif (equal(c, "u"))
d = toint(ctime[9..10]);
value = tostr(d);
elseif (equal(c, "P"))
value = (toint(ctime(time)[12..13]) < 12) ? "AM" | "PM";
elseif (equal(c, "p"))
value = (toint(ctime(time)[12..13]) < 12) ? "am" | "pm";
elseif (equal(c, "Z"))
z = ctime[26..$];
z = tofloat(this.time_zones[z]);
sign = (z < 0.0) ? "-" | "+";
z = abs(z);
hh = toint(z);
mm = toint((z - tofloat(hh)) * 60.0);
hh = (hh < 10) ? tostr("0", hh) | tostr(hh);
mm = (mm < 10) ? tostr("0", mm) | tostr(mm);
value = gmt ? "+00:00" | tostr(sign, hh, ":", mm);
elseif (equal(c, "z"))
z = ctime[26..$];
value = gmt ? "GMT" | z;
elseif (equal(c, "w"))
y = toint(ctime[21..24]);
m = is_member(ctime[5..7], this.months_short);
d = toint(ctime[9..10]);
for x in [1..m - 1]
d = d + (((!(y % 4)) && (!((y % 400) in {100, 200, 300}))) ? leapdays[x] | monthdays[x]);
endfor
z = ctime[1..3] in this.days_short;
a = (d - z) / 7;
b = (d - z) % 7;
if (d >= z)
value = tostr((a + (!(!z))) + (!(!b)));
else
value = "1";
endif
elseif (equal(c, "j"))
y = toint(ctime[21..24]);
m = is_member(ctime[5..7], this.months_short);
d = toint(ctime[9..10]);
for x in [1..m - 1]
d = d + (((!(y % 4)) && (!((y % 400) in {100, 200, 300}))) ? leapdays[x] | monthdays[x]);
endfor
value = tostr(d);
endif
endif
result = (result + template[1..i - 1]) + value;
template = template[i + 2..$];
endwhile
result = result + template;
return result;
return;
"{template, ?time = time(), ?gmt = 0} = args;";
"";
"if (!template)";
"  return \"\";";
"endif";
"";
"ctime = ctime(time);";
"";
"if (gmt)";
"  zone = ctime[26..$];";
"  time = time - toint(tofloat(this.time_zones[zone]) * 3600.0);";
"  ctime = ctime(time);";
"endif";
"";
"monthdays = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};";
"leapdays = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};";
"";
"result = \"\";";
"";
"while (template && (i = index(template, \"$\")))";
"  value = \"\";";
"  if (length(template) > i)";
"    if ((c = template[i + 1]) == \"$\")";
"      value = \"$\";";
"    elseif (equal(c, \"H\"))";
"      value = ctime[12..13];";
"    elseif (equal(c, \"h\"))";
"      value = tostr(toint(ctime[12..13]));";
"    elseif (equal(c, \"M\"))";
"      value = ctime[15..16];";
"    elseif (equal(c, \"m\"))";
"      value = tostr(toint(ctime[15..16]));";
"    elseif (equal(c, \"S\"))";
"      value = ctime[18..19];";
"    elseif (equal(c, \"s\"))";
"      value = tostr(toint(ctime[18..19]));";
"    elseif (equal(c, \"O\"))";
"      h = (toint(ctime[12..13]) + 11) % 12 + 1;";
"      value = h < 10 ? tostr(\"0\", h) | tostr(h);";
"    elseif (equal(c, \"o\"))";
"      h = (toint(ctime[12..13]) + 11) % 12 + 1;";
"      value = tostr(h);";
"    elseif (equal(c, \"Y\"))";
"      value = ctime[21..24];";
"    elseif (equal(c, \"y\"))";
"      value = ctime[23..24];";
"    elseif (equal(c, \"N\"))";
"      value = this.months[ctime[5..7] in this.months_short];";
"    elseif (equal(c, \"n\"))";
"      value = ctime[5..7];";
"    elseif (equal(c, \"B\"))";
"      m = ctime[5..7] in this.months_short;";
"      value = m < 10 ? tostr(\"0\", m) | tostr(m);";
"    elseif (equal(c, \"b\"))";
"      m = ctime[5..7] in this.months_short;";
"      value = tostr(m);";
"    elseif (equal(c, \"C\"))";
"      m = ctime[5..7] in this.months_short;";
"      value = m < 10 ? tostr(\" \", m) | tostr(m);";
"    elseif (equal(c, \"c\"))";
"      m = ctime[5..7] in this.months_short;";
"      value = tostr(m);";
"    elseif (equal(c, \"D\"))";
"      value = this.days[ctime[1..3] in this.days_short];";
"    elseif (equal(c, \"d\"))";
"      value = ctime[1..3];";
"    elseif (equal(c, \"T\"))";
"      d = toint(ctime[9..10]);";
"      value = d < 10 ? tostr(\"0\", d) | tostr(d);";
"    elseif (equal(c, \"t\"))";
"      d = toint(ctime[9..10]);";
"      value = tostr(d);";
"    elseif (equal(c, \"U\"))";
"      d = toint(ctime[9..10]);";
"      value = d < 10 ? tostr(\" \", d) | tostr(d);";
"    elseif (equal(c, \"u\"))";
"      d = toint(ctime[9..10]);";
"      value = tostr(d);";
"    elseif (equal(c, \"P\"))";
"      value = toint(ctime(time)[12..13]) < 12 ? \"AM\" | \"PM\";";
"    elseif (equal(c, \"p\"))";
"      value = toint(ctime(time)[12..13]) < 12 ? \"am\" | \"pm\";";
"    elseif (equal(c, \"Z\"))";
"      z = ctime[26..$];";
"      z = tofloat(this.time_zones[z]);";
"      sign = z < 0.0 ? \"-\" | \"+\";";
"      z = abs(z);";
"      hh = toint(z);";
"      mm = toint((z - tofloat(hh)) * 60.0);";
"      hh = hh < 10 ? tostr(\"0\", hh) | tostr(hh);";
"      mm = mm < 10 ? tostr(\"0\", mm) | tostr(mm);";
"      value = gmt ? \"+00:00\" | tostr(sign, hh, \":\", mm);";
"    elseif (equal(c, \"z\"))";
"      z = ctime[26..$];";
"      value = gmt ? \"GMT\" | z;";
"    elseif (equal(c, \"w\"))";
"      y = toint(ctime[21..24]);";
"      m = is_member(ctime[5..7], this.months_short);";
"      d = toint(ctime[9..10]);";
"      for x in [1..m - 1]";
"        d = d + ((!(y % 4) && !(y % 400 in {100, 200, 300})) ? leapdays[x] | monthdays[x]);";
"      endfor";
"      z = ctime[1..3] in this.days_short;";
"      a = (d - z) / 7;";
"      b = (d - z) % 7;";
"      if (d >= z)";
"        value = tostr(a + !!z + !!b);";
"      else";
"        value = \"1\";";
"      endif";
"    elseif (equal(c, \"j\"))";
"      y = toint(ctime[21..24]);";
"      m = is_member(ctime[5..7], this.months_short);";
"      d = toint(ctime[9..10]);";
"      for x in [1..m - 1]";
"        d = d + ((!(y % 4) && !(y % 400 in {100, 200, 300})) ? leapdays[x] | monthdays[x]);";
"      endfor";
"      value = tostr(d);";
"    endif";
"  endif";
"  result = result + template[1..i - 1] + value;";
"  template = template[i + 2..$];";
"endwhile";
"";
"result = result + template;";
"";
"return result;";
"";
"chunk_length:127";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:E58828FEFDE12FE853CC40A759DBF9C5D75B58E7";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"STR\"],\" \",[\"var\",\"$core.utility.time\"],\":\",[\"strong\",\"format\"],\"(\",[\"var\",\"STR format\"],\", [\",[\"var\",\"INT time\"],\", [\",[\"var\",\"INT gmt\"],\"]])\"]]";
"[\"p\",\"Formats the current time, or the specified \",[\"var\",\"time\"],\", according to the specified \",[\"var\",\"format\"],\" string. \",\"By default, the verb operates in the current time zone. The optional \",[\"var\",\"gmt\"],\" flag forces the conversion to GMT/UTC. \",\"Within the formatting string, the following character sequences have special meaning.\"]";
"[\"pre\",\"$$ => $\",\"$H => hours, 24-hour, zero-padded (09)\",\"$h => hours, 24-hour, unpadded (9)\",\"$M => minutes, zero-padded (08)\",\"$m => minutes, unpadded (8)\",\"$S => seconds, zero-padded (07)\",\"$s => seconds, unpadded (7)\",\"$O => hours, 12-hour, zero-padded (07)\",\"$o => hours, 12-hour, unpadded (7)\",\"$Y => year, four-digit (2013)\",\"$y => year, two-digit (13)\",\"$N => month, full (January)\",\"$n => month, abbreviated (Jan)\",\"$B => month, numeric, zero-padded (01)\",\"$b => month, numeric, unpadded (1)\",\"$C => month, numeric, space-padded ( 1)\",\"$c => month, numeric, unpadded (1)\",\"$D => day of week, full (Wednesday)\",\"$d => day of week, abbreviated (Wed)\",\"$T => day, zero-padded (02)\",\"$t => day, unpadded (2)\",\"$U => day, space-padded ( 2)\",\"$u => day, unpadded (2)\",\"$P => am/pm, uppercase (PM)\",\"$p => am/pm, lowercase (pm)\",\"$Z => timezone, numeric (-05:00)\",\"$z => timezone, abbreviated (EST)\",\"$w => week of year (1)\",\"$j => day of year (35)\"]";
"[\"p\",\"Examples:\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"$core.utility.time:format(\\\"$d, $T $n $Y $H:$M:$S $z\\\", 1363708535, 0)    => \\\"Tue, 19 Mar 2013 11:55:35 EDT\\\"\"],[\"code\",{\"class\":\"language-moocode\"},\"$core.utility.time:format(\\\"$Y-$B-$TT$H:$M:$SZ\\\", 1363708535, 1)          => \\\"2013-03-19T15:55:35Z\\\"\"]]";
"";
"chunk_length:5";
"chunk_type:documentation";
"content_type:application/json";
"sha1:5922266B96C3E912EDA23AB33D0CE4473AFDEFA4";
"-=-=-mxyzptlk-=-=-";
.
#32:14
{?time = time()} = args;
return this:format("$d, $T $n $Y $H:$M:$S $z", time, 1);
return;
"{?time = time()} = args;";
"";
"return this:format(\"$d, $T $n $Y $H:$M:$S $z\", time, 1);";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:BF44DAF235B197CE9B58D6366B4E19B8702449C5";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"STR\"],\" \",[\"var\",\"$core.utility.time\"],\":\",[\"strong\",\"rfc1123_time\"],\"([\",[\"var\",\"INT time\"],\"])\"]]";
"[\"p\",\"Returns the RFC 1123 format time. If \",[\"var\",\"time\"],\" is not specified, it defaults to the current time.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"$core.utility.time:rfc1123_time()    => \\\"Tue, 19 Mar 2013 11:55:35 EDT\\\"\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:A4C231FCD2322A902CECB6D64B78A8133F9A257F";
"-=-=-mxyzptlk-=-=-";
.
#32:15
{?time = time()} = args;
return this:format("$Y-$B-$TT$H:$M:$SZ", time, 1);
return;
"{?time = time()} = args;";
"";
"return this:format(\"$Y-$B-$TT$H:$M:$SZ\", time, 1);";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:04557F08F3F1E6301FE59A2D8D3F72D1D9AB6CC7";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"STR\"],\" \",[\"var\",\"$core.utility.time\"],\":\",[\"strong\",\"w3c_time\"],\"([\",[\"var\",\"INT time\"],\"])\"]]";
"[\"p\",\"Returns the W3C (ISO 8601) format time. If \",[\"var\",\"time\"],\" is not specified, it defaults to the current time.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"$core.utility.time:w3c_time()    => \\\"2013-03-19T15:55:35Z\\\"\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:B36AEAA29DE0DFFF11C5A658805C9FF942AE45FA";
"-=-=-mxyzptlk-=-=-";
.
#33:0
{mode} = args;
original = mode;
(r = index(mode, "r")) && (mode = tostr(mode[^..r - 1], mode[r + 1..$]));
(w = index(mode, "w")) && (mode = tostr(mode[^..w - 1], mode[w + 1..$]));
(a = index(mode, "a")) && (mode = tostr(mode[^..a - 1], mode[a + 1..$]));
(p = index(mode, "+")) && (mode = tostr(mode[^..p - 1], mode[p + 1..$]));
(m = index(mode, "-")) && (mode = tostr(mode[^..m - 1], mode[m + 1..$]));
(t = index(mode, "t")) && (mode = tostr(mode[^..t - 1], mode[t + 1..$]));
(b = index(mode, "b")) && (mode = tostr(mode[^..b - 1], mode[b + 1..$]));
(n = index(mode, "n")) && (mode = tostr(mode[^..n - 1], mode[n + 1..$]));
(f = index(mode, "f")) && (mode = tostr(mode[^..f - 1], mode[f + 1..$]));
mode && raise(E_INVARG, tostr("Invalid mode: ", original));
(((r && w) || (r && a)) || (w && a)) && raise(E_INVARG, tostr("Incompatible mode string: ", original));
(p && m) && raise(E_INVARG, tostr("Incompatible mode string: ", original));
(t && b) && raise(E_INVARG, tostr("Incompatible mode string: ", original));
(n && f) && raise(E_INVARG, tostr("Incompatible mode string: ", original));
return tostr((!a) ? (!w) ? "r" | "w" | "a", p ? "+" | "-", b ? "b" | "t", f ? "f" | "n");
return;
"{mode} = args;";
"";
"/* Simplify the setting of the mode string.  Allow common cases with";
" * minimal mode strings: \"r\", \"w\" etc.  Perform more detailed validity";
" * checks.";
" */";
"";
"original = mode;";
"";
"(r = index(mode, \"r\")) && (mode = tostr(mode[^..r - 1], mode[r + 1..$]));";
"(w = index(mode, \"w\")) && (mode = tostr(mode[^..w - 1], mode[w + 1..$]));";
"(a = index(mode, \"a\")) && (mode = tostr(mode[^..a - 1], mode[a + 1..$]));";
"(p = index(mode, \"+\")) && (mode = tostr(mode[^..p - 1], mode[p + 1..$]));";
"(m = index(mode, \"-\")) && (mode = tostr(mode[^..m - 1], mode[m + 1..$]));";
"(t = index(mode, \"t\")) && (mode = tostr(mode[^..t - 1], mode[t + 1..$]));";
"(b = index(mode, \"b\")) && (mode = tostr(mode[^..b - 1], mode[b + 1..$]));";
"(n = index(mode, \"n\")) && (mode = tostr(mode[^..n - 1], mode[n + 1..$]));";
"(f = index(mode, \"f\")) && (mode = tostr(mode[^..f - 1], mode[f + 1..$]));";
"";
"mode && raise(E_INVARG, tostr(\"Invalid mode: \", original));";
"((r && w) || (r && a) || (w && a)) && raise(E_INVARG, tostr(\"Incompatible mode string: \", original));";
"(p && m) && raise(E_INVARG, tostr(\"Incompatible mode string: \", original));";
"(t && b) && raise(E_INVARG, tostr(\"Incompatible mode string: \", original));";
"(n && f) && raise(E_INVARG, tostr(\"Incompatible mode string: \", original));";
"";
"return tostr(";
"  !a ? !w ? \"r\" | \"w\" | \"a\",";
"  p ? \"+\" | \"-\",";
"  b ? \"b\" | \"t\",";
"  f ? \"f\" | \"n\"";
");";
"";
"chunk_length:31";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:284363D6A4672F17547EE11F4398A087FB83F326";
"-=-=-mxyzptlk-=-=-";
.
#33:1
$permit("wizard");
{path, ?mode = ""} = args;
mode = this:_fix_mode(mode);
file = create(this.file_io_proto, 1);
file.file_handle = file_open(path, mode);
file.epoch = $epoch;
file.mode = mode;
file.name = tostr("<", file_name(file.file_handle), ", ", file.mode, ">");
return file;
return;
"$permit(\"wizard\");";
"";
"{path, ?mode = \"\"} = args;";
"";
"mode = this:_fix_mode(mode);";
"";
"file = create(this.file_io_proto, 1);";
"file.file_handle = file_open(path, mode);";
"file.epoch = $epoch;";
"file.mode = mode;";
"";
"file.name = tostr(\"<\", file_name(file.file_handle), \", \", file.mode, \">\");";
"";
"return file;";
"";
"chunk_length:14";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:83502761BB45C2C2A123D389A6C3481CE2F63ABE";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"file\"],\" \",[\"var\",\"$core.utility.file\"],\":\",[\"strong\",\"open\"],\"(\",[\"var\",\"STR path\"],\" [, \",[\"var\",\"STR flags\"],\"])\"]]";
"[\"p\",\"Attempts to open the specified file. The \",[\"var\",\"path\"],\" argument is required. The \",[\"var\",\"flags\"],\" argument can include the following:\"]";
"[\"pre\",\"\\\"r\\\" open the file for reading and fail if the file does not exist\",\"\\\"r+\\\" open the file for reading and writing and fail if the file does not exist\",\"\\\"w\\\" open the file for writing, truncating if it exists and creating if not\",\"\\\"w+\\\" open the file for reading and writing, truncating if it exists and creating if not\",\"\\\"a\\\" open the file for writing, create it if it does not exist; position at the end of the file\",\"\\\"a+\\\" open the file for reading and writing, create it if does not exist; position at the end of the file\"]";
"[\"p\",\"The following flags are optional and can be used along with the flags above:\"]";
"[\"pre\",\"\\\"b\\\" open the file in binary mode\",\"\\\"t\\\" open the file in text mode (default)\",\"\\\"f\\\" force flush data to disk after every write\",\"\\\"n\\\" do not force flush (default)\"]";
"[\"p\",\"In text mode, data is written as-is from the MOO, and data read in by the MOO is stripped of unprintable characters. In binary mode, data is converted from MOO binary string format when written and to MOO binary string format when read. In text mode writing, \\\"\\u001B\\\" means three bytes are written to the file. Similarly, in text mode reading, the line \\\"\\u001B\\\" means the characters \\\"~\\\", \\\"1\\\" and \\\"B\\\" were present in the file. In binary mode reading, \\\"\\u001B\\\" means an ASCII ESC character was in the file. In text mode, reading an ESC character from a file results in the ESC getting stripped.\"]";
"[\"p\",\"Examples:\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"$core.utility.file:open(\\\"foobar.txt\\\", \\\"r\\\")     => \",[\"em\",\"file\"],\" /* file is opened for reading in text mode */\"],[\"code\",{\"class\":\"language-moocode\"},\"$core.utility.file:open(\\\"foobar.png\\\", \\\"wb\\\")    => \",[\"em\",\"file\"],\" /* file is opened for writing in binary mode */\"]]";
"";
"chunk_length:8";
"chunk_type:documentation";
"content_type:application/json";
"sha1:2B2BA3BDD604A877F394715E540A048EC90A9D67";
"-=-=-mxyzptlk-=-=-";
.
#34:0
{object} = args;
if (object.owner != caller_perms())
set_task_perms(caller_perms());
endif
if (index(verb, "_suspended"))
verb = verb[^..$ - 10];
can_suspend = 1;
else
can_suspend = 0;
endif
result = {};
for ancestor in (ancestors(object, 1))
for item in (call_function(verb, ancestor))
can_suspend && $suspend_if_necessary(0);
result = {@result, {ancestor, item}};
endfor
endfor
return result;
return;
"{object} = args;";
"";
"/* Run with wiz-perms for the owner of `object'.  Otherwise, run with";
" * the calling verb's perms.  This allows the owner of `object' to";
" * list all verbs/properties on all ancestors, regardless of";
" * ownership, and the non-owner to list all verbs/properties on all";
" * ancestors if those ancestors are readable.";
" */";
"if (object.owner != caller_perms())";
"  set_task_perms(caller_perms());";
"endif";
"";
"if (index(verb, \"_suspended\"))";
"  verb = verb[^..$ - 10];";
"  can_suspend = 1;";
"else";
"  can_suspend = 0;";
"endif";
"";
"result = {};";
"";
"for ancestor in (ancestors(object, 1))";
"  for item in (call_function(verb, ancestor))";
"    can_suspend && $suspend_if_necessary(0);";
"    result = {@result, {ancestor, item}};";
"  endfor";
"endfor";
"";
"return result;";
"";
"chunk_length:29";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:28DEB861C3A0EA40FE1AD17C6CFDFDF07D139EC9";
"-=-=-mxyzptlk-=-=-";
"[\"pre.usage\",[\"code.language-moocode\",[\"em\",\"LIST\"],\" \",[\"var\",\"$core.utility.object\"],\":\",[\"strong\",\"verbs\"],\"(\",[\"var\",\"OBJ object\"],\")\"],[\"code.language-moocode\",[\"em\",\"LIST\"],\" \",[\"var\",\"$core.utility.object\"],\":\",[\"strong\",\"properties\"],\"(\",[\"var\",\"OBJ object\"],\")\"],[\"code.language-moocode\",[\"em\",\"LIST\"],\" \",[\"var\",\"$core.utility.object\"],\":\",[\"strong\",\"verbs_suspended\"],\"(\",[\"var\",\"OBJ object\"],\")\"],[\"code.language-moocode\",[\"em\",\"LIST\"],\" \",[\"var\",\"$core.utility.object\"],\":\",[\"strong\",\"properties_suspended\"],\"(\",[\"var\",\"OBJ object\"],\")\"]]";
"[\"p\",\"Returns a list of all verbs/properties defined on \",[\"var\",\"object\"],\". \",\"The list is made up of pairs of the form \",[\"code\",\"{\",[\"em\",\"definer\"],\", \",[\"em\",\"name\"],\"}\"],\" where \",[\"em\",\"definer\"],\" is the object on which the verb/property is defined and \",[\"em\",\"name\"],\" is the name of the verb/property. \",\"The \\\"suspended\\\" versions of the verb suspend if necessary while traversing the ancestors.\"]";
"[\"p\",\"Assuming \",[\"code\",\"ancestors(#3)\"],\" returns \",[\"code\",\"{#2, #1}\"],\":\"]";
"[\"pre.example\",[\"code.language-moocode\",\"$core.utility.object:verbs(#3)        => {{#2, \\\"v2\\\"}, {#2, \\\"v1\\\"}, {#1, \\\"v1\\\"}}\"],[\"code.language-moocode\",\"$core.utility.object:properties(#3)   => {{#2, \\\"p3\\\"}, {#2, \\\"p2\\\"}, {#1, \\\"p1\\\"}}\"]]";
"";
"chunk_length:4";
"chunk_type:documentation";
"content_type:application/json";
"sha1:21CDBCF4FFC987388BA808303EC20D599622B8C9";
"-=-=-mxyzptlk-=-=-";
.
#34:1
{object, owner} = args;
if ((verbs(object) || properties(object)) || children(object))
raise(E_INVARG, "Invalid object");
endif
caller_perms = caller_perms();
properties = this:properties(object);
for _, i in (properties)
properties[i] = properties[i][2];
endfor
if (((p = $match_permit(this.change_owner_permit_proto, owner)) == $failed_match) || (p == $ambiguous_match))
if (caller_perms.wizard)
elseif (owner == caller_perms)
return;
else
raise(E_PERM, "Cannot change owner");
endif
endif
if (object.owner != caller_perms)
raise(E_PERM, "Cannot change owner");
endif
for property in (properties)
pi = property_info(object, property);
if (index(pi[2], "c"))
if (pi[1] != caller_perms)
raise(E_PERM, "Cannot change owner");
endif
endif
endfor
object.owner = owner;
for property in (properties)
pi = property_info(object, property);
if (index(pi[2], "c"))
pi[1] = owner;
set_property_info(object, property, pi);
endif
endfor
return;
"/* Changes the owner of `object' to `owner' almost as if the object";
" * were created that way -- in particular, the ownership of `c'";
" * properties is changed, too.  This verb is _not_ a general purpose";
" * ownership changer.  There are many restrictions.  `object' may not";
" * have any verb or property definitions of its own, nor may it have";
" * children.  Both the object and all of its `c' properties must";
" * be owned be the caller.";
" */";
"";
"{object, owner} = args;";
"";
"/* someday, maybe */";
"if (verbs(object) || properties(object) || children(object))";
"  raise(E_INVARG, \"Invalid object\");";
"endif";
"";
"caller_perms = caller_perms();";
"properties = this:properties(object);";
"for _, i in (properties)";
"  properties[i] = properties[i][2];";
"endfor";
"";
"if ((p = $match_permit(this.change_owner_permit_proto, owner)) == $failed_match || p == $ambiguous_match)";
"  /* The following exceptions are useful for testing.  Pragmatically";
"   * speaking, a wizard can already change ownership willy-nilly and a";
"   * non-wizard can already change ownership to itself... so everyone";
"   * retains their existing powers.";
"   */";
"  if (caller_perms.wizard)";
"    ;";
"  elseif (owner == caller_perms)";
"    return;";
"  else";
"    raise(E_PERM, \"Cannot change owner\");";
"  endif";
"endif";
"";
"/* check things out */";
"";
"if (object.owner != caller_perms)";
"  raise(E_PERM, \"Cannot change owner\");";
"endif";
"";
"for property in (properties)";
"  pi = property_info(object, property);";
"  if (index(pi[2], \"c\"))";
"    if (pi[1] != caller_perms)";
"      raise(E_PERM, \"Cannot change owner\");";
"    endif";
"  endif";
"endfor";
"";
"/* go to work */";
"";
"object.owner = owner;";
"";
"for property in (properties)";
"  pi = property_info(object, property);";
"  if (index(pi[2], \"c\"))";
"    pi[1] = owner;";
"    set_property_info(object, property, pi);";
"  endif";
"endfor";
"";
"chunk_length:63";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:3A7AFD6D3B8164F7E6D2A230B5F6DBB4A0641CD1";
"-=-=-mxyzptlk-=-=-";
.
#34:2
{object} = args;
can_suspend = index(verb, "_suspended");
for object in (result = object.contents)
can_suspend && $suspend_if_necessary(0);
if (object.contents)
result = {@result, @this:(verb)(object)};
endif
endfor
return result;
return;
"{object} = args;";
"";
"can_suspend = index(verb, \"_suspended\");";
"";
"for object in (result = object.contents)";
"  can_suspend && $suspend_if_necessary(0);";
"  if (object.contents)";
"    result = {@result, @this:(verb)(object)};";
"  endif";
"endfor";
"";
"return result;";
"";
"chunk_length:12";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:3CD17DE72CE801D9CFDF933A75BCBB887008A4B3";
"-=-=-mxyzptlk-=-=-";
"[\"pre.usage\",[\"code.language-moocode\",[\"em\",\"LIST\"],\" \",[\"var\",\"$core.utility.object\"],\":\",[\"strong\",\"all_contents\"],\"(\",[\"var\",\"OBJ object\"],\")\"],[\"code.language-moocode\",[\"em\",\"LIST\"],\" \",[\"var\",\"$core.utility.object\"],\":\",[\"strong\",\"all_contents_suspended\"],\"(\",[\"var\",\"OBJ object\"],\")\"]]";
"[\"p\",\"Returns a list of all objects enclosed by \",[\"var\",\"object\"],\". \",\"The \\\"suspended\\\" version of the verb suspends if necessary while traversing the contents.\"]";
"[\"pre.example\",[\"code.language-moocode\",\"$core.utility.object:all_contents(#3)   => {#4, #5, #6}\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:9F314FF3F1A355C2F675930688E621B5F5C78BBE";
"-=-=-mxyzptlk-=-=-";
.
#35:0
(typeof(this) == OBJ) || raise(E_INVARG, "Callable on prototypes only");
{subject} = args;
valid(subject) || raise(E_INVARG);
set_task_perms(caller_perms());
instance = create(this, 1);
instance.subject = subject;
return instance;
return;
"typeof(this) == OBJ || raise(E_INVARG, \"Callable on prototypes only\");";
"";
"{subject} = args;";
"";
"valid(subject) || raise(E_INVARG);";
"";
"set_task_perms(caller_perms());";
"";
"instance = create(this, 1);";
"instance.subject = subject;";
"";
"return instance;";
"";
"chunk_length:12";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:E0B35527482AB7F291100402E30E123D3397DD18";
"-=-=-mxyzptlk-=-=-";
.
#35:1
(typeof(this) == ANON) || raise(E_INVARG, "Callable on instances only");
{prototype, owner, subject} = args;
return (isa(this, prototype) && (this.owner == owner)) && (this.subject == subject);
return;
"typeof(this) == ANON || raise(E_INVARG, \"Callable on instances only\");";
"";
"{prototype, owner, subject} = args;";
"";
"return isa(this, prototype) && this.owner == owner && this.subject == subject;";
"";
"chunk_length:5";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:B83C6100FFDD5BA5CFE38F8F4B692C2E2C76DF0C";
"-=-=-mxyzptlk-=-=-";
.
#37:0
callers() && $restrict_to_builtin("create");
return;
"callers() && $restrict_to_builtin(\"create\");";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:0E7D1317F0884312905D7B67686914095C7530B4";
"-=-=-mxyzptlk-=-=-";
.
#37:1
callers() && $restrict_to_builtin("recycle");
this:close();
return;
"callers() && $restrict_to_builtin(\"recycle\");";
"";
"this:close();";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:04B081C88AE7F2B31C186209F128D5217ACC7B7F";
"-=-=-mxyzptlk-=-=-";
.
#37:2
$private();
this:close();
return;
"$private();";
"";
"this:close();";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:F0C74D96A24097A0EE1290F5C9F840B87E88DA05";
"-=-=-mxyzptlk-=-=-";
.
#37:3
((this.epoch == $epoch) && (this.file_handle > -1)) && `file_close(this.file_handle) ! E_FILE';
this.file_handle = -1;
return;
"this.epoch == $epoch && this.file_handle > -1 && `file_close(this.file_handle) ! E_FILE';";
"this.file_handle = -1;";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:6A9710A55188A48EB31888749363188263092AF6";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"none\"],\" \",[\"var\",\"file\"],\":\",[\"strong\",\"close\"],\"()\"]]";
"[\"p\",\"Explicitly closes this \",[\"var\",\"file\"],\".\"]";
"";
"chunk_length:2";
"chunk_type:documentation";
"content_type:application/json";
"sha1:FD93FE920103B104E612F2437554C48DDF85B2C9";
"-=-=-mxyzptlk-=-=-";
.
#37:4
if (((verb == "is_open") && (this.epoch == $epoch)) && (this.file_handle > -1))
return 1;
elseif ((verb == "is_closed") && ((this.epoch != $epoch) || (this.file_handle < 0)))
return 1;
else
return 0;
endif
return;
"if (verb == \"is_open\" && this.epoch == $epoch && this.file_handle > -1)";
"  return 1;";
"elseif (verb == \"is_closed\" && (this.epoch != $epoch || this.file_handle < 0))";
"  return 1;";
"else";
"  return 0;";
"endif";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:80A45FDC4123CB05D694BC51CADFDAAB9D0214EB";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"INT\"],\" \",[\"var\",\"file\"],\":\",[\"strong\",\"is_open\"],\"()\"],[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"INT\"],\" \",[\"var\",\"file\"],\":\",[\"strong\",\"is_closed\"],\"()\"]]";
"[\"p\",\"Returns true if \",[\"var\",\"file\"],\" is open/closed.\"]";
"";
"chunk_length:2";
"chunk_type:documentation";
"content_type:application/json";
"sha1:DACDE8345F2815F049B7037FAF37CD7260C7CD09";
"-=-=-mxyzptlk-=-=-";
.
#37:5
if ((this.epoch == $epoch) && (this.file_handle > -1))
if ((verb == "is_text") && index(this.mode, "t"))
return 1;
elseif ((verb == "is_binary") && index(this.mode, "b"))
return 1;
endif
endif
return 0;
return;
"if (this.epoch == $epoch && this.file_handle > -1)";
"  if (verb == \"is_text\" && index(this.mode, \"t\"))";
"    return 1;";
"  elseif (verb == \"is_binary\" && index(this.mode, \"b\"))";
"    return 1;";
"  endif";
"endif";
"";
"return 0;";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:930E4875C18F2F0C031884510CE9496D93878620";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"INT\"],\" \",[\"var\",\"file\"],\":\",[\"strong\",\"is_text\"],\"()\"],[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"INT\"],\" \",[\"var\",\"file\"],\":\",[\"strong\",\"is_binary\"],\"()\"]]";
"[\"p\",\"Returns true if \",[\"var\",\"file\"],\" was opened in text/binary mode.\"]";
"";
"chunk_length:2";
"chunk_type:documentation";
"content_type:application/json";
"sha1:50163C6762E4EE0879250B92BDAF8117E8E3112A";
"-=-=-mxyzptlk-=-=-";
.
#37:6
if ((this.epoch == $epoch) && (this.file_handle > -1))
if ((verb == "is_readable") && (index(this.mode, "r") || index(this.mode, "+")))
return 1;
elseif ((verb == "is_writeable") && ((index(this.mode, "w") || index(this.mode, "a")) || index(this.mode, "+")))
return 1;
endif
endif
return 0;
return;
"if (this.epoch == $epoch && this.file_handle > -1)";
"  if (verb == \"is_readable\" && (index(this.mode, \"r\") || index(this.mode, \"+\")))";
"    return 1;";
"  elseif (verb == \"is_writeable\" && (index(this.mode, \"w\") || index(this.mode, \"a\") || index(this.mode, \"+\")))";
"    return 1;";
"  endif";
"endif";
"";
"return 0;";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:D8B5CEEB873ED059862AE07B00D82917022C3E9F";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"INT\"],\" \",[\"var\",\"file\"],\":\",[\"strong\",\"is_readable\"],\"()\"],[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"INT\"],\" \",[\"var\",\"file\"],\":\",[\"strong\",\"is_writeable\"],\"()\"]]";
"[\"p\",\"Returns true if \",[\"var\",\"file\"],\" was opened for reading/writing.\"]";
"";
"chunk_length:2";
"chunk_type:documentation";
"content_type:application/json";
"sha1:ED7FF595648EB33C7F7B4519A7B3D336FDA12AD6";
"-=-=-mxyzptlk-=-=-";
.
#37:7
((this.epoch == $epoch) || this:_invalidate()) || raise(E_FILE, "Invalid file");
return call_function("file_" + verb, this.file_handle, @args);
return;
"this.epoch == $epoch || this:_invalidate() || raise(E_FILE, \"Invalid file\");";
"return call_function(\"file_\" + verb, this.file_handle, @args);";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:3394F7D56169A0DBBE4A5C388BA926B2BE4B92AA";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"STR\"],\" \",[\"var\",\"file\"],\":\",[\"strong\",\"readline\"],\"()\"],[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"none\"],\" \",[\"var\",\"file\"],\":\",[\"strong\",\"writeline\"],\"(\",[\"var\",\"STR line\"],\")\"],[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"STR\"],\" \",[\"var\",\"file\"],\":\",[\"strong\",\"read\"],\"(\",[\"var\",\"INT number\"],\")\"],[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"INT\"],\" \",[\"var\",\"file\"],\":\",[\"strong\",\"write\"],\"(\",[\"var\",\"STR data\"],\")\"]]";
"[\"p\",\"Reads/writes from/to the specified \",[\"var\",\"file\"],\".\"]";
"[\"p\",\"The \",[\"strong\",\"read()\"],\" verb reads up to the specified number of bytes from the file and returns them.\"]";
"[\"p\",\"The \",[\"strong\",\"write()\"],\" verb writes the specified data to the file and returns the number of bytes written.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"f:readline()          => \\\"foobar\\\"\"],[\"code\",{\"class\":\"language-moocode\"},\"f:write(\\\"\\n\\r\\\")     => 2\"]]";
"";
"chunk_length:5";
"chunk_type:documentation";
"content_type:application/json";
"sha1:BFCFFB9EF4E94B3766D33537E743D74185B611E7";
"-=-=-mxyzptlk-=-=-";
.
#37:8
((this.epoch == $epoch) || this:_invalidate()) || raise(E_FILE, "Invalid file");
return call_function("file_" + verb, this.file_handle, @args);
return;
"this.epoch == $epoch || this:_invalidate() || raise(E_FILE, \"Invalid file\");";
"return call_function(\"file_\" + verb, this.file_handle, @args);";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:3394F7D56169A0DBBE4A5C388BA926B2BE4B92AA";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"INT\"],\" \",[\"var\",\"file\"],\":\",[\"strong\",\"size\"],\"()\"],[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"INT\"],\" \",[\"var\",\"file\"],\":\",[\"strong\",\"tell\"],\"()\"],[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"none\"],\" \",[\"var\",\"file\"],\":\",[\"strong\",\"seek\"],\"(\",[\"var\",\"INT location\"],\", \",[\"var\",\"STR whence\"],\")\"]]";
"[\"p\",\"The \",[\"strong\",\"size()\"],\" verb returns the size of \",[\"var\",\"file\"],\".\"]";
"[\"p\",\"The \",[\"strong\",\"tell()\"],\" verb returns the current position in \",[\"var\",\"file\"],\".\"]";
"[\"p\",\"The \",[\"strong\",\"seek()\"],\" verb seeks to a position in \",[\"var\",\"file\"],\". \",[\"var\",\"whence\"],\" is one of: \",\"\\\"SEEK_SET\\\" - seek relative to beginning, \\\"SEEK_CUR\\\" - seek relative to current position, \\\"SEEK_END\\\" - seek relative to end.\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"f:seek(0, \\\"SEEK_END\\\")     => _\"]]";
"";
"chunk_length:5";
"chunk_type:documentation";
"content_type:application/json";
"sha1:6D31DF01B386A6867AFD46325371EA4E55E9CCE4";
"-=-=-mxyzptlk-=-=-";
.
#37:9
((this.epoch == $epoch) || this:_invalidate()) || raise(E_FILE, "Invalid file");
return file_eof(this.file_handle);
return;
"this.epoch == $epoch || this:_invalidate() || raise(E_FILE, \"Invalid file\");";
"return file_eof(this.file_handle);";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:BF978095542F8F12E621A3CC4A7DF02A6AE066FE";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"INT\"],\" \",[\"var\",\"file\"],\":\",[\"strong\",\"is_eof\"],\"()\"]]";
"[\"p\",\"Returns true if \",[\"var\",\"file\"],\" is at end of file.\"]";
"";
"chunk_length:2";
"chunk_type:documentation";
"content_type:application/json";
"sha1:D52735BC268F342BB98D8B41F76E0039A01CF4C2";
"-=-=-mxyzptlk-=-=-";
.
#40:0
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
return;
"ticks_left() < 10000 || seconds_left() < 2 && suspend(0);";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:C3608BDA1ACF59B6AE2D36C8E3B873466464014B";
"-=-=-mxyzptlk-=-=-";
.
#40:1
{lines, ?intern = []} = args;
algo = this.default_hash_algo;
result = {};
for line in (lines)
this:_suspend_if_necessary();
hash = string_hash(line, algo);
hash = `intern[hash] ! E_RANGE => intern[hash] = hash';
result = {@result, {line, hash}};
endfor
return {result, intern};
return;
"{lines, ?intern = []} = args;";
"";
"/* By interning strings we ensure that string storage is re-used,";
" * which reduces string compare down to a pointer equality check in";
" * the server.";
" */";
"";
"algo = this.default_hash_algo;";
"";
"result = {};";
"for line in (lines)";
"  this:_suspend_if_necessary();";
"  hash = string_hash(line, algo);";
"  hash = `intern[hash] ! E_RANGE => intern[hash] = hash';";
"  result = {@result, {line, hash}};";
"endfor";
"";
"return {result, intern};";
"";
"chunk_length:18";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:3B840B91F733C547C6F63B2420E85AD186EF1B0E";
"-=-=-mxyzptlk-=-=-";
.
#40:2
{lines1, lines2, intern} = args;
for v, k in (intern)
this:_suspend_if_necessary();
intern[k] = {{0, 0}, {0, 0}};
endfor
for line, i in (lines1)
this:_suspend_if_necessary();
intern[line[2]][1] = {intern[line[2]][1][1] + 1, i};
endfor
for line, i in (lines2)
this:_suspend_if_necessary();
intern[line[2]][2] = {intern[line[2]][2][1] + 1, i};
endfor
items = {};
for line in (lines1)
this:_suspend_if_necessary();
item = intern[line[2]];
if ((item[1][1] == 1) && (item[2][1] == 1))
items = {@items, {item[1][2], item[2][2]}};
endif
endfor
return items;
return;
"{lines1, lines2, intern} = args;";
"";
"for v, k in (intern)";
"  this:_suspend_if_necessary();";
"  intern[k] = {{0, 0}, {0, 0}};";
"endfor";
"";
"for line, i in (lines1)";
"  this:_suspend_if_necessary();";
"  intern[line[2]][1] = {intern[line[2]][1][1] + 1, i};";
"endfor";
"";
"for line, i in (lines2)";
"  this:_suspend_if_necessary();";
"  intern[line[2]][2] = {intern[line[2]][2][1] + 1, i};";
"endfor";
"";
"items = {};";
"for line in (lines1)";
"  this:_suspend_if_necessary();";
"  item = intern[line[2]];";
"  if (item[1][1] == 1 && item[2][1] == 1)";
"    items = {@items, {item[1][2], item[2][2]}};";
"  endif";
"endfor";
"";
"return items;";
"";
"chunk_length:27";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:BCF4FA5C1C969563D67684352B747F95260A8CAD";
"-=-=-mxyzptlk-=-=-";
.
#40:3
{items} = args;
stacks = {};
for item in (items)
last = 0;
for i in [1..length(stacks)]
this:_suspend_if_necessary();
if (item[2] < stacks[i][$][1][2])
stacks[i] = {@stacks[i], {item, last}};
item = 0;
break;
endif
last = length(stacks[i]);
endfor
if (item)
stacks = {@stacks, {{item, last}}};
endif
endfor
stacks = stacks:reverse();
i = stacks && length(stacks[1]);
results = {};
for stack in (stacks)
this:_suspend_if_necessary();
item = stack[i];
results = {item[1], @results};
i = item[2];
endfor
return results;
return;
"{items} = args;";
"";
"/* patience sort */";
"stacks = {};";
"for item in (items)";
"  last = 0;";
"  for i in [1..length(stacks)]";
"    this:_suspend_if_necessary();";
"    if (item[2] < stacks[i][$][1][2])";
"      stacks[i] = {@stacks[i], {item, last}};";
"      item = 0;";
"      break;";
"    endif";
"    last = length(stacks[i]);";
"  endfor";
"  if (item)";
"    stacks = {@stacks, {{item, last}}};";
"  endif";
"endfor";
"";
"stacks = stacks:reverse();";
"i = stacks && length(stacks[1]);";
"results = {};";
"for stack in (stacks)";
"  this:_suspend_if_necessary();";
"  item = stack[i];";
"  results = {item[1], @results};";
"  i = item[2];";
"endfor";
"";
"return results;";
"";
"chunk_length:31";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:F2F39DE79F64CBBB7E604B1600CB04F108F937D1";
"-=-=-mxyzptlk-=-=-";
.
#40:4
{lines1, lines2, lcs} = args;
last = {0, 0};
lcs = {@lcs, {length(lines1) + 1, length(lines2) + 1}};
results = {};
for pos in (lcs)
this:_suspend_if_necessary();
i1 = last[1] + 1;
j1 = pos[1] - 1;
i2 = last[2] + 1;
j2 = pos[2] - 1;
while (i1 < j1)
this:_suspend_if_necessary();
if (lines1[i1][2] == `lines2[i2][2] ! E_RANGE')
i1 = i1 + 1;
i2 = i2 + 1;
continue;
endif
break;
endwhile
while (j1 >= i1)
this:_suspend_if_necessary();
if (lines1[j1][2] == `lines2[j2][2] ! E_RANGE')
j1 = j1 - 1;
j2 = j2 - 1;
continue;
endif
break;
endwhile
res1 = lines1[i1..j1]:slice(1);
res2 = lines2[i2..j2]:slice(1);
if (res1 && res2)
results = {@results, {"r", i1, i2, res1, res2}};
elseif (res1)
results = {@results, {"-", i1, i2, res1}};
elseif (res2)
results = {@results, {"+", i1, i2, res2}};
endif
last = pos;
endfor
return results;
return;
"{lines1, lines2, lcs} = args;";
"";
"last = {0, 0};";
"lcs = {@lcs, {length(lines1) + 1, length(lines2) + 1}};";
"";
"results = {};";
"for pos in (lcs)";
"  this:_suspend_if_necessary();";
"";
"  i1 = last[1] + 1;";
"  j1 = pos[1] - 1;";
"  i2 = last[2] + 1;";
"  j2 = pos[2] - 1;";
"  while (i1 < j1)";
"    this:_suspend_if_necessary();";
"    if (lines1[i1][2] == `lines2[i2][2] ! E_RANGE')";
"      i1 = i1 + 1;";
"      i2 = i2 + 1;";
"      continue;";
"    endif";
"    break;";
"  endwhile";
"  while (j1 >= i1)";
"    this:_suspend_if_necessary();";
"    if (lines1[j1][2] == `lines2[j2][2] ! E_RANGE')";
"      j1 = j1 - 1;";
"      j2 = j2 - 1;";
"      continue;";
"    endif";
"    break;";
"  endwhile";
"  res1 = lines1[i1..j1]:slice(1);";
"  res2 = lines2[i2..j2]:slice(1);";
"  if (res1 && res2)";
"    results = {@results, {\"r\", i1, i2, res1, res2}};";
"  elseif (res1)";
"    results = {@results, {\"-\", i1, i2, res1}};";
"  elseif (res2)";
"    results = {@results, {\"+\", i1, i2, res2}};";
"  endif";
"";
"  last = pos;";
"endfor";
"";
"return results;";
"";
"chunk_length:45";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:878B1D1E76A186DC5F3F522323593AEC88D154FF";
"-=-=-mxyzptlk-=-=-";
.
#40:5
{lines1, lines2} = args;
intern = [];
{lines1, intern} = this:_hash_lines(lines1, intern);
{lines2, intern} = this:_hash_lines(lines2, intern);
lcs = this:_find_lcs(this:_find_common_unique_lines(lines1, lines2, intern));
return this:_generate_diff(lines1, lines2, lcs);
return;
"{lines1, lines2} = args;";
"";
"intern = [];";
"{lines1, intern} = this:_hash_lines(lines1, intern);";
"{lines2, intern} = this:_hash_lines(lines2, intern);";
"";
"lcs = this:_find_lcs(this:_find_common_unique_lines(lines1, lines2, intern));";
"";
"return this:_generate_diff(lines1, lines2, lcs);";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:80A42BCA22606876E26013750C479B574B5A3CC5";
"-=-=-mxyzptlk-=-=-";
.
#41:0
$restrict_to_caller($composed);
$external_compilers["application/x-moocode;version=1.0.*"] = this.manifest:to_map():invert()["compiler"];
return;
"$restrict_to_caller($composed);";
"$external_compilers[\"application/x-moocode;version=1.0.*\"] = this.manifest:to_map():invert()[\"compiler\"];";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:0B386F6BEE81FB4625109B9153554B3F3B15AF06";
"-=-=-mxyzptlk-=-=-";
.
#41:1
$restrict_to_caller($composed);
$external_compilers = $external_compilers:delete("application/x-moocode;version=1.0.*");
return;
"$restrict_to_caller($composed);";
"$external_compilers = $external_compilers:delete(\"application/x-moocode;version=1.0.*\");";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:E4446A239DCFF4FF1D9CF6457B90B8F5F8FC50E0";
"-=-=-mxyzptlk-=-=-";
.
#44:0
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
return;
"(ticks_left() < 10000 || seconds_left() < 2) && suspend(0);";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:C7B9AA9D4FFB81B732A30FE8DFCCB25794BD2172";
"-=-=-mxyzptlk-=-=-";
.
#44:1
{parser, separator, infix, terminator, ?symbols = {}} = args;
ids = {};
for symbol in (symbols)
ids = {@ids, parser:push(@symbol)};
endfor
if (terminator && (parser:token().id == terminator))
return {};
endif
key = parser:expression(0);
parser:advance(infix);
value = parser:expression(0);
MAP = {{key, value}};
while (parser:token().id == separator)
this:suspend_if_necessary();
MAP && parser:advance(separator);
key = parser:expression(0);
parser:advance(infix);
value = parser:expression(0);
MAP = {@MAP, {key, value}};
endwhile
for id in (ids)
parser:pop(id);
endfor
return MAP;
return;
"{parser, separator, infix, terminator, ?symbols = {}} = args;";
"";
"ids = {};";
"for symbol in (symbols)";
"  ids = {@ids, parser:push(@symbol)};";
"endfor";
"";
"if (terminator && parser:token().id == terminator)";
"  return {};";
"endif";
"";
"key = parser:expression(0);";
"parser:advance(infix);";
"value = parser:expression(0);";
"map = {{key, value}};";
"";
"while (parser:token().id == separator)";
"  this:suspend_if_necessary();";
"  map && parser:advance(separator);";
"  key = parser:expression(0);";
"  parser:advance(infix);";
"  value = parser:expression(0);";
"  map = {@map, {key, value}};";
"endwhile";
"";
"for id in (ids)";
"  parser:pop(id);";
"endfor";
"";
"return map;";
"";
"chunk_length:30";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:474311B60CEBDC2D767B8DBD4CD2945317515F00";
"-=-=-mxyzptlk-=-=-";
.
#44:2
{parser, separator, terminator, ?symbols = "defaults"} = args;
if (symbols && (symbols == "defaults"))
symbols = {{"@", 0, this.plastic.prefix_operator_proto}};
endif
ids = {};
for symbol in (symbols)
ids = {@ids, parser:push(@symbol)};
endfor
if (terminator && (parser:token().id == terminator))
return {};
endif
expression = parser:expression(0);
LIST = {expression};
while (parser:token().id == separator)
this:suspend_if_necessary();
parser:advance(separator);
expression = parser:expression(0);
LIST = {@LIST, expression};
endwhile
for id in (ids)
parser:pop(id);
endfor
return LIST;
return;
"{parser, separator, terminator, ?symbols = \"defaults\"} = args;";
"";
"/* enable defaults */";
"if (symbols && symbols == \"defaults\")";
"  symbols = {{\"@\", 0, this.plastic.prefix_operator_proto}};";
"endif";
"";
"ids = {};";
"for symbol in (symbols)";
"  ids = {@ids, parser:push(@symbol)};";
"endfor";
"";
"if (terminator && parser:token().id == terminator)";
"  return {};";
"endif";
"";
"expression = parser:expression(0);";
"list = {expression};";
"";
"while (parser:token().id == separator)";
"  this:suspend_if_necessary();";
"  parser:advance(separator);";
"  expression = parser:expression(0);";
"  list = {@list, expression};";
"endwhile";
"";
"for id in (ids)";
"  parser:pop(id);";
"endfor";
"";
"return list;";
"";
"chunk_length:31";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:6FEB895CC428DF005B46D141E6ABC5D9BDA89B83";
"-=-=-mxyzptlk-=-=-";
.
#44:3
{parser, pattern} = args;
state = 1;
for element in (pattern)
if ((state == 1) && (element.type == "variable"))
continue;
elseif ((((state == 1) || (state == 2)) && (element.type == "binary")) && (element.id == "="))
if (element.first.type == "variable")
state = 2;
continue;
endif
elseif ((((state == 1) || (state == 2)) && (element.type == "unary")) && (element.id == "@"))
if (element.first.type == "variable")
state = 3;
continue;
endif
endif
raise("Syntax error", "Illegal scattering pattern", parser);
endfor
return;
"{parser, pattern} = args;";
"";
"state = 1;";
"";
"for element in (pattern)";
"  if (state == 1 && element.type == \"variable\")";
"    continue;";
"  elseif ((state == 1 || state == 2) && element.type == \"binary\" && element.id == \"=\")";
"    if (element.first.type == \"variable\")";
"      state = 2;";
"      continue;";
"    endif";
"  elseif ((state == 1 || state == 2) && element.type == \"unary\" && element.id == \"@\")";
"    if (element.first.type == \"variable\")";
"      state = 3;";
"      continue;";
"    endif";
"  endif";
"";
"  raise(\"Syntax error\", \"Illegal scattering pattern\", parser);";
"endfor";
"";
"chunk_length:21";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:6DC3B53967446EAB01EE576267459D8598505807";
"-=-=-mxyzptlk-=-=-";
.
#44:4
{node} = args;
if (typeof(node) == LIST)
return node;
elseif (`typeof(value = node.value) == LIST ! ANY')
return value;
else
children = {};
for prop in ({"first", "second", "third"})
if (`value = node.(prop) ! E_PROPNF => 0' != 0)
children = {@children, value};
endif
endfor
return children;
endif
return;
"{node} = args;";
"";
"/* Intelligently gather children from various places.";
" */";
"";
"if (typeof(node) == LIST)";
"  return node;";
"elseif (`typeof(value = node.value) == LIST ! ANY')";
"  return value;";
"else";
"  children = {};";
"  for prop in ({\"first\", \"second\", \"third\"})";
"    if (`value = node.(prop) ! E_PROPNF => 0' != 0)";
"      children = {@children, value};";
"    endif";
"  endfor";
"  return children;";
"endif";
"";
"chunk_length:18";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:F9D17E1580E0ABE09BCBB3C38E32B585B4A9FC58";
"-=-=-mxyzptlk-=-=-";
.
#44:5
{root, pattern} = args;
keys = pattern:keys();
matches = {};
stack = {root};
while next (stack)
this:suspend_if_necessary();
{top, @stack} = stack;
stack = {@stack, @this:children(top)};
if ((typeof(top) == ANON) && isa(top, this.plastic.symbol_proto))
for key in (keys)
if (top.(key) != pattern[key])
continue next;
endif
endfor
matches = {@matches, top};
endif
endwhile
return matches;
return;
"{root, pattern} = args;";
"";
"/* Pattern is a map.  The keys specify the properties (`id', `type',";
" * etc.) to match on.  The values specify the property values for the";
" * match comparison.  Conducts a depth first search for pattern.";
" */";
"";
"keys = pattern:keys();";
"matches = {};";
"stack = {root};";
"";
"while next (stack)";
"  this:suspend_if_necessary();";
"  {top, @stack} = stack;";
"  stack = {@stack, @this:children(top)};";
"  if (typeof(top) == ANON && isa(top, this.plastic.symbol_proto))";
"    for key in (keys)";
"      if (top.(key) != pattern[key])";
"        continue next;";
"      endif";
"    endfor";
"    matches = {@matches, top};";
"  endif";
"endwhile";
"";
"return matches;";
"";
"chunk_length:26";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:E2FB22B3F5AED1A4B4755CC5BDBE7536492A30EE";
"-=-=-mxyzptlk-=-=-";
.
#45:0
(typeof(this) == OBJ) || raise(E_INVARG, "Callable on prototypes only");
return;
"(typeof(this) == OBJ) || raise(E_INVARG, \"Callable on prototypes only\");";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:BE6D82ABBC07073E4B29626E4EC88552C6CA9B06";
"-=-=-mxyzptlk-=-=-";
.
#45:1
(typeof(this) == ANON) || raise(E_INVARG, "Callable on instances only");
return;
"(typeof(this) == ANON) || raise(E_INVARG, \"Callable on instances only\");";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:2494F4E5D91036073E30C4AB6E329F50AFF52891";
"-=-=-mxyzptlk-=-=-";
.
#46:0
$private();
this:_ensure_instance();
{name} = args;
if (`value = this.variable_map[name] ! E_RANGE')
return value;
elseif ((name in this.variable_map) || (name in this.reserved_names))
value = name;
while ((value in this.variable_map) || (value in this.reserved_names))
value = tostr("_", value);
endwhile
this.variable_map[name] = value;
return value;
else
value = name;
this.variable_map[name] = value;
return value;
endif
return;
"$private();";
"";
"this:_ensure_instance();";
"";
"{name} = args;";
"";
"if (`value = this.variable_map[name] ! E_RANGE')";
"  return value;";
"elseif (name in this.variable_map || name in this.reserved_names)";
"  value = name;";
"  while (value in this.variable_map || value in this.reserved_names)";
"    value = tostr(\"_\", value);";
"  endwhile";
"  this.variable_map[name] = value;";
"  return value;";
"else";
"  value = name;";
"  this.variable_map[name] = value;";
"  return value;";
"endif";
"";
"chunk_length:20";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:8301AF25003B5DDDCAE06066BFEACAB8796887A5";
"-=-=-mxyzptlk-=-=-";
.
#46:1
$private();
this:_ensure_instance();
{name} = args;
if (`value = this.variable_map[name] ! E_RANGE')
return value;
else
value = tostr("_", random());
while ((value in this.variable_map) || (value in this.reserved_names))
value = tostr("_", random());
endwhile
this.variable_map[name] = value;
return value;
endif
return;
"$private();";
"";
"this:_ensure_instance();";
"";
"{name} = args;";
"";
"if (`value = this.variable_map[name] ! E_RANGE')";
"  return value;";
"else";
"  value = tostr(\"_\", random());";
"  while (value in this.variable_map || value in this.reserved_names)";
"    value = tostr(\"_\", random());";
"  endwhile";
"  this.variable_map[name] = value;";
"  return value;";
"endif";
"";
"chunk_length:16";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:02D253B3D9562CB07EB8FDD81363E5CBEF6F5C62";
"-=-=-mxyzptlk-=-=-";
.
#46:2
this:_ensure_prototype();
{source, ?options = []} = args;
tokenizer = this.plastic.tokenizer_proto:create(source);
parser = this.plastic.parser_proto:create(tokenizer);
compiler = create(this, 1);
try
statements = parser:statements();
except ex (ANY)
return {0, {tostr("Line ", ex[3].tokenizer.row, ":  ", ex[2])}};
endtry
source = {};
for statement in (statements)
if (statement.type != "statement")
source = {@source, tostr(compiler:p(statement), ";")};
else
source = {@source, @compiler:p(statement)};
endif
endfor
return {1, source};
return;
"this:_ensure_prototype();";
"";
"{source, ?options = []} = args;";
"";
"tokenizer = this.plastic.tokenizer_proto:create(source);";
"parser = this.plastic.parser_proto:create(tokenizer);";
"compiler = create(this, 1);";
"";
"try";
"  statements = parser:statements();";
"except ex (ANY)";
"  return {0, {tostr(\"Line \", ex[3].tokenizer.row, \":  \", ex[2])}};";
"endtry";
"";
"source = {};";
"";
"for statement in (statements)";
"  if (statement.type != \"statement\")";
"    source = {@source, tostr(compiler:p(statement), \";\")};";
"  else";
"    source = {@source, @compiler:p(statement)};";
"  endif";
"endfor";
"";
"return {1, source};";
"";
"chunk_length:25";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:0AC290B9993C10FB1DCA7BBA94C7CB2C7C6C9665";
"-=-=-mxyzptlk-=-=-";
.
#46:3
this:_ensure_instance();
{statement} = args;
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
if (statement.type == "variable")
return this:_lookup(statement.value);
elseif (statement.type == "unique")
return this:_generate(statement.value);
elseif (isa(statement, this.plastic.sign_operator_proto))
if (statement.type == "unary")
return tostr((statement.value == "-") ? "-" | "", this:p(statement.first));
else
return tostr("(", this:p(statement.first), " ", statement.value, " ", this:p(statement.second), ")");
endif
elseif (isa(statement, this.plastic.control_flow_statement_proto))
if ((first = statement.first) != 0)
return {tostr(statement.id, " ", this:p(first), ";")};
else
return {tostr(statement.id, ";")};
endif
elseif (isa(statement, this.plastic.if_statement_proto))
value = statement.value;
code = {tostr("if (", this:p(value[1]), ")")};
for s in (value[2])
if (respond_to(s, "std"))
code = {@code, @this:p(s)};
else
code = {@code, this:p(s) + ";"};
endif
endfor
i = 3;
while ((length(value) >= i) && (typeof(value[i]) != LIST))
code = {@code, tostr("elseif (", this:p(value[i]), ")")};
i = i + 1;
for s in (value[i])
if (respond_to(s, "std"))
code = {@code, @this:p(s)};
else
code = {@code, this:p(s) + ";"};
endif
endfor
i = i + 1;
endwhile
if (length(value) == i)
code = {@code, "else"};
for s in (value[i])
if (respond_to(s, "std"))
code = {@code, @this:p(s)};
else
code = {@code, this:p(s) + ";"};
endif
endfor
endif
code = {@code, "endif"};
return code;
elseif (isa(statement, this.plastic.for_statement_proto))
value = statement.value;
if (statement.subtype == "range")
code = {tostr("for ", this:p(value[1]), " in [", this:p(value[2]), "..", this:p(value[3]), "]")};
statements = value[4];
elseif (length(value) == 4)
code = {tostr("for ", this:p(value[1]), ", ", this:p(value[2]), " in (", this:p(value[3]), ")")};
statements = value[4];
else
code = {tostr("for ", this:p(value[1]), " in (", this:p(value[2]), ")")};
statements = value[3];
endif
for s in (statements)
if (respond_to(s, "std"))
code = {@code, @this:p(s)};
else
code = {@code, this:p(s) + ";"};
endif
endfor
code = {@code, "endfor"};
return code;
elseif (isa(statement, this.plastic.loop_statement_proto))
value = statement.value;
i = 0;
if (length(value) > 2)
prefix = tostr("while ", this:p(value[i = i + 1]));
else
prefix = tostr("while");
endif
if (statement.id == "while")
code = {tostr(prefix, " (", this:p(value[i = i + 1]), ")")};
else
code = {tostr(prefix, " (!(", this:p(value[i = i + 1]), "))")};
endif
for s in (value[i = i + 1])
if (respond_to(s, "std"))
code = {@code, @this:p(s)};
else
code = {@code, this:p(s) + ";"};
endif
endfor
code = {@code, "endwhile"};
return code;
elseif (isa(statement, this.plastic.fork_statement_proto))
value = statement.value;
i = 0;
if (length(value) > 2)
code = {tostr("fork ", this:p(value[i = i + 1]), " (", this:p(value[i = i + 1]), ")")};
else
code = {tostr("fork", " (", this:p(value[i = i + 1]), ")")};
endif
for s in (value[i = i + 1])
if (respond_to(s, "std"))
code = {@code, @this:p(s)};
else
code = {@code, this:p(s) + ";"};
endif
endfor
code = {@code, "endfork"};
return code;
elseif (isa(statement, this.plastic.try_statement_proto))
value = statement.value;
code = {"try"};
for s in (value[1])
if (respond_to(s, "std"))
code = {@code, @this:p(s)};
else
code = {@code, this:p(s) + ";"};
endif
endfor
if (statement.subtype == "finally")
code = {@code, "finally"};
for s in (value[2])
if (respond_to(s, "std"))
code = {@code, @this:p(s)};
else
code = {@code, this:p(s) + ";"};
endif
endfor
else
for value in (value[2..$])
if (length(value) == 3)
x = {};
for s in (value[2])
x = {@x, this:p(s)};
endfor
code = {@code, tostr("except ", this:p(value[1]), " (", x:join(", "), ")")};
statements = value[3];
else
x = {};
for s in (value[1])
x = {@x, this:p(s)};
endfor
code = {@code, tostr("except (", x:join(", "), ")")};
statements = value[2];
endif
for s in (statements)
if (respond_to(s, "std"))
code = {@code, @this:p(s)};
else
code = {@code, this:p(s) + ";"};
endif
endfor
endfor
endif
code = {@code, "endtry"};
return code;
elseif (isa(statement, this.plastic.assignment_operator_proto))
if (statement.first.type == "pattern")
res = "{";
rest = 0;
for v in (statement.first.value)
if (v.type == "unary")
v = tostr("@", this:p(v.first));
elseif (v.type == "binary")
v = tostr("?", this:p(v.first), " = ", this:p(v.second));
else
v = this:p(v);
endif
res = tostr(res, rest ? ", " | "", v);
rest = 1;
endfor
res = tostr(res, "}");
return tostr("(", res, " ", statement.value, " ", this:p(statement.second), ")");
else
return tostr("(", this:p(statement.first), " ", statement.value, " ", this:p(statement.second), ")");
endif
elseif (isa(statement, this.plastic.bracket_operator_proto))
if (statement.type == "ternary")
return tostr("(", this:p(statement.first), "[", this:p(statement.second), "..", this:p(statement.third), "])");
elseif (statement.type == "binary")
return tostr("(", this:p(statement.first), "[", this:p(statement.second), "])");
else
res = "[";
first = 1;
for v in (statement.value)
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
res = tostr(res, first ? "" | ", ", this:p(v[1]), " -> ", this:p(v[2]));
first = 0;
endfor
res = tostr(res, "]");
return res;
return {res};
endif
elseif (isa(statement, this.plastic.brace_operator_proto))
res = "{";
first = 1;
for v in (statement.value)
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
res = tostr(res, first ? "" | ", ", this:p(v));
first = 0;
endfor
res = tostr(res, "}");
return res;
elseif (isa(statement, this.plastic.invocation_operator_proto))
if (statement.type == "ternary")
a = {};
for v in (statement.third)
a = {@a, this:p(v)};
endfor
if (statement.second.type == "identifier")
return tostr(this:p(statement.first), ":", this:p(statement.second), "(", a:join(", "), ")");
else
return tostr(this:p(statement.first), ":(", this:p(statement.second), ")(", a:join(", "), ")");
endif
elseif (statement.type == "binary")
a = {};
for v in (statement.second)
a = {@a, this:p(v)};
endfor
return tostr(this:p(statement.first), "(", a:join(", "), ")");
else
return tostr(this:p(statement.first));
endif
elseif (isa(statement, this.plastic.property_selector_operator_proto))
if (statement.second.type == "identifier")
return tostr(this:p(statement.first), ".", this:p(statement.second));
else
return tostr(this:p(statement.first), ".(", this:p(statement.second) + ")");
endif
elseif (isa(statement, this.plastic.error_catching_operator_proto))
if (statement.type == "unary")
return tostr(statement.value, this:p(statement.first));
endif
x = {};
for s in (statement.second)
x = {@x, this:p(s)};
endfor
second = x:join(", ");
if (statement.type == "ternary")
return tostr("`", this:p(statement.first), " ! ", second, " => ", this:p(statement.third), "'");
else
return tostr("`", this:p(statement.first), " ! ", second, "'");
endif
elseif (isa(statement, this.plastic.literal_proto))
return toliteral(statement.value);
elseif (isa(statement, this.plastic.positional_symbol_proto))
return statement.value;
elseif (isa(statement, this.plastic.prefix_operator_proto))
return tostr(statement.value, this:p(statement.first));
elseif (isa(statement, this.plastic.infix_operator_proto))
value = statement.value;
value = (value != "**") ? value | "^";
return tostr("(", this:p(statement.first), " ", value, " ", this:p(statement.second), ")");
elseif (isa(statement, this.plastic.traditional_ternary_operator_proto))
return tostr("(", this:p(statement.first), " ? ", this:p(statement.second), " | ", this:p(statement.third), ")");
elseif (isa(statement, this.plastic.name_proto))
return statement.value;
else
raise(E_INVARG);
endif
return;
"this:_ensure_instance();";
"";
"{statement} = args;";
"";
"ticks_left() < 10000 || seconds_left() < 2 && suspend(0);";
"";
"if (statement.type == \"variable\")";
"  return this:_lookup(statement.value);";
"elseif (statement.type == \"unique\")";
"  return this:_generate(statement.value);";
"elseif (isa(statement, this.plastic.sign_operator_proto))";
"  if (statement.type == \"unary\")";
"    return tostr(statement.value == \"-\" ? \"-\" | \"\", this:p(statement.first));";
"  else";
"    return tostr(\"(\", this:p(statement.first), \" \", statement.value, \" \", this:p(statement.second), \")\");";
"  endif";
"";
"elseif (isa(statement, this.plastic.control_flow_statement_proto))";
"  if ((first = statement.first) != 0)";
"    return {tostr(statement.id, \" \" , this:p(first), \";\")};";
"  else";
"    return {tostr(statement.id, \";\")};";
"  endif";
"";
"elseif (isa(statement, this.plastic.if_statement_proto))";
"  value =  statement.value;";
"";
"  code = {tostr(\"if (\", this:p(value[1]), \")\")};";
"";
"  for s in (value[2])";
"    if (respond_to(s, \"std\"))";
"      code = {@code, @this:p(s)};";
"    else";
"      code = {@code, this:p(s) + \";\"};";
"    endif";
"  endfor";
"";
"  i = 3;";
"  while (length(value) >= i && typeof(value[i]) != LIST)";
"    code = {@code, tostr(\"elseif (\", this:p(value[i]), \")\")};";
"";
"    i = i + 1;";
"";
"    for s in (value[i])";
"      if (respond_to(s, \"std\"))";
"        code = {@code, @this:p(s)};";
"      else";
"        code = {@code, this:p(s) + \";\"};";
"      endif";
"    endfor";
"";
"    i = i + 1;";
"  endwhile";
"";
"  if (length(value) == i)";
"    code = {@code, \"else\"};";
"";
"    for s in (value[i])";
"      if (respond_to(s, \"std\"))";
"        code = {@code, @this:p(s)};";
"      else";
"        code = {@code, this:p(s) + \";\"};";
"      endif";
"    endfor";
"  endif";
"";
"  code = {@code, \"endif\"};";
"";
"  return code;";
"";
"elseif (isa(statement, this.plastic.for_statement_proto))";
"  value =  statement.value;";
"";
"  if (statement.subtype == \"range\")";
"    code = {tostr(\"for \", this:p(value[1]), \" in [\", this:p(value[2]), \"..\", this:p(value[3]), \"]\")};";
"    statements = value[4];";
"  elseif (length(value) == 4)";
"    code = {tostr(\"for \", this:p(value[1]), \", \", this:p(value[2]), \" in (\", this:p(value[3]), \")\")};";
"    statements = value[4];";
"  else";
"    code = {tostr(\"for \", this:p(value[1]), \" in (\", this:p(value[2]), \")\")};";
"    statements = value[3];";
"  endif";
"";
"  for s in (statements)";
"    if (respond_to(s, \"std\"))";
"      code = {@code, @this:p(s)};";
"    else";
"      code = {@code, this:p(s) + \";\"};";
"    endif";
"  endfor";
"";
"  code = {@code, \"endfor\"};";
"";
"  return code;";
"";
"elseif (isa(statement, this.plastic.loop_statement_proto))";
"  value =  statement.value;";
"";
"  i = 0;";
"";
"  if (length(value) > 2)";
"    prefix = tostr(\"while \", this:p(value[i = i + 1]));";
"  else";
"    prefix = tostr(\"while\");";
"  endif";
"";
"  if (statement.id == \"while\")";
"    code = {tostr(prefix, \" (\", this:p(value[i = i + 1]), \")\")};";
"  else";
"    code = {tostr(prefix, \" (!(\", this:p(value[i = i + 1]), \"))\")};";
"  endif";
"";
"  for s in (value[i = i + 1])";
"    if (respond_to(s, \"std\"))";
"      code = {@code, @this:p(s)};";
"    else";
"      code = {@code, this:p(s) + \";\"};";
"    endif";
"  endfor";
"";
"  code = {@code, \"endwhile\"};";
"";
"  return code;";
"";
"elseif (isa(statement, this.plastic.fork_statement_proto))";
"  value =  statement.value;";
"";
"  i = 0;";
"";
"  if (length(value) > 2)";
"    code = {tostr(\"fork \", this:p(value[i = i + 1]), \" (\", this:p(value[i = i + 1]), \")\")};";
"  else";
"    code = {tostr(\"fork\", \" (\", this:p(value[i = i + 1]), \")\")};";
"  endif";
"";
"  for s in (value[i = i + 1])";
"    if (respond_to(s, \"std\"))";
"      code = {@code, @this:p(s)};";
"    else";
"      code = {@code, this:p(s) + \";\"};";
"    endif";
"  endfor";
"";
"  code = {@code, \"endfork\"};";
"";
"  return code;";
"";
"elseif (isa(statement, this.plastic.try_statement_proto))";
"  value =  statement.value;";
"";
"  code = {\"try\"};";
"";
"  for s in (value[1])";
"    if (respond_to(s, \"std\"))";
"      code = {@code, @this:p(s)};";
"    else";
"      code = {@code, this:p(s) + \";\"};";
"    endif";
"  endfor";
"";
"  if (statement.subtype == \"finally\")";
"    code = {@code, \"finally\"};";
"";
"    for s in (value[2])";
"      if (respond_to(s, \"std\"))";
"        code = {@code, @this:p(s)};";
"      else";
"        code = {@code, this:p(s) + \";\"};";
"      endif";
"    endfor";
"";
"  else";
"    for value in (value[2..$])";
"      if (length(value) == 3)";
"        x = {};";
"        for s in (value[2])";
"          x = {@x, this:p(s)};";
"        endfor";
"";
"        code = {@code, tostr(\"except \", this:p(value[1]), \" (\", x:join(\", \"), \")\")};";
"        statements = value[3];";
"";
"      else";
"        x = {};";
"        for s in (value[1])";
"          x = {@x, this:p(s)};";
"        endfor";
"";
"        code = {@code, tostr(\"except (\", x:join(\", \"), \")\")};";
"        statements = value[2];";
"";
"      endif";
"";
"      for s in (statements)";
"        if (respond_to(s, \"std\"))";
"          code = {@code, @this:p(s)};";
"        else";
"          code = {@code, this:p(s) + \";\"};";
"        endif";
"      endfor";
"";
"    endfor";
"  endif";
"";
"  code = {@code, \"endtry\"};";
"";
"  return code;";
"";
"elseif (isa(statement, this.plastic.assignment_operator_proto))";
"  if (statement.first.type == \"pattern\")";
"    res = \"{\";";
"    rest = 0;";
"    for v in (statement.first.value)";
"      if (v.type == \"unary\")";
"        v = tostr(\"@\", this:p(v.first));";
"      elseif (v.type == \"binary\")";
"        v = tostr(\"?\", this:p(v.first), \" = \", this:p(v.second));";
"      else";
"        v = this:p(v);";
"      endif";
"      res = tostr(res, (rest ? \", \" | \"\"), v);";
"      rest = 1;";
"    endfor";
"    res = tostr(res, \"}\");";
"    return tostr(\"(\", res, \" \", statement.value, \" \", this:p(statement.second), \")\");";
"  else";
"    return tostr(\"(\", this:p(statement.first), \" \", statement.value, \" \", this:p(statement.second), \")\");";
"  endif";
"";
"elseif (isa(statement, this.plastic.bracket_operator_proto))";
"  if (statement.type == \"ternary\")";
"    return tostr(\"(\", this:p(statement.first), \"[\", this:p(statement.second), \"..\", this:p(statement.third), \"])\");";
"  elseif (statement.type == \"binary\")";
"    return tostr(\"(\", this:p(statement.first), \"[\", this:p(statement.second), \"])\");";
"  else";
"    res = \"[\";";
"    first = 1;";
"    for v in (statement.value)";
"      ticks_left() < 10000 || seconds_left() < 2 && suspend(0);";
"      res = tostr(res, (first ? \"\" | \", \"), this:p(v[1]), \" -> \", this:p(v[2]));";
"      first = 0;";
"    endfor";
"    res = tostr(res, \"]\");";
"    return res;";
"    return {res};";
"  endif";
"";
"elseif (isa(statement, this.plastic.brace_operator_proto))";
"  res = \"{\";";
"  first = 1;";
"  for v in (statement.value)";
"    ticks_left() < 10000 || seconds_left() < 2 && suspend(0);";
"    res = tostr(res, (first ? \"\" | \", \"), this:p(v));";
"    first = 0;";
"  endfor";
"  res = tostr(res, \"}\");";
"  return res;";
"";
"elseif (isa(statement, this.plastic.invocation_operator_proto))";
"  if (statement.type == \"ternary\")";
"    a = {};";
"    for v in (statement.third)";
"      a = {@a, this:p(v)};";
"    endfor";
"    if (statement.second.type == \"identifier\")";
"      return tostr(this:p(statement.first), \":\", this:p(statement.second), \"(\", a:join(\", \"), \")\");";
"    else";
"      return tostr(this:p(statement.first), \":(\", this:p(statement.second), \")(\", a:join(\", \"), \")\");";
"    endif";
"  elseif (statement.type == \"binary\")";
"    a = {};";
"    for v in (statement.second)";
"      a = {@a, this:p(v)};";
"    endfor";
"    return tostr(this:p(statement.first), \"(\", a:join(\", \"), \")\");";
"  else";
"    return tostr(this:p(statement.first));";
"  endif";
"";
"elseif (isa(statement, this.plastic.property_selector_operator_proto))";
"  if (statement.second.type == \"identifier\")";
"    return tostr(this:p(statement.first), \".\", this:p(statement.second));";
"  else";
"    return tostr(this:p(statement.first), \".(\", this:p(statement.second) + \")\");";
"  endif";
"";
"elseif (isa(statement, this.plastic.error_catching_operator_proto))";
"  if (statement.type == \"unary\")";
"    return tostr(statement.value, this:p(statement.first));";
"  endif";
"";
"  x = {};";
"  for s in (statement.second)";
"    x = {@x, this:p(s)};";
"  endfor";
"";
"  second = x:join(\", \");";
"";
"  if (statement.type == \"ternary\")";
"    return tostr(\"`\", this:p(statement.first), \" ! \", second, \" => \", this:p(statement.third), \"'\");";
"  else";
"    return tostr(\"`\", this:p(statement.first), \" ! \", second, \"'\");";
"  endif";
"";
"elseif (isa(statement, this.plastic.literal_proto))";
"  return toliteral(statement.value);";
"elseif (isa(statement, this.plastic.positional_symbol_proto))";
"  return statement.value;";
"elseif (isa(statement, this.plastic.prefix_operator_proto))";
"  return tostr(statement.value, this:p(statement.first));";
"elseif (isa(statement, this.plastic.infix_operator_proto))";
"  value = statement.value;";
"  value = (value != \"**\") ? value | \"^\";";
"  return tostr(\"(\", this:p(statement.first), \" \", value, \" \", this:p(statement.second), \")\");";
"elseif (isa(statement, this.plastic.traditional_ternary_operator_proto))";
"  return tostr(\"(\", this:p(statement.first), \" ? \", this:p(statement.second), \" | \", this:p(statement.third), \")\");";
"elseif (isa(statement, this.plastic.name_proto))";
"  return statement.value;";
"else";
"  raise(E_INVARG);";
"endif";
"";
"chunk_length:322";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:67D036011B33B8DE5FF6C910693AA9CC4E945B98";
"-=-=-mxyzptlk-=-=-";
.
#47:0
{statement, ?indent = ""} = args;
if (typeof(statement) == LIST)
result = {tostr(indent, "-")};
for item in (statement)
result = {@result, @this:_print(item, indent + "  ")};
endfor
return result;
endif
if (`typeof(statement.value) == LIST ! ANY')
result = {tostr(indent, statement.id, " : ", statement.type)};
for value in (statement.value)
result = {@result, @this:_print(value, indent + "  ")};
endfor
else
result = {tostr(indent, (typeof(statement.value) == ERR) ? toliteral(statement.value) | statement.value, " : ", statement.type)};
for prop in ({"first", "second", "third"})
if ((`value = statement.(prop) ! E_PROPNF' != E_PROPNF) && (value != 0))
result = {@result, @this:_print(value, indent + "  ")};
endif
endfor
endif
return result;
return;
"{statement, ?indent = \"\"} = args;";
"";
"if (typeof(statement) == LIST)";
"  result = {tostr(indent, \"-\")};";
"";
"  for item in (statement)";
"    result = {@result, @this:_print(item, indent + \"  \")};";
"  endfor";
"";
"  return result;";
"endif";
"";
"if (`typeof(statement.value) == LIST ! ANY')";
"  result = {tostr(indent, statement.id, \" : \", statement.type)};";
"";
"  for value in (statement.value)";
"    result = {@result, @this:_print(value, indent + \"  \")};";
"  endfor";
"else";
"  result = {tostr(indent, typeof(statement.value) == ERR ? toliteral(statement.value) | statement.value, \" : \", statement.type)};";
"";
"  for prop in ({\"first\", \"second\", \"third\"})";
"    if (`value = statement.(prop) ! E_PROPNF' != E_PROPNF && value != 0)";
"      result = {@result, @this:_print(value, indent + \"  \")};";
"    endif";
"  endfor";
"endif";
"";
"return result;";
"";
"chunk_length:29";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:67068C3DEAFED07576F5AE9A4A94AE664A9EF238";
"-=-=-mxyzptlk-=-=-";
.
#47:1
{source, ?options = []} = args;
tokenizer = this.plastic.tokenizer_proto:create(source);
parser = this.plastic.parser_proto:create(tokenizer);
statements = parser:statements();
source = {};
for statement in (statements)
source = {@source, @this:_print(statement)};
endfor
return source;
return;
"{source, ?options = []} = args;";
"";
"tokenizer = this.plastic.tokenizer_proto:create(source);";
"parser = this.plastic.parser_proto:create(tokenizer);";
"";
"statements = parser:statements();";
"";
"source = {};";
"";
"for statement in (statements)";
"  source = {@source, @this:_print(statement)};";
"endfor";
"";
"return source;";
"";
"chunk_length:14";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:2A38FC7355668CD5D2C874FC93127BF0A0B9F786";
"-=-=-mxyzptlk-=-=-";
.
#48:0
this:_ensure_prototype();
instance = create(this, 1);
instance.row = 1;
instance.column = 1;
instance.source = ((length(args) == 1) && (typeof(args[1]) == LIST)) ? args[1] | args;
return instance;
return;
"this:_ensure_prototype();";
"";
"instance = create(this, 1);";
"";
"instance.row = 1;";
"instance.column = 1;";
"instance.source = (length(args) == 1 && typeof(args[1]) == LIST) ? args[1] | args;";
"";
"return instance;";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:FF59BCA3B71DAD9EAE30F0144CEA202F76B8B97C";
"-=-=-mxyzptlk-=-=-";
.
#48:1
this:_ensure_instance();
this.token = 0;
if (!this.source)
return this;
endif
row = this.row;
column = this.column;
source = this.source;
first = this.first;
block_comment = 0;
inline_comment = 0;
while loop (length(source) >= row)
this.plastic.utilities:suspend_if_necessary();
if (column > (len = length(source[row])))
if (this.token)
this.token["eol"] = 1;
endif
inline_comment = 0;
row = row + 1;
column = 1;
first = 1;
continue loop;
endif
next_two = (len > column) ? source[row][column..column + 1] | "";
if (block_comment && (next_two == "*/"))
block_comment = 0;
column = column + 2;
continue loop;
elseif (next_two == "/*")
block_comment = 1;
column = column + 2;
continue loop;
elseif (next_two == "//")
inline_comment = 1;
column = column + 2;
continue loop;
endif
if (block_comment || inline_comment)
column = column + 1;
continue loop;
endif
if ((len >= column) && (((c = source[row][column]:asc()) == 32) || (c == 9)))
column = column + 1;
continue loop;
endif
if (this.token)
break loop;
endif
if (`c = source[row][column] ! E_RANGE')
if ((((c >= "a") && (c <= "z")) || (c == "_")) || (c == "$"))
col1 = column;
column = column + 1;
while (`c = source[row][column] ! E_RANGE')
if ((((c >= "a") && (c <= "z")) || ((c >= "0") && (c <= "9"))) || (c == "_"))
column = column + 1;
else
break;
endif
endwhile
col2 = column - 1;
chars = source[row][col1..col2];
if (index(chars, "E_") == 1)
try
this.token = ["sol" -> first, "eol" -> 0, "type" -> "error", "value" -> this.errors[chars]];
except ex (E_RANGE)
this.token = ["sol" -> first, "eol" -> 0, "type" -> "error", "value" -> chars, "error" -> tostr("Invalid error: ", chars)];
endtry
else
this.token = ["sol" -> first, "eol" -> 0, "type" -> "name", "value" -> chars];
endif
elseif (c == "#")
col1 = column;
column = column + 1;
if (`c = source[row][column] ! E_RANGE')
if ((c == "+") || (c == "-"))
column = column + 1;
endif
endif
while (`c = source[row][column] ! E_RANGE')
if ((c >= "0") && (c <= "9"))
column = column + 1;
else
break;
endif
endwhile
col2 = column - 1;
chars = source[row][col1..col2];
if ((chars[$] < "0") || (chars[$] > "9"))
this.token = ["sol" -> first, "eol" -> 0, "type" -> "object", "value" -> chars, "error" -> "Bad object number"];
elseif ((c >= "a") && (c <= "z"))
this.token = ["sol" -> first, "eol" -> 0, "type" -> "object", "value" -> chars + c, "error" -> "Bad object number"];
else
this.token = ["sol" -> first, "eol" -> 0, "type" -> "object", "value" -> toobj(chars)];
endif
elseif ((c >= "0") && (c <= "9"))
FLOAT = 0;
col1 = column;
column = column + 1;
while (`c = source[row][column] ! E_RANGE')
if ((c >= "0") && (c <= "9"))
column = column + 1;
else
break;
endif
endwhile
if ((c == ".") && ((cc = `source[row][column + 1] ! E_RANGE') != "."))
FLOAT = 1;
column = column + 1;
while (`c = source[row][column] ! E_RANGE')
if ((c >= "0") && (c <= "9"))
column = column + 1;
else
break;
endif
endwhile
endif
if (c == "e")
FLOAT = 1;
column = column + 1;
if (`c = source[row][column] ! E_RANGE' && (c in {"-", "+"}))
column = column + 1;
endif
while (`c = source[row][column] ! E_RANGE')
if ((c >= "0") && (c <= "9"))
column = column + 1;
else
break;
endif
endwhile
endif
col2 = column - 1;
chars = source[row][col1..col2];
if (((chars[$] < "0") || (chars[$] > "9")) && (chars[$] != "."))
this.token = ["sol" -> first, "eol" -> 0, "type" -> "number", "value" -> chars, "error" -> "Bad number"];
elseif ((c >= "a") && (c <= "z"))
this.token = ["sol" -> first, "eol" -> 0, "type" -> "number", "value" -> chars + c, "error" -> "Bad number"];
else
this.token = ["sol" -> first, "eol" -> 0, "type" -> "number", "value" -> FLOAT ? tofloat(chars) | toint(chars)];
endif
elseif ((c == "\"") || (c == "'"))
esc = 0;
chars = "";
q = c;
col1 = column;
column = column + 1;
while (`c = source[row][column] ! E_RANGE' && ((c != q) || esc))
column = column + 1;
if ((c != "\\") || esc)
chars = tostr(chars, c);
esc = 0;
else
esc = 1;
endif
endwhile
column = column + 1;
col2 = column - 1;
if (c != q)
this.token = ["sol" -> first, "eol" -> 0, "type" -> "string", "value" -> source[row][col1..col2 - 1], "error" -> "Unterminated string"];
else
this.token = ["sol" -> first, "eol" -> 0, "type" -> "string", "value" -> chars];
endif
elseif (index("-+<>=*/%!|&.", c))
col1 = column;
column = column + 1;
if (`c = source[row][column] ! E_RANGE' && index(">=*!|&.", c))
column = column + 1;
this.token = ["sol" -> first, "eol" -> 0, "type" -> "operator", "value" -> source[row][col1..column - 1]];
else
this.token = ["sol" -> first, "eol" -> 0, "type" -> "operator", "value" -> source[row][col1]];
endif
else
column = column + 1;
this.token = ["sol" -> first, "eol" -> 0, "type" -> "operator", "value" -> c];
endif
first = 0;
endif
endwhile
this.row = row;
this.column = column;
this.source = source;
this.first = first;
if (block_comment)
this.token = ["sol" -> 0, "eol" -> 0, "type" -> "comment", "value" -> "", "error" -> "Unterminated comment"];
endif
if ((this.token && (this.token["type"] == "name")) && (this.token["value"] == "$"))
this.token["type"] = "operator";
endif
return this;
return;
"this:_ensure_instance();";
"";
"this.token = 0;";
"";
"if (!this.source)";
"  return this;";
"endif";
"";
"row = this.row;";
"column = this.column;";
"source = this.source;";
"first = this.first;";
"";
"block_comment = 0;";
"inline_comment = 0;";
"";
"while loop (length(source) >= row)";
"";
"  this.plastic.utilities:suspend_if_necessary();";
"";
"  /* Determine whether the current token is at the end of a line or not";
"   * by scanning forward until we either run out of whitespace and";
"   * comments or hit the end of the line.";
"   */";
"  /* A consequence of this design is that we suck up whitespace and";
"   * comments _after_ finding a token, and (except for the first time";
"   * through) we _start_ at the row/column of the next token.  We also";
"   * go through the loop at least twice: once to find the token, and";
"   * again to suck up whitespace and comments.";
"   */";
"";
"  /* handle end of line */";
"  if (column > (len = length(source[row])))";
"    if (this.token)";
"      this.token[\"eol\"] = 1;";
"    endif";
"    inline_comment = 0;";
"    row = row + 1;";
"    column = 1;";
"    first = 1;";
"    continue loop;";
"  endif";
"";
"  /* if possible, grab two more characters */";
"  next_two = len > column ? source[row][column..column + 1] | \"\";";
"";
"  /* and test for comment delimiters */";
"  if (block_comment && next_two == \"*/\")";
"    block_comment = 0;";
"    column = column + 2;";
"    continue loop;";
"  elseif (next_two == \"/*\")";
"    block_comment = 1;";
"    column = column + 2;";
"    continue loop;";
"  elseif (next_two == \"//\")";
"    inline_comment = 1;";
"    column = column + 2;";
"    continue loop;";
"  endif";
"";
"  if (block_comment || inline_comment)";
"    column = column + 1;";
"    continue loop;";
"  endif";
"";
"  /* skip spaces and tabs */";
"  if (len >= column && ((c = source[row][column]:asc()) == 32 || c == 9))";
"    column = column + 1;";
"    continue loop;";
"  endif";
"";
"  if (this.token)";
"    break loop;";
"  endif";
"";
"  if (`c = source[row][column] ! E_RANGE')";
"";
"    /* name and error */";
"    /* MOO error literals look like names but they're not.  Worse, a";
"     * valid error like E_PERM is treated like a literal, while an";
"     * invalid error like E_FOO is treated like a variable.  Any name";
"     * that starts with the characters \"E_\" is *now* an error literal,";
"     * but invalid errors are errors.";
"     */";
"    if ((c >= \"a\" && c <= \"z\") || c == \"_\" || c == \"$\")";
"      col1 = column; /* mark the start */";
"      column = column + 1;";
"      while (`c = source[row][column] ! E_RANGE')";
"        if ((c >= \"a\" && c <= \"z\") || (c >= \"0\" && c <= \"9\") || c == \"_\")";
"          column = column + 1;";
"        else";
"          break;";
"        endif";
"      endwhile";
"      col2 = column - 1;";
"      chars = source[row][col1..col2];";
"      if (index(chars, \"E_\") == 1)";
"        try";
"          this.token = [\"sol\" -> first, \"eol\" -> 0, \"type\" -> \"error\", \"value\" -> this.errors[chars]];";
"        except ex (E_RANGE)";
"          this.token = [\"sol\" -> first, \"eol\" -> 0, \"type\" -> \"error\", \"value\" -> chars, \"error\" -> tostr(\"Invalid error: \", chars)];";
"        endtry";
"      else";
"        this.token = [\"sol\" -> first, \"eol\" -> 0, \"type\" -> \"name\", \"value\" -> chars];";
"      endif";
"";
"    /* object number */";
"    elseif (c == \"#\")";
"      col1 = column; /* mark the start */";
"      column = column + 1;";
"      if (`c = source[row][column] ! E_RANGE')";
"        if (c == \"+\" || c == \"-\")";
"          column = column + 1;";
"        endif";
"      endif";
"      while (`c = source[row][column] ! E_RANGE')";
"        if (c >= \"0\" && c <= \"9\")";
"          column = column + 1;";
"        else";
"          break;";
"        endif";
"      endwhile";
"      col2 = column - 1;";
"      chars = source[row][col1..col2];";
"      if (chars[$] < \"0\" || chars[$] > \"9\")";
"        this.token = [\"sol\" -> first, \"eol\" -> 0, \"type\" -> \"object\", \"value\" -> chars, \"error\" -> \"Bad object number\"];";
"      elseif (c >= \"a\" && c <= \"z\")";
"        this.token = [\"sol\" -> first, \"eol\" -> 0, \"type\" -> \"object\", \"value\" -> chars + c, \"error\" -> \"Bad object number\"];";
"      else";
"        this.token = [\"sol\" -> first, \"eol\" -> 0, \"type\" -> \"object\", \"value\" -> toobj(chars)];";
"      endif";
"";
"    /* number */";
"    elseif (c >= \"0\" && c <= \"9\")";
"      float = 0;";
"      col1 = column; /* mark the start */";
"      column = column + 1;";
"      while (`c = source[row][column] ! E_RANGE')";
"        if (c >= \"0\" && c <= \"9\")";
"          column = column + 1;";
"        else";
"          break;";
"        endif";
"      endwhile";
"      if (c == \".\" && ((cc = `source[row][column + 1] ! E_RANGE') != \".\")) /* not `..' */";
"        float = 1;";
"        column = column + 1;";
"        while (`c = source[row][column] ! E_RANGE')";
"          if (c >= \"0\" && c <= \"9\")";
"            column = column + 1;";
"          else";
"            break;";
"          endif";
"        endwhile";
"      endif";
"      if (c == \"e\")";
"        float = 1;";
"        column = column + 1;";
"        if (`c = source[row][column] ! E_RANGE' && c in {\"-\", \"+\"})";
"          column = column + 1;";
"        endif";
"        while (`c = source[row][column] ! E_RANGE')";
"          if (c >= \"0\" && c <= \"9\")";
"            column = column + 1;";
"          else";
"            break;";
"          endif";
"        endwhile";
"      endif";
"      col2 = column - 1;";
"      chars = source[row][col1..col2];";
"      if ((chars[$] < \"0\" || chars[$] > \"9\") && chars[$] != \".\")";
"        this.token = [\"sol\" -> first, \"eol\" -> 0, \"type\" -> \"number\", \"value\" -> chars, \"error\" -> \"Bad number\"];";
"      elseif (c >= \"a\" && c <= \"z\")";
"        this.token = [\"sol\" -> first, \"eol\" -> 0, \"type\" -> \"number\", \"value\" -> chars + c, \"error\" -> \"Bad number\"];";
"      else";
"        this.token = [\"sol\" -> first, \"eol\" -> 0, \"type\" -> \"number\", \"value\" -> float ? tofloat(chars) | toint(chars)];";
"      endif";
"";
"    /* string */";
"    elseif (c == \"\\\"\" || c == \"'\")";
"      esc = 0;";
"      chars = \"\";";
"      q = c;";
"      col1 = column; /* mark the start */";
"      column = column + 1;";
"      while (`c = source[row][column] ! E_RANGE' && (c != q || esc))";
"        column = column + 1;";
"        if (c != \"\\\\\" || esc)";
"          chars = tostr(chars, c);";
"          esc = 0;";
"        else";
"          esc = 1;";
"        endif";
"      endwhile";
"      column = column + 1;";
"      col2 = column - 1;";
"      if (c != q)";
"        this.token = [\"sol\" -> first, \"eol\" -> 0, \"type\" -> \"string\", \"value\" -> source[row][col1..col2 - 1], \"error\" -> \"Unterminated string\"];";
"      else";
"        this.token = [\"sol\" -> first, \"eol\" -> 0, \"type\" -> \"string\", \"value\" -> chars];";
"      endif";
"";
"    /* possible multi-character operator */";
"    elseif (index(\"-+<>=*/%!|&.\", c))";
"      col1 = column; /* mark the start */";
"      column = column + 1;";
"      if (`c = source[row][column] ! E_RANGE' && index(\">=*!|&.\", c))";
"        column = column + 1;";
"        this.token = [\"sol\" -> first, \"eol\" -> 0, \"type\" -> \"operator\", \"value\" -> source[row][col1..column - 1]];";
"      else";
"        this.token = [\"sol\" -> first, \"eol\" -> 0, \"type\" -> \"operator\", \"value\" -> source[row][col1]];";
"      endif";
"";
"    /* operator */";
"    else";
"      column = column + 1;";
"      this.token = [\"sol\" -> first, \"eol\" -> 0, \"type\" -> \"operator\", \"value\" -> c];";
"";
"    endif";
"";
"    /* found a token */";
"    first = 0;";
"";
"  endif";
"endwhile";
"";
"this.row = row;";
"this.column = column;";
"this.source = source;";
"this.first = first;";
"";
"/* check for unterminated comment */";
"if (block_comment)";
"  this.token = [\"sol\" -> 0, \"eol\" -> 0, \"type\" -> \"comment\", \"value\" -> \"\", \"error\" -> \"Unterminated comment\"];";
"endif";
"";
"/* dollar sign by itself is not a name */";
"if (this.token && this.token[\"type\"] == \"name\" && this.token[\"value\"] == \"$\")";
"  this.token[\"type\"] = \"operator\";";
"endif";
"";
"return this;";
"";
"chunk_length:244";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:D537A39EE9E6F057935746089B0450632311F1E6";
"-=-=-mxyzptlk-=-=-";
.
#48:2
this:_ensure_instance();
return this.token;
return;
"this:_ensure_instance();";
"";
"return this.token;";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:88791DF01E1D0711F700234B78C3BA4184A82F47";
"-=-=-mxyzptlk-=-=-";
.
#49:0
this:_ensure_prototype();
{tokenizer, @options} = args;
instance = create(this, 1);
instance.tokenizer = tokenizer;
instance.symbols = [];
plastic = this.plastic;
instance:symbol("(end)");
instance:symbol("(name)", 0, plastic.name_proto);
instance:symbol("(literal)", 0, plastic.literal_proto);
instance:symbol(";", 0, plastic.operator_proto);
instance:symbol(",", 0, plastic.operator_proto);
instance:symbol("]", 0, plastic.operator_proto);
instance:symbol("}", 0, plastic.operator_proto);
instance:symbol("->", 0, plastic.operator_proto);
instance:symbol("=>", 0, plastic.operator_proto);
instance:symbol("..", 0, plastic.operator_proto);
instance:symbol("|", 0, plastic.operator_proto);
instance:symbol("`", 0, plastic.operator_proto);
instance:symbol("!", 0, plastic.prefix_operator_proto);
instance:symbol("=", 50, plastic.assignment_operator_proto);
instance:symbol("+=", 50, plastic.compound_assignment_operator_proto);
instance:symbol("-=", 50, plastic.compound_assignment_operator_proto);
instance:symbol("*=", 50, plastic.compound_assignment_operator_proto);
instance:symbol("/=", 50, plastic.compound_assignment_operator_proto);
instance:symbol("%=", 50, plastic.compound_assignment_operator_proto);
instance:symbol("!!", 100, plastic.error_catching_operator_proto);
instance:symbol("?", 200, plastic.traditional_ternary_operator_proto);
instance:symbol("&&", 300, plastic.infix_operator_proto);
instance:symbol("||", 300, plastic.infix_operator_proto);
instance:symbol("!=", 400, plastic.infix_operator_proto);
instance:symbol("==", 400, plastic.infix_operator_proto);
instance:symbol("<", 400, plastic.infix_operator_proto);
instance:symbol("<=", 400, plastic.infix_operator_proto);
instance:symbol(">", 400, plastic.infix_operator_proto);
instance:symbol(">=", 400, plastic.infix_operator_proto);
instance:symbol("in", 400, plastic.infix_operator_proto);
instance:symbol("+", 500, plastic.sign_operator_proto);
instance:symbol("-", 500, plastic.sign_operator_proto);
instance:symbol("*", 600, plastic.infix_operator_proto);
instance:symbol("/", 600, plastic.infix_operator_proto);
instance:symbol("%", 600, plastic.infix_operator_proto);
instance:symbol("**", 650, plastic.infix_operator_proto, ["right" -> 1]);
instance:symbol("[", 800, plastic.bracket_operator_proto);
instance:symbol("{", 0, plastic.brace_operator_proto);
instance:symbol("return", 0, plastic.control_flow_statement_proto);
instance:symbol("break", 0, plastic.control_flow_statement_proto);
instance:symbol("continue", 0, plastic.control_flow_statement_proto);
instance:symbol("if", 0, plastic.if_statement_proto);
instance:symbol("for", 0, plastic.for_statement_proto);
instance:symbol("while", 0, plastic.loop_statement_proto);
instance:symbol("until", 0, plastic.loop_statement_proto);
instance:symbol("fork", 0, plastic.fork_statement_proto);
instance:symbol("try", 0, plastic.try_statement_proto);
instance:symbol("from", 0, plastic.from_statement_proto);
instance:symbol("import", 0, plastic.from_statement_proto);
instance:symbol(":", 800, plastic.verb_selector_operator_proto);
instance:symbol(".", 800, plastic.property_selector_operator_proto);
instance:symbol("(", 800, plastic.invocation_operator_proto, ["not_at_start" -> 1]);
instance:symbol(")", 0, plastic.operator_proto);
return instance;
return;
"this:_ensure_prototype();";
"";
"{tokenizer, @options} = args;";
"";
"instance = create(this, 1);";
"instance.tokenizer = tokenizer;";
"instance.symbols = [];";
"";
"plastic = this.plastic;";
"";
"/* `(end)' is required */";
"instance:symbol(\"(end)\");";
"instance:symbol(\"(name)\", 0, plastic.name_proto);";
"instance:symbol(\"(literal)\", 0, plastic.literal_proto);";
"instance:symbol(\";\", 0, plastic.operator_proto);";
"instance:symbol(\",\", 0, plastic.operator_proto);";
"instance:symbol(\"]\", 0, plastic.operator_proto);";
"instance:symbol(\"}\", 0, plastic.operator_proto);";
"instance:symbol(\"->\", 0, plastic.operator_proto);";
"instance:symbol(\"=>\", 0, plastic.operator_proto);";
"instance:symbol(\"..\", 0, plastic.operator_proto);";
"instance:symbol(\"|\", 0, plastic.operator_proto);";
"instance:symbol(\"`\", 0, plastic.operator_proto);";
"instance:symbol(\"!\", 0, plastic.prefix_operator_proto);";
"instance:symbol(\"=\", 50, plastic.assignment_operator_proto);";
"instance:symbol(\"+=\", 50, plastic.compound_assignment_operator_proto);";
"instance:symbol(\"-=\", 50, plastic.compound_assignment_operator_proto);";
"instance:symbol(\"*=\", 50, plastic.compound_assignment_operator_proto);";
"instance:symbol(\"/=\", 50, plastic.compound_assignment_operator_proto);";
"instance:symbol(\"%=\", 50, plastic.compound_assignment_operator_proto);";
"instance:symbol(\"!!\", 100, plastic.error_catching_operator_proto);";
"instance:symbol(\"?\", 200, plastic.traditional_ternary_operator_proto);";
"instance:symbol(\"&&\", 300, plastic.infix_operator_proto);";
"instance:symbol(\"||\", 300, plastic.infix_operator_proto);";
"instance:symbol(\"!=\", 400, plastic.infix_operator_proto);";
"instance:symbol(\"==\", 400, plastic.infix_operator_proto);";
"instance:symbol(\"<\", 400, plastic.infix_operator_proto);";
"instance:symbol(\"<=\", 400, plastic.infix_operator_proto);";
"instance:symbol(\">\", 400, plastic.infix_operator_proto);";
"instance:symbol(\">=\", 400, plastic.infix_operator_proto);";
"instance:symbol(\"in\", 400, plastic.infix_operator_proto);";
"instance:symbol(\"+\", 500, plastic.sign_operator_proto);";
"instance:symbol(\"-\", 500, plastic.sign_operator_proto);";
"instance:symbol(\"*\", 600, plastic.infix_operator_proto);";
"instance:symbol(\"/\", 600, plastic.infix_operator_proto);";
"instance:symbol(\"%\", 600, plastic.infix_operator_proto);";
"instance:symbol(\"**\", 650, plastic.infix_operator_proto, [\"right\" -> 1]);";
"instance:symbol(\"[\", 800, plastic.bracket_operator_proto);";
"instance:symbol(\"{\", 0, plastic.brace_operator_proto); /* never bind left */";
"instance:symbol(\"return\", 0, plastic.control_flow_statement_proto);";
"instance:symbol(\"break\", 0, plastic.control_flow_statement_proto);";
"instance:symbol(\"continue\", 0, plastic.control_flow_statement_proto);";
"instance:symbol(\"if\", 0, plastic.if_statement_proto);";
"instance:symbol(\"for\", 0, plastic.for_statement_proto);";
"instance:symbol(\"while\", 0, plastic.loop_statement_proto);";
"instance:symbol(\"until\", 0, plastic.loop_statement_proto);";
"instance:symbol(\"fork\", 0, plastic.fork_statement_proto);";
"instance:symbol(\"try\", 0, plastic.try_statement_proto);";
"instance:symbol(\"from\", 0, plastic.from_statement_proto); /* deprecated, use `import' */";
"instance:symbol(\"import\", 0, plastic.from_statement_proto);";
"instance:symbol(\":\", 800, plastic.verb_selector_operator_proto);";
"instance:symbol(\".\", 800, plastic.property_selector_operator_proto);";
"/* the infix form is function/verb invocation */";
"instance:symbol(\"(\", 800, plastic.invocation_operator_proto, [\"not_at_start\" -> 1]);";
"instance:symbol(\")\", 0, plastic.operator_proto);";
"";
"return instance;";
"";
"chunk_length:67";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:4229CD14FD6B952F0087A45F1B6C91BB40195245";
"-=-=-mxyzptlk-=-=-";
.
#49:1
this:_ensure_instance();
{id, ?bp = 0, ?proto = $nothing, ?options = []} = args;
proto = valid(proto) ? proto | this.plastic.symbol_proto;
if ((symbol = `this.symbols[id] ! E_RANGE') == E_RANGE)
symbol = proto:create(id, bp, options);
endif
this.symbols[id] = symbol;
return symbol;
return;
"this:_ensure_instance();";
"";
"{id, ?bp = 0, ?proto = $nothing, ?options = []} = args;";
"";
"proto = valid(proto) ? proto | this.plastic.symbol_proto;";
"";
"if ((symbol = `this.symbols[id] ! E_RANGE') == E_RANGE)";
"  symbol = proto:create(id, bp, options);";
"endif";
"";
"this.symbols[id] = symbol;";
"";
"return symbol;";
"";
"chunk_length:13";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:0B2A68461D7DF243F67813AB414CB1AE94A08562";
"-=-=-mxyzptlk-=-=-";
.
#49:2
this:_ensure_instance();
{symbol} = args;
id = symbol.id;
if (((((type = this.symbols[id].type) != "name") && (type != "statement")) && (type != "keyword")) && (type != "binary"))
an_or_a = index("aeiou", type[1]) ? "an" | "a";
raise("Syntax error", tostr("`", id, "' is ", an_or_a, " ", type), this);
endif
symbol.reserved = 1;
symbol.type = verb[9..$];
this.symbols[id] = symbol;
return;
"this:_ensure_instance();";
"";
"{symbol} = args;";
"";
"id = symbol.id;";
"";
"/* raise error if this symbol is not a name, statement, keyword or binary (for `in') */";
"if ((type = this.symbols[id].type) != \"name\" && type != \"statement\" && type != \"keyword\" && type != \"binary\")";
"  an_or_a = index(\"aeiou\", type[1]) ? \"an\" | \"a\";";
"  raise(\"Syntax error\", tostr(\"`\", id, \"' is \", an_or_a, \" \", type), this);";
"endif";
"";
"/* verb name is \"reserve_statement\" OR \"reserve_keyword\" */";
"";
"symbol.reserved = 1;";
"symbol.type = verb[9..$];";
"";
"this.symbols[id] = symbol;";
"";
"chunk_length:18";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:2B59D507172651E3C7DD5157D7852BDD05EDD0C6";
"-=-=-mxyzptlk-=-=-";
.
#49:3
this:_ensure_instance();
{symbol} = args;
id = symbol.id;
if (this.symbols[id].reserved)
raise("Syntax error", tostr("`", id, "' is reserved"), this);
endif
symbol.reserved = 0;
symbol.type = verb[6..$];
this.symbols[id] = symbol;
return;
"this:_ensure_instance();";
"";
"{symbol} = args;";
"";
"id = symbol.id;";
"";
"/* raise error if this symbol is reserved */";
"if (this.symbols[id].reserved)";
"  raise(\"Syntax error\", tostr(\"`\", id, \"' is reserved\"), this);";
"endif";
"";
"/* verb name is \"make_identifier\" OR \"make_variable\" */";
"";
"symbol.reserved = 0;";
"symbol.type = verb[6..$];";
"";
"this.symbols[id] = symbol;";
"";
"chunk_length:17";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:A59D239BB8DE5DC150F30DF9CF32B33945D2DD35";
"-=-=-mxyzptlk-=-=-";
.
#49:4
this:_ensure_instance();
{?ttid = 0} = args;
if (this.token == 0)
this.tokenizer:advance();
token = this.tokenizer.token;
if (token)
type = token["type"];
value = token["value"];
sol = token["sol"];
eol = token["eol"];
if (`token["error"] ! E_RANGE')
raise("Syntax error", token["error"], this);
elseif ((((type == "number") || (type == "string")) || (type == "object")) || (type == "error"))
symbol = this:symbol("(literal)");
this.token = symbol:clone();
this.token.type = type;
this.token.value = value;
this.token.sol = sol;
this.token.eol = eol;
elseif (type == "operator")
if ((symbol = `this.symbols[value] ! E_RANGE') == E_RANGE)
raise("Syntax error", tostr("Unknown operator:  `", value, "'"), this);
endif
this.token = symbol:clone();
this.token.type = "operator";
this.token.value = value;
this.token.sol = sol;
this.token.eol = eol;
elseif (type == "name")
id = value;
if ((symbol = `this.symbols[id] ! E_RANGE') != E_RANGE)
this.token = symbol:clone();
this.symbols[id] = this.token;
this.token.type = symbol.type || "name";
this.token.id = id;
this.token.value = value;
this.token.sol = sol;
this.token.eol = eol;
else
symbol = this:symbol("(name)");
this.token = symbol:clone();
this.symbols[id] = this.token;
this.token.type = "name";
this.token.id = id;
this.token.value = value;
this.token.sol = sol;
this.token.eol = eol;
endif
else
raise("Syntax error", "Unexpected token", this);
endif
else
symbol = this:symbol("(end)");
this.token = symbol:clone();
endif
endif
if (ttid)
this:advance(ttid);
endif
return this.token;
return;
"this:_ensure_instance();";
"";
"{?ttid = 0} = args;";
"";
"if (this.token == 0)";
"  this.tokenizer:advance();";
"  token = this.tokenizer.token;";
"  if (token)";
"    type = token[\"type\"];";
"    value = token[\"value\"];";
"    sol = token[\"sol\"];";
"    eol = token[\"eol\"];";
"    if (`token[\"error\"] ! E_RANGE')";
"      raise(\"Syntax error\", token[\"error\"], this);";
"    elseif (type == \"number\" || type == \"string\" || type == \"object\" || type == \"error\")";
"      symbol = this:symbol(\"(literal)\");";
"      this.token = symbol:clone();";
"      this.token.type = type;";
"      this.token.value = value;";
"      this.token.sol = sol;";
"      this.token.eol = eol;";
"    elseif (type == \"operator\")";
"      /* Update the symbol table itself and give the operator the";
"       * initial type \"operator\" (the type will change to \"unary\",";
"       * \"binary\" or \"ternary\" when we learn how this symbol is used in";
"       * the program).";
"       */";
"      /* check the symbol table */";
"      if ((symbol = `this.symbols[value] ! E_RANGE') == E_RANGE)";
"        raise(\"Syntax error\", tostr(\"Unknown operator:  `\", value, \"'\"), this);";
"      endif";
"      this.token = symbol:clone();";
"      this.token.type = \"operator\";";
"      this.token.value = value;";
"      this.token.sol = sol;";
"      this.token.eol = eol;";
"    elseif (type == \"name\")";
"      /* Update the symbol table itself and give the name the initial";
"       * type \"name\" (the type will change to \"variable\", \"identifier\",";
"       * \"statement\" or \"keyword\" when we learn how this symbol is used";
"       * in the program).";
"       */";
"      id = value;";
"      /* peek into the symbol table */";
"      if ((symbol = `this.symbols[id] ! E_RANGE') != E_RANGE)";
"        this.token = symbol:clone();";
"        this.symbols[id] = this.token;";
"        this.token.type = symbol.type || \"name\";";
"        this.token.id = id;";
"        this.token.value = value;";
"	this.token.sol = sol;";
"        this.token.eol = eol;";
"      else";
"        symbol = this:symbol(\"(name)\");";
"        this.token = symbol:clone();";
"        this.symbols[id] = this.token;";
"        this.token.type = \"name\";";
"        this.token.id = id;";
"        this.token.value = value;";
"	this.token.sol = sol;";
"        this.token.eol = eol;";
"      endif";
"    else";
"      raise(\"Syntax error\", \"Unexpected token\", this);";
"    endif";
"  else";
"    symbol = this:symbol(\"(end)\");";
"    this.token = symbol:clone();";
"  endif";
"endif";
"";
"if (ttid)";
"  this:advance(ttid);";
"endif";
"";
"return this.token;";
"";
"chunk_length:76";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:B142216A9225CFA84B928D4A7CBB49B7A1240755";
"-=-=-mxyzptlk-=-=-";
.
#49:5
this:_ensure_instance();
{?id = 0} = args;
if ((id && (this.token != 0)) && (this.token.id != id))
raise("Syntax error", tostr("Expected `", id, "'"), this);
endif
this.token = 0;
return this;
return;
"this:_ensure_instance();";
"";
"{?id = 0} = args;";
"";
"/* raise error if token doesn't match expectation */";
"if (id && this.token != 0 && this.token.id != id)";
"  raise(\"Syntax error\", tostr(\"Expected `\", id, \"'\"), this);";
"endif";
"";
"this.token = 0;";
"";
"return this;";
"";
"chunk_length:12";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:B578DF8B4CC8A8272EE8533436189DC247950745";
"-=-=-mxyzptlk-=-=-";
.
#49:6
this:_ensure_instance();
{?bp = 0} = args;
token = this:token();
this:advance();
if (token.id == "(end)")
return token;
endif
left = token:nud(this);
while ((bp < this:token().bp) && (!(this:token().not_at_start && this:token().sol)))
this.plastic.utilities:suspend_if_necessary();
token = this:token();
this:advance();
left = token:led(this, left);
endwhile
return left;
return;
"this:_ensure_instance();";
"";
"{?bp = 0} = args;";
"";
"token = this:token();";
"this:advance();";
"";
"/* don't call `nud()' and/or `led()' on `(end)' */";
"if (token.id == \"(end)\")";
"  return token;";
"endif";
"";
"left = token:nud(this);";
"";
"/* Per the usual implementation, loop as long as the the current";
" * binding power is greater than each token's binding power, and we're";
" * not attempting to bind a token that can't bind at the beginning of";
" * a line, at the beginning of a line (handles the dangling function";
" * invocation case).";
" */";
"while (bp < this:token().bp && !(this:token().not_at_start && this:token().sol))";
"";
"  this.plastic.utilities:suspend_if_necessary();";
"";
"  token = this:token();";
"  this:advance();";
"  left = token:led(this, left);";
"endwhile";
"";
"return left;";
"";
"chunk_length:30";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:92F33F213709139DCA6D4F667F28997A5FB51AAD";
"-=-=-mxyzptlk-=-=-";
.
#49:7
this:_ensure_instance();
token = this:token();
while (token.id == ";")
this:advance();
token = this:token();
endwhile
if (respond_to(token, "std"))
this:advance();
return token:std(this);
else
expression = this:expression();
if (this:token().id == ";")
this:advance();
endif
return expression;
endif
return;
"this:_ensure_instance();";
"";
"token = this:token();";
"";
"/* disregarded naked semicolons */";
"while (token.id == \";\")";
"  this:advance();";
"  token = this:token();";
"endwhile";
"";
"/* either the beginning of a statement */";
"/* or an expression with an optional semicolon */";
"if (respond_to(token, \"std\"))";
"  this:advance();";
"  return token:std(this);";
"else";
"  expression = this:expression();";
"  if (this:token().id == \";\")";
"    this:advance();";
"  endif";
"  return expression;";
"endif";
"";
"chunk_length:22";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:A633F2B8764F84393F61203601572D48B1D56CCE";
"-=-=-mxyzptlk-=-=-";
.
#49:8
this:_ensure_instance();
terminals = args;
statements = {};
while (1)
this.plastic.utilities:suspend_if_necessary();
token = this:token();
while (token.id == ";")
this:advance();
token = this:token();
endwhile
if ((token.id == "(end)") || ((token.type in {"name", "statement", "keyword"}) && (token.value in terminals)))
break;
endif
statement = this:statement();
if (statement.id == "(end)")
break;
endif
statements = {@statements, statement};
endwhile
return statements;
return;
"this:_ensure_instance();";
"";
"terminals = args;";
"";
"statements = {};";
"";
"while (1)";
"  this.plastic.utilities:suspend_if_necessary();";
"";
"  token = this:token();";
"";
"  /* disregarded naked semicolons */";
"  while (token.id == \";\")";
"    this:advance();";
"    token = this:token();";
"  endwhile";
"";
"  if (token.id == \"(end)\" || ((token.type in {\"name\", \"statement\", \"keyword\"}) && token.value in terminals))";
"    break;";
"  endif";
"  statement = this:statement();";
"  if (statement.id == \"(end)\")";
"    break;";
"  endif";
"  statements = {@statements, statement};";
"endwhile";
"";
"return statements;";
"";
"chunk_length:28";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:8E015FCCF923A1CBCBB533483A3D7C69F931249A";
"-=-=-mxyzptlk-=-=-";
.
#49:9
raise("DEPRECATED");
this:_ensure_instance();
stack = statements = this:statements();
while (stack)
this.plastic.utilities:suspend_if_necessary();
{top, @stack} = stack;
stack = {@stack, @this.plastic.utilities:children(top)};
if (((typeof(top) == ANON) && isa(top, this.plastic.symbol_proto)) && (top.owner == this.owner))
this.object_utilities:change_owner(top, caller_perms());
endif
endwhile
return statements;
return;
"raise(\"DEPRECATED\");";
"";
"this:_ensure_instance();";
"";
"/* This is the API entry-point for clients that want to turn a";
" * stream of tokens into a syntax tree and to return it for further";
" * modification, changing ownership to the client in the process.";
" * Assumes \"change owner\" permission has been granted by the";
" * caller.";
" */";
"";
"stack = statements = this:statements();";
"";
"while (stack)";
"  this.plastic.utilities:suspend_if_necessary();";
"  {top, @stack} = stack;";
"  stack = {@stack, @this.plastic.utilities:children(top)};";
"  /* There is no requirement to clone nodes when rewriting a syntax";
"   * tree, therefore nodes may appear multiple times in different";
"   * parts of the tree.  Check ownership to ensure the node in";
"   * question has not already had its ownership changed.";
"   */";
"  if (typeof(top) == ANON && isa(top, this.plastic.symbol_proto) && top.owner == this.owner)";
"    this.object_utilities:change_owner(top, caller_perms());";
"  endif";
"endwhile";
"";
"return statements;";
"";
"chunk_length:28";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:4C56C57EBCE20408699B8414AC04F9CB56E28532";
"-=-=-mxyzptlk-=-=-";
.
#49:10
this:_ensure_instance();
definition = args;
{id, @rest} = definition;
new = 0;
if (`this.symbols[id] ! E_RANGE' == E_RANGE)
this:symbol(@definition);
new = 1;
endif
return {new, id};
return;
"this:_ensure_instance();";
"";
"definition = args;";
"{id, @rest} = definition;";
"";
"new = 0;";
"";
"if (`this.symbols[id] ! E_RANGE' == E_RANGE)";
"  this:symbol(@definition);";
"  new = 1;";
"endif";
"";
"return {new, id};";
"";
"chunk_length:13";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:4781098C110B4FFF668FD2A18CBD3BD8AFB62823";
"-=-=-mxyzptlk-=-=-";
.
#49:11
this:_ensure_instance();
{args} = args;
{new, id} = args;
if (new)
this.symbols = this.symbols:delete(id);
endif
return;
"this:_ensure_instance();";
"";
"{args} = args;";
"{new, id} = args;";
"";
"if (new)";
"  this.symbols = this.symbols:delete(id);";
"endif";
"";
"chunk_length:8";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:0694833C1581AAE25EFCBB39D68E09A5C5EECD56";
"-=-=-mxyzptlk-=-=-";
.
#50:0
{id, ?bp = 0, ?opts = []} = args;
(typeof(this) == OBJ) || raise(E_PERM, "Call not allowed on anonymous object");
instance = create(this, 1);
instance.id = id;
instance.value = id;
instance.bp = bp;
for v, k in (opts:slice("right", "not_at_start"))
instance.(k) = v;
endfor
return instance;
return;
"{id, ?bp = 0, ?opts = []} = args;";
"(typeof(this) == OBJ) || raise(E_PERM, \"Call not allowed on anonymous object\");";
"instance = create(this, 1);";
"instance.id = id;";
"instance.value = id;";
"instance.bp = bp;";
"for v, k in (opts:slice(\"right\", \"not_at_start\"))";
"    instance.(k) = v;";
"endfor";
"return instance;";
"";
"chunk_length:10";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:B489C82E1F2E11EC2F8DFA41404681DDDC462000";
"-=-=-mxyzptlk-=-=-";
.
#50:1
(typeof(this) == OBJ) && raise(E_PERM, "Call not allowed on permanent object");
parents = parents(this);
instance = create(parents, 1);
for ancestor in (ancestors(this))
for property in (`properties(ancestor) ! E_PERM => {}')
instance.(property) = this.(property);
endfor
endfor
return instance;
return;
"(typeof(this) == OBJ) && raise(E_PERM, \"Call not allowed on permanent object\");";
"parents = parents(this);";
"instance = create(parents, 1);";
"for ancestor in (ancestors(this))";
"  for property in (`properties(ancestor) ! E_PERM => {}')";
"    instance.(property) = this.(property);";
"  endfor";
"endfor";
"return instance;";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:4D2593BDDD8F59910175EAE7CB5A6545EF0EAFAD";
"-=-=-mxyzptlk-=-=-";
.
#50:2
{parser} = args;
raise("Syntax error", tostr("Undefined: ", this.id), parser);
return;
"{parser} = args;";
"raise(\"Syntax error\", tostr(\"Undefined: \", this.id), parser);";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:68DC710F510F0E7CC805B4B86840E071693713E8";
"-=-=-mxyzptlk-=-=-";
.
#50:3
{parser, _} = args;
raise("Syntax error", tostr("Missing operator: ", this.id), parser);
return;
"{parser, _} = args;";
"raise(\"Syntax error\", tostr(\"Missing operator: \", this.id), parser);";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:18A6698FEADF4FF80C0F7CAFE90F2DB32EC68A5F";
"-=-=-mxyzptlk-=-=-";
.
#51:0
return this;
return;
"return this;";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:58CFE4977A49A7695FEE4D2F29BB87606D70E92F";
"-=-=-mxyzptlk-=-=-";
.
#52:0
{parser} = args;
if (parser.imports:has_key(this.value) && (parser:token().id != "("))
left = this;
this = parser.plastic.property_selector_operator_proto:create(".", this.bp);
this.type = "binary";
this.first = parser.imports[left.value];
this.second = left;
parser:make_identifier(left);
else
parser:make_variable(this);
endif
return this;
return;
"{parser} = args;";
"";
"/* Peek ahead.  If the name was imported and the next character is not";
" * the invocation operator then this is property selection.";
" * Otherwise, assume the name is a variable.  Subsequent usage may";
" * modify this assumption.";
"*/";
"if (parser.imports:has_key(this.value) && parser:token().id != \"(\")";
"  left = this;";
"  this = parser.plastic.property_selector_operator_proto:create(\".\", this.bp);";
"  this.type = \"binary\";";
"  this.first = parser.imports[left.value];";
"  this.second = left;";
"  parser:make_identifier(left);";
"else";
"  parser:make_variable(this);";
"endif";
"";
"return this;";
"";
"chunk_length:19";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:590F0EBCAFF83B7CEEDB4453069C2433DAF1CFC2";
"-=-=-mxyzptlk-=-=-";
.
#53:0
{parser} = args;
raise("Syntax error", "Undefined", parser);
return;
"{parser} = args;";
"raise(\"Syntax error\", \"Undefined\", parser);";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:F2A4DE7467B49F34B0185D83E9DB7CC26D24EBDE";
"-=-=-mxyzptlk-=-=-";
.
#55:0
{parser} = args;
if ((this.id != "return") && (parser.loop_depth < 1))
raise("Syntax error", tostr("No enclosing loop for ", this.id), parser);
endif
parser:reserve_statement(this);
if ((!this.eol) && (parser:token().id != ";"))
expression = parser:expression(0);
this.first = expression;
endif
if ((this.id != "return") && (this.first != 0))
if (this.first.type != "variable")
raise("Syntax error", "Loop name must be a name", parser);
endif
if (!(this.first.value in parser.loop_variables))
raise("Syntax error", tostr("Invalid loop name for ", this.id), parser);
endif
endif
if (parser:token().id == ";")
parser:advance(";");
endif
return this;
return;
"{parser} = args;";
"";
"if (this.id != \"return\" && parser.loop_depth < 1)";
"  raise(\"Syntax error\", tostr(\"No enclosing loop for \", this.id), parser);";
"endif";
"";
"/* update the symbol table */";
"parser:reserve_statement(this);";
"";
"if (!this.eol && parser:token().id != \";\")";
"  expression = parser:expression(0);";
"  this.first = expression;";
"endif";
"";
"if (this.id != \"return\" && this.first != 0)";
"  if (this.first.type != \"variable\")";
"    raise(\"Syntax error\", \"Loop name must be a name\", parser);";
"  endif";
"  if (!(this.first.value in parser.loop_variables))";
"    raise(\"Syntax error\", tostr(\"Invalid loop name for \", this.id), parser);";
"  endif";
"endif";
"";
"if (parser:token().id == \";\")";
"  parser:advance(\";\");";
"endif";
"";
"return this;";
"";
"chunk_length:28";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:418293156AC1D9BE243C39A3EC9F3B7FFBE4CDD5";
"-=-=-mxyzptlk-=-=-";
.
#56:0
{parser, first} = args;
right = this.right && 1;
second = parser:expression(this.bp - right);
if (second.id == "(end)")
raise("Syntax error", "Expected an expression", parser);
endif
this.type = "binary";
this.first = first;
this.second = second;
return this;
return;
"{parser, first} = args;";
"";
"right = this.right && 1; /* does this operator associate to the right? */";
"";
"second = parser:expression(this.bp - right);";
"";
"if (second.id == \"(end)\")";
"  raise(\"Syntax error\", \"Expected an expression\", parser);";
"endif";
"";
"this.type = \"binary\";";
"this.first = first;";
"this.second = second;";
"";
"return this;";
"";
"chunk_length:15";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:5A90918D1650451B6F3F14F2AC74F67C25F382B2";
"-=-=-mxyzptlk-=-=-";
.
#57:0
{parser, first} = args;
if ((first.type == "unary") && (first.id == "{"))
this.plastic.utilities:validate_scattering_pattern(parser, first.value);
first.type = "pattern";
endif
if ((((first.type != "variable") && (first.type != "pattern")) && (first.id != ".")) && (first.id != "["))
raise("Syntax error", "Illegal expression on left side of assignment", parser);
endif
second = parser:expression(this.bp - 1);
if (second.id == "(end)")
raise("Syntax error", "Expected an expression", parser);
endif
this.type = "binary";
this.first = first;
this.second = second;
return this;
return;
"{parser, first} = args;";
"";
"if (first.type == \"unary\" && first.id == \"{\") /* scattering syntax */";
"  this.plastic.utilities:validate_scattering_pattern(parser, first.value);";
"  first.type = \"pattern\";";
"endif";
"";
"if (first.type != \"variable\" && first.type != \"pattern\" && first.id != \".\" && first.id != \"[\")";
"  raise(\"Syntax error\", \"Illegal expression on left side of assignment\", parser);";
"endif";
"";
"second = parser:expression(this.bp - 1);";
"";
"if (second.id == \"(end)\")";
"  raise(\"Syntax error\", \"Expected an expression\", parser);";
"endif";
"";
"this.type = \"binary\";";
"this.first = first;";
"this.second = second;";
"";
"return this;";
"";
"chunk_length:22";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:F0969021843EDF73519565F7131A329F32CD2DF5";
"-=-=-mxyzptlk-=-=-";
.
#58:0
{parser, first} = args;
if (((first.type != "variable") && (first.id != ".")) && (first.id != "["))
raise("Syntax error", "Illegal expression on left side of assignment", parser);
endif
second = parser:expression(this.bp - 1);
if (second.id == "(end)")
raise("Syntax error", "Expected an expression", parser);
endif
op = this.id[1];
bp = parser.symbols[op].bp;
inner = parser.plastic.infix_operator_proto:create(op, bp);
inner.type = "binary";
inner.first = first;
inner.second = second;
outer = parser.plastic.assignment_operator_proto:create("=", this.bp);
outer.type = "binary";
outer.first = first;
outer.second = inner;
return outer;
return;
"{parser, first} = args;";
"";
"if (first.type != \"variable\" && first.id != \".\" && first.id != \"[\")";
"  raise(\"Syntax error\", \"Illegal expression on left side of assignment\", parser);";
"endif";
"";
"second = parser:expression(this.bp - 1);";
"";
"if (second.id == \"(end)\")";
"  raise(\"Syntax error\", \"Expected an expression\", parser);";
"endif";
"";
"op = this.id[1];";
"bp = parser.symbols[op].bp;";
"";
"inner = parser.plastic.infix_operator_proto:create(op, bp);";
"inner.type = \"binary\";";
"inner.first = first;";
"inner.second = second;";
"";
"outer = parser.plastic.assignment_operator_proto:create(\"=\", this.bp);";
"outer.type = \"binary\";";
"outer.first = first;";
"outer.second = inner;";
"";
"return outer;";
"";
"chunk_length:26";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:D668478D97D225907C9506876AB858AEEE19F2EE";
"-=-=-mxyzptlk-=-=-";
.
#59:0
{parser} = args;
first = parser:expression(700);
if (first.id == "(end)")
raise("Syntax error", "Expected an expression", parser);
endif
this.type = "unary";
this.first = first;
return this;
return;
"{parser} = args;";
"";
"first = parser:expression(700);";
"";
"if (first.id == \"(end)\")";
"  raise(\"Syntax error\", \"Expected an expression\", parser);";
"endif";
"";
"this.type = \"unary\";";
"this.first = first;";
"";
"return this;";
"";
"chunk_length:12";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:71052EB9A64F517E3CBE29438E498136C830D190";
"-=-=-mxyzptlk-=-=-";
.
#60:0
{parser} = args;
sequence = this.plastic.utilities:parse_map_sequence(parser, ",", "->", "]");
parser:token("]");
this.type = "unary";
this.value = sequence;
this.first = this;
return this;
return;
"{parser} = args;";
"";
"sequence = this.plastic.utilities:parse_map_sequence(parser, \",\", \"->\", \"]\");";
"parser:token(\"]\");";
"";
"this.type = \"unary\";";
"this.value = sequence;";
"this.first = this;";
"";
"return this;";
"";
"chunk_length:10";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:C58ADA1565060D3143B279910446F0D8F39D58CA";
"-=-=-mxyzptlk-=-=-";
.
#60:1
{parser, first} = args;
caret = parser:push("^", 0, this.plastic.positional_symbol_proto);
dollar = parser:push("$", 0, this.plastic.positional_symbol_proto);
second = parser:expression(0);
if (parser:token().id == "..")
parser:advance("..");
third = parser:expression(0);
parser:advance("]");
this.type = "ternary";
this.first = first;
this.second = second;
this.third = third;
else
parser:advance("]");
this.type = "binary";
this.first = first;
this.second = second;
endif
parser:pop(caret);
parser:pop(dollar);
return this;
return;
"{parser, first} = args;";
"";
"caret = parser:push(\"^\", 0, this.plastic.positional_symbol_proto);";
"dollar = parser:push(\"$\", 0, this.plastic.positional_symbol_proto);";
"";
"second = parser:expression(0);";
"";
"if (parser:token().id == \"..\")";
"  parser:advance(\"..\");";
"  third = parser:expression(0);";
"  parser:advance(\"]\");";
"  this.type = \"ternary\";";
"  this.first = first;";
"  this.second = second;";
"  this.third = third;";
"else";
"  parser:advance(\"]\");";
"  this.type = \"binary\";";
"  this.first = first;";
"  this.second = second;";
"endif";
"";
"parser:pop(caret);";
"parser:pop(dollar);";
"";
"return this;";
"";
"chunk_length:26";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:E3672ECDB8F1E70C3B53C5793417BE0E54E98468";
"-=-=-mxyzptlk-=-=-";
.
#61:0
{parser} = args;
sequence = this.plastic.utilities:parse_list_sequence(parser, ",", "}");
parser:token("}");
this.type = "unary";
this.value = sequence;
this.first = this;
return this;
return;
"{parser} = args;";
"";
"sequence = this.plastic.utilities:parse_list_sequence(parser, \",\", \"}\");";
"parser:token(\"}\");";
"";
"this.type = \"unary\";";
"this.value = sequence;";
"this.first = this;";
"";
"return this;";
"";
"chunk_length:10";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:687E36A53B89521FDC319DA7581CD449862A2BBF";
"-=-=-mxyzptlk-=-=-";
.
#62:0
{parser} = args;
parser:reserve_statement(this);
a = {};
parser:token("(");
expression = parser:expression(0);
a = {@a, expression};
parser:token(")");
statements = parser:statements("elseif", "else", "endif", "end");
a = {@a, statements};
while (parser:token().id == "elseif")
parser:advance("elseif");
parser:token("(");
expression = parser:expression(0);
a = {@a, expression};
parser:token(")");
statements = parser:statements("elseif", "else", "endif", "end");
a = {@a, statements};
symbol = parser.symbols["elseif"];
parser:reserve_keyword(symbol);
endwhile
if (parser:token().id == "else")
parser:advance("else");
statements = parser:statements("endif", "end");
a = {@a, statements};
symbol = parser.symbols["else"];
parser:reserve_keyword(symbol);
endif
if ((id = parser:token().id) == "endif")
parser:advance("endif");
else
parser:advance("end");
endif
symbol = parser.symbols[id];
parser:reserve_keyword(symbol);
this.value = a;
return this;
return;
"{parser} = args;";
"";
"/* update the symbol table */";
"parser:reserve_statement(this);";
"";
"a = {};";
"";
"/* the predicate */";
"parser:token(\"(\");";
"expression = parser:expression(0);";
"a = {@a, expression};";
"parser:token(\")\");";
"";
"/* the consequent */";
"statements = parser:statements(\"elseif\", \"else\", \"endif\", \"end\");";
"a = {@a, statements};";
"";
"/* the alternatives */";
"while (parser:token().id == \"elseif\")";
"  parser:advance(\"elseif\");";
"";
"  /* predicate */";
"  parser:token(\"(\");";
"  expression = parser:expression(0);";
"  a = {@a, expression};";
"  parser:token(\")\");";
"";
"  /* consequent */";
"  statements = parser:statements(\"elseif\", \"else\", \"endif\", \"end\");";
"  a = {@a, statements};";
"";
"  /* update the symbol table */";
"  symbol = parser.symbols[\"elseif\"];";
"  parser:reserve_keyword(symbol);";
"endwhile";
"";
"/* the final alternative */";
"if (parser:token().id == \"else\")";
"  parser:advance(\"else\");";
"";
"  statements = parser:statements(\"endif\", \"end\");";
"  a = {@a, statements};";
"";
"  /* update the symbol table */";
"  symbol = parser.symbols[\"else\"];";
"  parser:reserve_keyword(symbol);";
"endif";
"";
"/* the last token must be \"endif\" or \"end\" */";
"if ((id = parser:token().id) == \"endif\")";
"  parser:advance(\"endif\");";
"else";
"  parser:advance(\"end\");";
"endif";
"";
"/* update the symbol table */";
"symbol = parser.symbols[id];";
"parser:reserve_keyword(symbol);";
"";
"/* store the parts in this token's `value' */";
"this.value = a;";
"";
"return this;";
"";
"chunk_length:63";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:46F2D54F58E6B9C969243EEFCECA239D22FF4A45";
"-=-=-mxyzptlk-=-=-";
.
#63:0
{parser} = args;
expression = parser:expression(0);
parser:token(")");
this.type = "unary";
this.first = expression;
return this;
return;
"{parser} = args;";
"";
"expression = parser:expression(0);";
"parser:token(\")\");";
"";
"this.type = \"unary\";";
"this.first = expression;";
"";
"return this;";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:1DDA7B523803C381657DBFCD1FEFBFBAD9085984";
"-=-=-mxyzptlk-=-=-";
.
#63:1
{parser, left} = args;
sequence = this.plastic.utilities:parse_list_sequence(parser, ",", ")");
parser:token(")");
if (left.id == ".")
raise("Syntax error", "Invalid application of invocation", parser);
elseif (left.id == ":")
first = left.first;
second = left.second;
this.type = "ternary";
this.first = first;
this.second = second;
this.third = sequence;
else
if (left.type != "variable")
raise("Syntax error", "Expected an identifier", parser);
endif
parser:make_identifier(left);
if (`import = parser.imports[left.value] ! E_RANGE' != E_RANGE)
this.type = "ternary";
this.first = import;
this.second = left;
this.third = sequence;
else
this.type = "binary";
this.first = left;
this.second = sequence;
endif
endif
return this;
return;
"{parser, left} = args;";
"";
"sequence = this.plastic.utilities:parse_list_sequence(parser, \",\", \")\");";
"parser:token(\")\");";
"";
"/* The invocation operator handles function and verb invocation, and";
" * guards against use on properties.";
" */";
"if (left.id == \".\")";
"  raise(\"Syntax error\", \"Invalid application of invocation\", parser);";
"elseif (left.id == \":\")";
"  first = left.first;";
"  second = left.second;";
"";
"  /* the verb selector operator has our back */";
"";
"  this.type = \"ternary\";";
"  this.first = first;";
"  this.second = second;";
"  this.third = sequence;";
"else";
"  if (left.type != \"variable\")";
"    raise(\"Syntax error\", \"Expected an identifier\", parser);";
"  endif";
"";
"  parser:make_identifier(left);";
"";
"  if (`import = parser.imports[left.value] ! E_RANGE' != E_RANGE)";
"    this.type = \"ternary\";";
"    this.first = import;";
"    this.second = left;";
"    this.third = sequence;";
"  else";
"    this.type = \"binary\";";
"    this.first = left;";
"    this.second = sequence;";
"  endif";
"endif";
"";
"return this;";
"";
"chunk_length:40";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:A9ABE8B8945FE0CB838E789178BBC5A58B841398";
"-=-=-mxyzptlk-=-=-";
.
#64:0
{parser, first} = args;
if (parser:token().id == "(")
parser:advance("(");
second = parser:expression(0);
parser:advance(")");
else
second = parser:expression(this.bp);
if (second.type != "variable")
raise("Syntax error", "Expected an identifier", parser);
endif
parser:make_identifier(second);
endif
if (parser:token().id != "(")
raise("Syntax error", "Expected `('", parser);
endif
this.type = "binary";
this.first = first;
this.second = second;
return this;
return;
"{parser, first} = args;";
"";
"if (parser:token().id == \"(\")";
"  parser:advance(\"(\");";
"  second = parser:expression(0);";
"  parser:advance(\")\");";
"else";
"  second = parser:expression(this.bp);";
"  if (second.type != \"variable\")";
"    raise(\"Syntax error\", \"Expected an identifier\", parser);";
"  endif";
"  parser:make_identifier(second);";
"endif";
"";
"if (parser:token().id != \"(\")";
"  raise(\"Syntax error\", \"Expected `('\", parser);";
"endif";
"";
"this.type = \"binary\";";
"this.first = first;";
"this.second = second;";
"";
"return this;";
"";
"chunk_length:23";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:B9DFBD0CCD5EEDED7AC95EC7FAD47D65829DDBEE";
"-=-=-mxyzptlk-=-=-";
.
#65:0
{parser, first} = args;
if (parser:token().id == "(")
parser:advance("(");
second = parser:expression(0);
parser:advance(")");
else
second = parser:expression(this.bp);
if (second.type != "variable")
raise("Syntax error", "Expected an identifier", parser);
endif
parser:make_identifier(second);
endif
this.type = "binary";
this.first = first;
this.second = second;
return this;
return;
"{parser, first} = args;";
"";
"if (parser:token().id == \"(\")";
"  parser:advance(\"(\");";
"  second = parser:expression(0);";
"  parser:advance(\")\");";
"else";
"  second = parser:expression(this.bp);";
"  if (second.type != \"variable\")";
"    raise(\"Syntax error\", \"Expected an identifier\", parser);";
"  endif";
"  parser:make_identifier(second);";
"endif";
"";
"this.type = \"binary\";";
"this.first = first;";
"this.second = second;";
"";
"return this;";
"";
"chunk_length:19";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:C3E0624F254D64CFCB9D8CE99CBFEA6B40E2E6B1";
"-=-=-mxyzptlk-=-=-";
.
#66:0
{parser} = args;
first = parser:expression(700);
if (first.id == "(end)")
raise("Syntax error", "Expected an expression", parser);
endif
this.type = "unary";
this.first = first;
return this;
return;
"{parser} = args;";
"";
"first = parser:expression(700);";
"";
"if (first.id == \"(end)\")";
"  raise(\"Syntax error\", \"Expected an expression\", parser);";
"endif";
"";
"this.type = \"unary\";";
"this.first = first;";
"";
"return this;";
"";
"chunk_length:12";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:71052EB9A64F517E3CBE29438E498136C830D190";
"-=-=-mxyzptlk-=-=-";
.
#66:1
{parser, first} = args;
id = parser:push("@", 0, this.plastic.prefix_operator_proto);
if ((token = parser:token()).id == "ANY")
parser:advance("ANY");
symbol = parser.symbols["ANY"];
parser:reserve_keyword(symbol);
second = {token};
else
second = this.plastic.utilities:parse_list_sequence(parser, ",", "");
if (second[$].id == "(end)")
raise("Syntax error", "Expected `ANY' or a list of expressions", parser);
endif
endif
parser:pop(id);
if ((token = parser:token()).id == "=>")
parser:advance("=>");
third = parser:expression(0);
if (third.id == "(end)")
raise("Syntax error", "Expected an expression", parser);
endif
this.type = "ternary";
this.first = first;
this.second = second;
this.third = third;
else
this.type = "binary";
this.first = first;
this.second = second;
endif
return this;
return;
"{parser, first} = args;";
"";
"/* Error codes are either the keyword `ANY' or a list of expressions";
" * (see 4.1.12 Catching Errors in Expressions).";
" */";
"id = parser:push(\"@\", 0, this.plastic.prefix_operator_proto);";
"";
"if ((token = parser:token()).id == \"ANY\")";
"  parser:advance(\"ANY\");";
"  symbol = parser.symbols[\"ANY\"];";
"  parser:reserve_keyword(symbol);";
"  second = {token};";
"else";
"  second = this.plastic.utilities:parse_list_sequence(parser, \",\", \"\");";
"";
"  if (second[$].id == \"(end)\")";
"    raise(\"Syntax error\", \"Expected `ANY' or a list of expressions\", parser);";
"  endif";
"endif";
"";
"parser:pop(id);";
"";
"if ((token = parser:token()).id == \"=>\")";
"  parser:advance(\"=>\");";
"  third = parser:expression(0);";
"";
"  if (third.id == \"(end)\")";
"    raise(\"Syntax error\", \"Expected an expression\", parser);";
"  endif";
"";
"  this.type = \"ternary\";";
"  this.first = first;";
"  this.second = second;";
"  this.third = third;";
"else";
"  this.type = \"binary\";";
"  this.first = first;";
"  this.second = second;";
"endif";
"";
"return this;";
"";
"chunk_length:41";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:3F74393AE60842B8E06B0DEB07E005C4B0350E3B";
"-=-=-mxyzptlk-=-=-";
.
#67:0
{parser, first} = args;
second = parser:expression(0);
parser:token("|");
third = parser:expression(0);
if ((second.id == "(end)") || (third.id == "(end)"))
raise("Syntax error", "Expected an expression", parser);
endif
this.type = "ternary";
this.first = first;
this.second = second;
this.third = third;
return this;
return;
"{parser, first} = args;";
"";
"second = parser:expression(0);";
"parser:token(\"|\");";
"third = parser:expression(0);";
"";
"if (second.id == \"(end)\" || third.id == \"(end)\")";
"  raise(\"Syntax error\", \"Expected an expression\", parser);";
"endif";
"";
"this.type = \"ternary\";";
"this.first = first;";
"this.second = second;";
"this.third = third;";
"";
"return this;";
"";
"chunk_length:16";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:5437C1BBEF59856CD0E8FF421B0C741D0AA42CE2";
"-=-=-mxyzptlk-=-=-";
.
#68:0
{parser} = args;
parser:reserve_statement(this);
a = {};
variables = {};
variable = parser:token();
parser:make_variable(variable);
parser:advance();
variables = {@variables, variable};
if (parser:token().id == ",")
while (parser:token().id == ",")
parser:advance(",");
variable = parser:token();
parser:make_variable(variable);
parser:advance();
variables = {@variables, variable};
endwhile
elseif (parser:token().id == "->")
while (parser:token().id == "->")
parser:advance("->");
variable = parser:token();
parser:make_variable(variable);
parser:advance();
variables = {variable, @variables};
endwhile
endif
a = {@a, @variables};
for _, i in (variables)
variables[i] = variables[i].id;
endfor
parser:token("in");
symbol = parser.symbols["in"];
parser:reserve_keyword(symbol);
if (parser:token().id == "[")
this.subtype = "range";
(length(a) < 2) || raise("Syntax error", "Too many loop variables", parser);
parser:token("[");
first = parser:expression(0);
a = {@a, first};
parser:token("..");
second = parser:expression(0);
a = {@a, second};
parser:token("]");
else
this.subtype = "collection";
(length(a) < 3) || raise("Syntax error", "Too many loop variables", parser);
parser:token("(");
expression = parser:expression(0);
a = {@a, expression};
parser:token(")");
endif
parser.loop_variables = {@parser.loop_variables, @variables};
parser.loop_depth = parser.loop_depth + 1;
statements = parser:statements("endfor", "end");
a = {@a, statements};
l = length(variables);
parser.loop_variables = parser.loop_variables[1..$ - l];
parser.loop_depth = parser.loop_depth - 1;
if ((id = parser:token().id) == "endfor")
parser:advance("endfor");
else
parser:advance("end");
endif
symbol = parser.symbols[id];
parser:reserve_keyword(symbol);
this.value = a;
return this;
return;
"{parser} = args;";
"";
"/* update the symbol table */";
"parser:reserve_statement(this);";
"";
"a = {};";
"";
"/* the index(s) */";
"variables = {};";
"";
"variable = parser:token();";
"parser:make_variable(variable);";
"parser:advance();";
"variables = {@variables, variable};";
"";
"if (parser:token().id == \",\")";
"  while (parser:token().id == \",\")";
"    parser:advance(\",\");";
"    variable = parser:token();";
"    parser:make_variable(variable);";
"    parser:advance();";
"    variables = {@variables, variable};";
"  endwhile";
"elseif (parser:token().id == \"->\")";
"  while (parser:token().id == \"->\")";
"    parser:advance(\"->\");";
"    variable = parser:token();";
"    parser:make_variable(variable);";
"    parser:advance();";
"    variables = {variable, @variables};";
"  endwhile";
"endif";
"";
"a = {@a, @variables};";
"";
"for _, i in (variables)";
"  variables[i] = variables[i].id;";
"endfor";
"";
"parser:token(\"in\");";
"";
"/* update the symbol table */";
"symbol = parser.symbols[\"in\"];";
"parser:reserve_keyword(symbol);";
"";
"/* could be a range or a collection */";
"if (parser:token().id == \"[\")";
"  /* range */";
"  this.subtype = \"range\";";
"  length(a) < 2 || raise(\"Syntax error\", \"Too many loop variables\", parser);";
"  parser:token(\"[\");";
"  first = parser:expression(0);";
"  a = {@a, first};";
"  parser:token(\"..\");";
"  second = parser:expression(0);";
"  a = {@a, second};";
"  parser:token(\"]\");";
"else";
"  /* collection */";
"  this.subtype = \"collection\";";
"  length(a) < 3 || raise(\"Syntax error\", \"Too many loop variables\", parser);";
"  parser:token(\"(\");";
"  expression = parser:expression(0);";
"  a = {@a, expression};";
"  parser:token(\")\");";
"endif";
"";
"/* the body */";
"parser.loop_variables = {@parser.loop_variables, @variables};";
"parser.loop_depth = parser.loop_depth + 1;";
"";
"statements = parser:statements(\"endfor\", \"end\");";
"a = {@a, statements};";
"";
"l = length(variables);";
"parser.loop_variables = parser.loop_variables[1..$ - l];";
"parser.loop_depth = parser.loop_depth - 1;";
"";
"/* the last token must be \"endfor\" or \"end\" */";
"if ((id = parser:token().id) == \"endfor\")";
"  parser:advance(\"endfor\");";
"else";
"  parser:advance(\"end\");";
"endif";
"";
"/* update the symbol table */";
"symbol = parser.symbols[id];";
"parser:reserve_keyword(symbol);";
"";
"/* store the parts in this token's `value' */";
"this.value = a;";
"";
"return this;";
"";
"chunk_length:93";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:5AAB8E9CAAFE384224B1C38E9A1D2672AB4B26C6";
"-=-=-mxyzptlk-=-=-";
.
#69:0
{parser} = args;
parser:reserve_statement(this);
end = tostr("end", this.id);
a = {};
variables = {};
if (((type = parser:token().type) == "variable") || (type == "name"))
variable = parser:token();
parser:make_variable(variable);
parser:advance();
variables = {@variables, variable.id};
a = {@a, variable};
endif
parser:token("(");
expression = parser:expression(0);
a = {@a, expression};
parser:token(")");
parser.loop_variables = {@parser.loop_variables, @variables};
parser.loop_depth = parser.loop_depth + 1;
statements = parser:statements(end, "end");
a = {@a, statements};
l = length(variables);
parser.loop_variables = parser.loop_variables[1..$ - l];
parser.loop_depth = parser.loop_depth - 1;
if ((id = parser:token().id) == end)
parser:advance(end);
else
parser:advance("end");
endif
symbol = parser.symbols[id];
parser:reserve_keyword(symbol);
this.value = a;
return this;
return;
"{parser} = args;";
"";
"/* update the symbol table */";
"parser:reserve_statement(this);";
"";
"end = tostr(\"end\", this.id);";
"";
"a = {};";
"";
"/* possible, optional loop name */";
"variables = {};";
"if ((type = parser:token().type) == \"variable\" || type == \"name\")";
"  variable = parser:token();";
"  parser:make_variable(variable);";
"  parser:advance();";
"  variables = {@variables, variable.id};";
"  a = {@a, variable};";
"endif";
"";
"/* the condition */";
"parser:token(\"(\");";
"expression = parser:expression(0);";
"a = {@a, expression};";
"parser:token(\")\");";
"";
"/* the body */";
"parser.loop_variables = {@parser.loop_variables, @variables};";
"parser.loop_depth = parser.loop_depth + 1;";
"";
"statements = parser:statements(end, \"end\");";
"a = {@a, statements};";
"";
"l = length(variables);";
"parser.loop_variables = parser.loop_variables[1..$ - l];";
"parser.loop_depth = parser.loop_depth - 1;";
"";
"/* the last token must be \"endwhile/enduntil\" or \"end\" */";
"if ((id = parser:token().id) == end)";
"  parser:advance(end);";
"else";
"  parser:advance(\"end\");";
"endif";
"";
"/* update the symbol table */";
"symbol = parser.symbols[id];";
"parser:reserve_keyword(symbol);";
"";
"/* store the parts in this token's `value' */";
"this.value = a;";
"";
"return this;";
"";
"chunk_length:51";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:DC2BECAEBBED52539E7926D3C715C5F443673A8D";
"-=-=-mxyzptlk-=-=-";
.
#70:0
{parser} = args;
parser:reserve_statement(this);
a = {};
if (((type = parser:token().type) == "variable") || (type == "name"))
variable = parser:token();
parser:make_variable(variable);
parser:advance();
a = {@a, variable};
endif
parser:token("(");
expression = parser:expression(0);
a = {@a, expression};
parser:token(")");
statements = parser:statements("endfork", "end");
a = {@a, statements};
if ((id = parser:token().id) == "endfork")
parser:advance("endfork");
else
parser:advance("end");
endif
symbol = parser.symbols[id];
parser:reserve_keyword(symbol);
this.value = a;
return this;
return;
"{parser} = args;";
"";
"/* update the symbol table */";
"parser:reserve_statement(this);";
"";
"a = {};";
"";
"/* possible, optional task name */";
"if ((type = parser:token().type) == \"variable\" || type == \"name\")";
"  variable = parser:token();";
"  parser:make_variable(variable);";
"  parser:advance();";
"  a = {@a, variable};";
"endif";
"";
"/* the expression */";
"parser:token(\"(\");";
"expression = parser:expression(0);";
"a = {@a, expression};";
"parser:token(\")\");";
"";
"/* the body */";
"statements = parser:statements(\"endfork\", \"end\");";
"a = {@a, statements};";
"";
"/* the last token must be \"endfork\" or \"end\" */";
"if ((id = parser:token().id) == \"endfork\")";
"  parser:advance(\"endfork\");";
"else";
"  parser:advance(\"end\");";
"endif";
"";
"/* update the symbol table */";
"symbol = parser.symbols[id];";
"parser:reserve_keyword(symbol);";
"";
"/* store the parts in this token's `value' */";
"this.value = a;";
"";
"return this;";
"";
"chunk_length:40";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:0ED7146966275E0722F7F9DF4BD7F76C03BB0DDD";
"-=-=-mxyzptlk-=-=-";
.
#71:0
{parser} = args;
parser:reserve_statement(this);
a = {};
body = parser:statements("except", "finally", "endtry", "end");
a = {@a, body};
if (parser:token().id == "finally")
parser:advance("finally");
b = parser:statements("endtry", "end");
symbol = parser.symbols["finally"];
parser:reserve_keyword(symbol);
this.subtype = "finally";
a = {@a, b};
else
b = {};
id = parser:push("@", 0, this.plastic.prefix_operator_proto);
while (parser:token().id == "except")
parser:advance("except");
if ((variable = parser:token()).id != "(")
parser:advance();
if ((variable.type != "name") && (variable.type != "variable"))
raise("Syntax error", "Variable must be an identifier", parser);
endif
parser:make_variable(variable);
parser:token("(");
if ((token = parser:token()).id == "ANY")
parser:advance("ANY");
symbol = parser.symbols["ANY"];
parser:reserve_keyword(symbol);
codes = {token};
else
codes = this.plastic.utilities:parse_list_sequence(parser, ",", ")");
endif
parser:token(")");
(!codes) && raise("Syntax error", "Codes may not be empty", parser);
b = {variable, codes};
else
parser:token("(");
if ((token = parser:token()).id == "ANY")
parser:advance("ANY");
symbol = parser.symbols["ANY"];
parser:reserve_keyword(symbol);
codes = {token};
else
codes = this.plastic.utilities:parse_list_sequence(parser, ",", ")");
endif
parser:token(")");
(!codes) && raise("Syntax error", "Codes may not be empty", parser);
b = {codes};
endif
handler = parser:statements("except", "finally", "endtry", "end");
b = {@b, handler};
symbol = parser.symbols["except"];
parser:reserve_keyword(symbol);
a = {@a, b};
endwhile
parser:pop(id);
if (!b)
raise("Syntax error", "Missing except", parser);
endif
this.subtype = "except";
endif
if ((id = parser:token().id) == "endtry")
parser:advance("endtry");
else
parser:advance("end");
endif
symbol = parser.symbols[id];
parser:reserve_keyword(symbol);
this.value = a;
return this;
return;
"{parser} = args;";
"";
"/* update the symbol table */";
"parser:reserve_statement(this);";
"";
"a = {};";
"";
"/* the body */";
"body = parser:statements(\"except\", \"finally\", \"endtry\", \"end\");";
"a = {@a, body};";
"";
"if (parser:token().id == \"finally\")";
"  parser:advance(\"finally\");";
"";
"  b = parser:statements(\"endtry\", \"end\");";
"";
"  /* update the symbol table */";
"  symbol = parser.symbols[\"finally\"];";
"  parser:reserve_keyword(symbol);";
"";
"  this.subtype = \"finally\";";
"";
"  a = {@a, b};";
"";
"else";
"  b = {};";
"";
"  id = parser:push(\"@\", 0, this.plastic.prefix_operator_proto);";
"";
"  /* the exceptions */";
"  while (parser:token().id == \"except\")";
"    parser:advance(\"except\");";
"";
"    /* variable and codes */";
"    if ((variable = parser:token()).id != \"(\")";
"      parser:advance();";
"";
"      if (variable.type != \"name\" && variable.type != \"variable\")";
"        raise(\"Syntax error\", \"Variable must be an identifier\", parser);";
"      endif";
"      parser:make_variable(variable);";
"";
"      parser:token(\"(\");";
"      if ((token = parser:token()).id == \"ANY\")";
"        parser:advance(\"ANY\");";
"        symbol = parser.symbols[\"ANY\"];";
"        parser:reserve_keyword(symbol);";
"        codes = {token};";
"      else";
"        codes = this.plastic.utilities:parse_list_sequence(parser, \",\", \")\");";
"      endif";
"      parser:token(\")\");";
"";
"      !codes && raise(\"Syntax error\", \"Codes may not be empty\", parser);";
"";
"      b = {variable, codes};";
"";
"    /* just codes */";
"    else";
"      parser:token(\"(\");";
"      if ((token = parser:token()).id == \"ANY\")";
"        parser:advance(\"ANY\");";
"        symbol = parser.symbols[\"ANY\"];";
"        parser:reserve_keyword(symbol);";
"        codes = {token};";
"      else";
"        codes = this.plastic.utilities:parse_list_sequence(parser, \",\", \")\");";
"      endif";
"      parser:token(\")\");";
"";
"      !codes && raise(\"Syntax error\", \"Codes may not be empty\", parser);";
"";
"      b = {codes};";
"";
"    endif";
"";
"    /* handler */";
"    handler = parser:statements(\"except\", \"finally\", \"endtry\", \"end\");";
"    b = {@b, handler};";
"";
"    /* update the symbol table */";
"    symbol = parser.symbols[\"except\"];";
"    parser:reserve_keyword(symbol);";
"";
"    a = {@a, b};";
"";
"  endwhile";
"";
"  parser:pop(id);";
"";
"  if (!b)";
"    raise(\"Syntax error\", \"Missing except\", parser);";
"  endif";
"";
"  this.subtype = \"except\";";
"";
"endif";
"";
"/* the last token must be \"endtry\" or \"end\" */";
"if ((id = parser:token().id) == \"endtry\")";
"  parser:advance(\"endtry\");";
"else";
"  parser:advance(\"end\");";
"endif";
"";
"/* update the symbol table */";
"symbol = parser.symbols[id];";
"parser:reserve_keyword(symbol);";
"";
"/* store the parts in this token's `value' */";
"this.value = a;";
"";
"return this;";
"";
"chunk_length:113";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:E35D0E704DAB84B635FDF374A2AE5B68C2A8A8EC";
"-=-=-mxyzptlk-=-=-";
.
#72:0
return this;
return;
"return this;";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:58CFE4977A49A7695FEE4D2F29BB87606D70E92F";
"-=-=-mxyzptlk-=-=-";
.
#73:0
{parser} = args;
first = parser:expression(700);
if (first.id == "(end)")
raise("Syntax error", "Expected an expression", parser);
endif
this.type = "unary";
this.first = first;
return this;
return;
"{parser} = args;";
"";
"first = parser:expression(700);";
"";
"if (first.id == \"(end)\")";
"  raise(\"Syntax error\", \"Expected an expression\", parser);";
"endif";
"";
"this.type = \"unary\";";
"this.first = first;";
"";
"return this;";
"";
"chunk_length:12";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:71052EB9A64F517E3CBE29438E498136C830D190";
"-=-=-mxyzptlk-=-=-";
.
#73:1
{parser, first} = args;
second = parser:expression(this.bp);
if (second.id == "(end)")
raise("Syntax error", "Expected an expression", parser);
endif
this.type = "binary";
this.first = first;
this.second = second;
return this;
return;
"{parser, first} = args;";
"";
"second = parser:expression(this.bp);";
"";
"if (second.id == \"(end)\")";
"  raise(\"Syntax error\", \"Expected an expression\", parser);";
"endif";
"";
"this.type = \"binary\";";
"this.first = first;";
"this.second = second;";
"";
"return this;";
"";
"chunk_length:13";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:A9AE696659B56975F48F68AF477F92EB2084698F";
"-=-=-mxyzptlk-=-=-";
.
#74:0
{parser} = args;
parser:reserve_statement(this);
types = {"name", "variable", "identifier"};
if ((target = parser:token()).type == "string")
parser:advance();
elseif ((target.type in types) && (target.value == "this"))
parser:advance();
elseif ((target.type in types) && (target.value[1] == "$"))
target = parser:expression();
if (target.id == ".")
temp = target;
while (temp.id == ".")
if (((temp.first.id != ".") && (!(temp.first.type in types))) && (!(temp.second.type in types)))
raise("Syntax error", tostr("Invalid reference: ", target.id), parser);
endif
temp = temp.first;
endwhile
elseif (target.value[1] == "$")
else
raise("Syntax error", tostr("Invalid reference: ", target.id), parser);
endif
else
raise("Syntax error", tostr("Invalid reference: ", target.id), parser);
endif
parser:token("use");
symbol = parser.symbols["use"];
parser:reserve_keyword(symbol);
imports = {};
if ((import = parser:token()).id == "(end)")
raise("Syntax error", "Expected an identifier", parser);
elseif (!(import.type in types))
raise("Syntax error", "Import must be an identifier", parser);
endif
parser:make_identifier(import);
parser:advance();
imports = {@imports, import};
while (parser:token().id == ",")
parser:advance(",");
if ((import = parser:token()).id == "(end)")
raise("Syntax error", "Expected an identifier", parser);
elseif (!(import.type in types))
raise("Syntax error", "Import must be an identifier", parser);
endif
parser:make_identifier(import);
parser:advance();
imports = {@imports, import};
endwhile
if (target.type == "string")
temp = parser.plastic.invocation_operator_proto:create("(");
temp.type = "binary";
temp.first = parser.plastic.name_proto:create("$lookup");
temp.first.type = "identifier";
temp.first.value = "$lookup";
temp.second = {target};
target = temp;
endif
first = parser.plastic.name_proto:create(tostr(random()));
first.type = "unique";
if (!length(imports))
raise("Syntax error", "Missing imports", parser);
endif
for import in (imports)
if (`parser.imports[import.id] ! E_RANGE' != E_RANGE)
raise("Syntax error", "Duplicate imports", parser);
endif
parser.imports[import.id] = first;
endfor
result = parser.plastic.assignment_operator_proto:create("=");
result.type = "binary";
result.first = first;
result.second = target;
return result;
return;
"{parser} = args;";
"";
"/* update the symbol table */";
"parser:reserve_statement(this);";
"";
"types = {\"name\", \"variable\", \"identifier\"};";
"";
"/* the reference */";
"if ((target = parser:token()).type == \"string\")";
"  parser:advance();";
"elseif (target.type in types && target.value == \"this\")";
"  parser:advance();";
"elseif (target.type in types && target.value[1] == \"$\")";
"  target = parser:expression();";
"  if (target.id == \".\")";
"    temp = target;";
"    while (temp.id == \".\")";
"      if ((temp.first.id != \".\" && !(temp.first.type in types)) && !(temp.second.type in types))";
"        raise(\"Syntax error\", tostr(\"Invalid reference: \", target.id), parser);";
"      endif";
"      temp = temp.first;";
"    endwhile";
"  elseif (target.value[1] == \"$\")";
"    /* ok */";
"  else";
"    raise(\"Syntax error\", tostr(\"Invalid reference: \", target.id), parser);";
"  endif";
"else";
"  raise(\"Syntax error\", tostr(\"Invalid reference: \", target.id), parser);";
"endif";
"";
"parser:token(\"use\");";
"";
"/* update the symbol table */";
"symbol = parser.symbols[\"use\"];";
"parser:reserve_keyword(symbol);";
"";
"/* the import(s) */";
"imports = {};";
"";
"if ((import = parser:token()).id == \"(end)\")";
"  raise(\"Syntax error\", \"Expected an identifier\", parser);";
"elseif (!(import.type in types))";
"  raise(\"Syntax error\", \"Import must be an identifier\", parser);";
"endif";
"parser:make_identifier(import);";
"parser:advance();";
"imports = {@imports, import};";
"";
"while (parser:token().id == \",\")";
"  parser:advance(\",\");";
"  if ((import = parser:token()).id == \"(end)\")";
"    raise(\"Syntax error\", \"Expected an identifier\", parser);";
"  elseif (!(import.type in types))";
"    raise(\"Syntax error\", \"Import must be an identifier\", parser);";
"  endif";
"  parser:make_identifier(import);";
"  parser:advance();";
"  imports = {@imports, import};";
"endwhile";
"";
"/* generate code */";
"if (target.type == \"string\")";
"  temp = parser.plastic.invocation_operator_proto:create(\"(\");";
"  temp.type = \"binary\";";
"  temp.first = parser.plastic.name_proto:create(\"$lookup\");";
"  temp.first.type = \"identifier\";";
"  temp.first.value = \"$lookup\";";
"  temp.second = {target};";
"  target = temp;";
"endif";
"";
"first = parser.plastic.name_proto:create(tostr(random()));";
"first.type = \"unique\";";
"";
"if (!length(imports))";
"  raise(\"Syntax error\", \"Missing imports\", parser);";
"endif";
"";
"for import in (imports)";
"  if (`parser.imports[import.id] ! E_RANGE' != E_RANGE)";
"    raise(\"Syntax error\", \"Duplicate imports\", parser);";
"  endif";
"  parser.imports[import.id] = first;";
"endfor";
"";
"result = parser.plastic.assignment_operator_proto:create(\"=\");";
"result.type = \"binary\";";
"result.first = first;";
"result.second = target;";
"";
"return result;";
"";
"chunk_length:92";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:7DB690B77D7FD6951C7E3F6EF124D6789998DC2D";
"-=-=-mxyzptlk-=-=-";
.
#78:0
{child} = args;
return isa(child, this);
return;
"{child} = args";
"";
"return isa(child, this)";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:6E07B530CF1FB1C121941C32D2DC1A5ACFCC3149";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"INT\"],\" \",[\"var\",\"context\"],\":\",[\"strong\",\"is_parent_of\"],\"(\",[\"var\",\"OBJ object\"],\")\"]]";
"[\"p\",\"Returns true if this \",[\"var\",\"context\"],\" is a parent/ancestor of \",[\"var\",\"object\"],\".\"]";
"[\"pre\",{\"class\":\"example\"},[\"code\",{\"class\":\"language-moocode\"},\"context:is_parent_of(other)        => 1\"]]";
"";
"chunk_length:3";
"chunk_type:documentation";
"content_type:application/json";
"sha1:325C0F52A13356980EEF8B04ABF172F92ADBA047";
"-=-=-mxyzptlk-=-=-";
.
#78:1
return;
"";
"chunk_length:0";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:BF21A9E8FBC5A3846FB05B4FA0859E0917B2202F";
"-=-=-mxyzptlk-=-=-";
"[\"p\",[\"em\",\"No-op\"],\" implementation of \",[\"strong\",\"handle_element()\"],\".\"]";
"";
"chunk_length:1";
"chunk_type:documentation";
"content_type:application/json";
"sha1:2E865FA8D73468D5BFCB8C9257F68C6CB769DD54";
"-=-=-mxyzptlk-=-=-";
.
#78:2
return;
"";
"chunk_length:0";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:BF21A9E8FBC5A3846FB05B4FA0859E0917B2202F";
"-=-=-mxyzptlk-=-=-";
"[\"p\",[\"em\",\"No-op\"],\" implementation of \",[\"strong\",\"handle_text()\"],\".\"]";
"";
"chunk_length:1";
"chunk_type:documentation";
"content_type:application/json";
"sha1:AAF8E3AF5DD07F6C003717DB5CDA07F2FA4D6F70";
"-=-=-mxyzptlk-=-=-";
.
#79:0
$restrict_to_caller($blink.utilities, "traverse");
_1228983399 = $lookup("utilities");
{schema, line} = args;
valid_tags = "any";
if (this.parent)
{parent, _, _} = _1228983399:parse_element(this.parent);
if (rule = _1228983399:lookup_element(parent, schema))
{_, _, valid_tags} = rule;
endif
endif
saved_parent = this.parent;
this.parent = line;
{tag, attributes, body} = _1228983399:parse_element(line);
if (rule = _1228983399:lookup_element(tag, schema))
{_, valid_attributes, _} = rule;
if ((valid_tags == "any") || (tag in valid_tags))
if ((attributes == 0) || ((diff = attributes:keys():difference(valid_attributes)) == {}))
caller:traverse(body, this, schema);
else
raise("-*-invalid-*-", tostr("Tag has invalid attribute(s): ", tag, " -> ", diff:join()));
endif
else
raise("-*-invalid-*-", tostr("Tag in invalid nested position: ", tag));
endif
else
raise("-*-invalid-*-", tostr("Tag is invalid: ", tag));
endif
this.parent = saved_parent;
return;
"$restrict_to_caller($blink.utilities, \"traverse\")";
"";
"from \"utilities\" use parse_element, lookup_element";
"";
"{schema, line} = args";
"";
"valid_tags = \"any\"";
"";
"if (this.parent)";
"  {parent, _, _} = parse_element(this.parent)";
"  if ((rule = lookup_element(parent, schema)))";
"    {_, _, valid_tags} = rule";
"  end";
"end";
"";
"saved_parent = this.parent";
"this.parent = line";
"";
"{tag, attributes, body} = parse_element(line)";
"";
"if ((rule = lookup_element(tag, schema)))";
"  {_, valid_attributes, _} = rule";
"  if (valid_tags == \"any\" || tag in valid_tags)";
"    if (attributes == 0 || (diff = attributes:keys():difference(valid_attributes)) == {})";
"      caller:traverse(body, this, schema)";
"    else";
"      raise(\"-*-invalid-*-\", tostr(\"Tag has invalid attribute(s): \", tag, \" -> \", diff:join()))";
"    end";
"  else";
"    raise(\"-*-invalid-*-\", tostr(\"Tag in invalid nested position: \", tag))";
"  end";
"else";
"  raise(\"-*-invalid-*-\", tostr(\"Tag is invalid: \", tag))";
"end";
"";
"this.parent = saved_parent";
"";
"chunk_length:36";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:5C9E326D4BD0D8F34F12EF6443E412CD3C012641";
"-=-=-mxyzptlk-=-=-";
"[\"p\",\"See \",[\"strong\",\"$blink.utilities.context_proto:handle_element()\"],\".\"]";
"";
"chunk_length:1";
"chunk_type:documentation";
"content_type:application/json";
"sha1:33B7B92BE633F269960EFED6AE63168E3F461C0E";
"-=-=-mxyzptlk-=-=-";
.
#79:1
$restrict_to_caller($blink.utilities, "traverse");
return;
"$restrict_to_caller($blink.utilities, \"traverse\")";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:EDBCE417A5F5EF87FCE7F8FAB39FA1AAEAEE3D3D";
"-=-=-mxyzptlk-=-=-";
"[\"p\",\"See \",[\"strong\",\"$blink.utilities.context_proto:handle_text()\"],\".\"]";
"";
"chunk_length:1";
"chunk_type:documentation";
"content_type:application/json";
"sha1:AD126944ADB6CFAFD5A8F56E90E496D4D98ABDCC";
"-=-=-mxyzptlk-=-=-";
.
#80:0
$restrict_to_caller($blink.utilities, "traverse");
_178476469 = $lookup("utilities");
{schema, line} = args;
valid_tags = "any";
if (this.parent)
{parent, _, _} = _178476469:parse_element(this.parent);
if (rule = _178476469:lookup_element(parent, schema))
{_, _, valid_tags} = rule;
endif
endif
saved_parent = this.parent;
this.parent = line;
{tag, attributes, body} = _178476469:parse_element(line);
if (rule = _178476469:lookup_element(tag, schema))
{_, valid_attributes, _} = rule;
if ((valid_tags == "any") || (tag in valid_tags))
if (attributes != 0)
lines = this.lines;
this.lines = {};
caller:traverse(body, this, schema);
this.lines = {@lines, {tag, attributes:slice(valid_attributes), @this.lines}};
else
lines = this.lines;
this.lines = {};
caller:traverse(body, this, schema);
this.lines = {@lines, {tag, @this.lines}};
endif
else
lines = this.lines;
this.lines = {};
caller:traverse(body, this, schema);
this.lines = {@lines, @this.lines};
endif
else
lines = this.lines;
this.lines = {};
caller:traverse(body, this, schema);
this.lines = {@lines, @this.lines};
endif
this.parent = saved_parent;
return;
"$restrict_to_caller($blink.utilities, \"traverse\")";
"";
"from \"utilities\" use parse_element, lookup_element";
"";
"{schema, line} = args";
"";
"valid_tags = \"any\"";
"";
"if (this.parent)";
"  {parent, _, _} = parse_element(this.parent)";
"  if ((rule = lookup_element(parent, schema)))";
"    {_, _, valid_tags} = rule";
"  end";
"end";
"";
"saved_parent = this.parent";
"this.parent = line";
"";
"{tag, attributes, body} = parse_element(line)";
"";
"if ((rule = lookup_element(tag, schema)))";
"  {_, valid_attributes, _} = rule";
"  if (valid_tags == \"any\" || tag in valid_tags)";
"    if (attributes != 0)";
"      lines = this.lines";
"      this.lines = {}";
"      caller:traverse(body, this, schema)";
"      this.lines = {@lines, {tag, attributes:slice(valid_attributes), @this.lines}}";
"    else";
"      lines = this.lines";
"      this.lines = {}";
"      caller:traverse(body, this, schema)";
"      this.lines = {@lines, {tag, @this.lines}}";
"    end";
"  else";
"    lines = this.lines";
"    this.lines = {}";
"    caller:traverse(body, this, schema)";
"    this.lines = {@lines, @this.lines}";
"  end";
"else";
"  lines = this.lines";
"  this.lines = {}";
"  caller:traverse(body, this, schema)";
"  this.lines = {@lines, @this.lines}";
"end";
"";
"this.parent = saved_parent";
"";
"chunk_length:48";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:35CE9EC3DF9C9CEA4BAB7AEF5F95083B038BBDCE";
"-=-=-mxyzptlk-=-=-";
"[\"p\",\"See \",[\"strong\",\"$blink.utilities.context_proto:handle_element()\"],\".\"]";
"";
"chunk_length:1";
"chunk_type:documentation";
"content_type:application/json";
"sha1:33B7B92BE633F269960EFED6AE63168E3F461C0E";
"-=-=-mxyzptlk-=-=-";
.
#80:1
$restrict_to_caller($blink.utilities, "traverse");
{schema, line} = args;
this.lines = {@this.lines, tostr(line)};
return;
"$restrict_to_caller($blink.utilities, \"traverse\")";
"";
"{schema, line} = args";
"";
"this.lines = {@this.lines, tostr(line)}";
"";
"chunk_length:5";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:11CE7A57B997AB63A28B29049F0EA920800FB0CF";
"-=-=-mxyzptlk-=-=-";
"[\"p\",\"See \",[\"strong\",\"$blink.utilities.context_proto:handle_text()\"],\".\"]";
"";
"chunk_length:1";
"chunk_type:documentation";
"content_type:application/json";
"sha1:AD126944ADB6CFAFD5A8F56E90E496D4D98ABDCC";
"-=-=-mxyzptlk-=-=-";
.
#81:0
$protected();
object = create(parents(this), 1);
object.style = this.style;
return object;
return;
"$protected()";
"";
"object = create(parents(this), 1)";
"";
"object.style = this.style";
"";
"return object";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:570BBE2A90DF715E0602B6BB9C244A6788A6F2BC";
"-=-=-mxyzptlk-=-=-";
.
#81:1
{lines, ?schema = 0, ?style = 0} = args;
lines = this.utilities:sanitize(lines, schema);
context = create(this, 1);
style && (context.style = style);
this.utilities:traverse(lines, context, schema);
if (context.block_level)
return context.lines;
else
return {tostr(@context.lines)};
endif
return;
"{lines, schema = 0, style = 0} = args";
"";
"lines = this.utilities:sanitize(lines, schema)";
"";
"context = create(this, 1)";
"style && (context.style = style)";
"";
"this.utilities:traverse(lines, context, schema)";
"";
"if (context.block_level)";
"  return context.lines";
"else";
"  return {tostr(@context.lines)}";
"end";
"";
"chunk_length:14";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:0DE2D1876FA4BC7E1A5046B3BF18A644C0F9D549";
"-=-=-mxyzptlk-=-=-";
.
#82:0
$restrict_to_caller(this.utilities, "traverse");
{schema, line} = args;
{tag, attributes, body} = this.utilities:parse_element(line);
context = this:clone();
context.parent = line;
caller:traverse(body, context, schema);
if (`indent = this.style[tag]["indent"] ! E_RANGE')
indent = " ":fill(toint(indent));
for i in [1..length(context.lines)]
context.lines[i] = tostr(indent, context.lines[i]);
endfor
endif
whitespace_preserve = `this.style[tag]["whitespace"] == "preserve" ! E_RANGE => 0';
display_block = `this.style[tag]["display"] == "block" ! E_RANGE => 0';
if (context.block_level || whitespace_preserve)
this.lines = {@this.lines, @context.lines};
else
this.lines = {@this.lines, tostr(@context.lines)};
endif
if (`this.style[tag]["transform"] == "uppercase" ! E_RANGE')
this.lines[$] = this.lines[$]:to_uppercase();
endif
if (`border = this.style[tag]["border"] ! E_RANGE')
this.lines = {@this.lines, border:fill(this.lines[$]:length())};
endif
if (`this.style[tag]["margin"] == "bottom" ! E_RANGE')
this.lines = {@this.lines, ""};
endif
this.block_level = ((this.block_level || context.block_level) || whitespace_preserve) || display_block;
return;
"$restrict_to_caller(this.utilities, \"traverse\")";
"";
"{schema, line} = args";
"";
"{tag, attributes, body} = this.utilities:parse_element(line)";
"";
"context = this:clone()";
"";
"context.parent = line";
"";
"caller:traverse(body, context, schema)";
"";
"if ((indent = this.style[tag][\"indent\"]) !! E_RANGE)";
"  indent = \" \":fill(toint(indent))";
"  for i in [1..length(context.lines)]";
"    context.lines[i] = tostr(indent, context.lines[i])";
"  end";
"end";
"";
"whitespace_preserve = (this.style[tag][\"whitespace\"] == \"preserve\" !! E_RANGE => 0)";
"display_block = (this.style[tag][\"display\"] == \"block\" !! E_RANGE => 0)";
"";
"if (context.block_level || whitespace_preserve)";
"  this.lines = {@this.lines, @context.lines}";
"else";
"  this.lines = {@this.lines, tostr(@context.lines)}";
"end";
"";
"if (this.style[tag][\"transform\"] == \"uppercase\" !! E_RANGE)";
"  this.lines[$] = this.lines[$]:to_uppercase()";
"end";
"";
"if ((border = this.style[tag][\"border\"]) !! E_RANGE)";
"  this.lines = {@this.lines, border:fill(this.lines[$]:length())}";
"end";
"";
"if (this.style[tag][\"margin\"] == \"bottom\" !! E_RANGE)";
"  this.lines = {@this.lines, \"\"}";
"end";
"";
"this.block_level = this.block_level || context.block_level || whitespace_preserve || display_block";
"";
"chunk_length:41";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:CE8270FACBC375265952E9E0F394420F4521F938";
"-=-=-mxyzptlk-=-=-";
"[\"p\",\"See \",[\"strong\",\"$blink.utilities.context_proto:handle_element()\"],\".\"]";
"";
"chunk_length:1";
"chunk_type:documentation";
"content_type:application/json";
"sha1:33B7B92BE633F269960EFED6AE63168E3F461C0E";
"-=-=-mxyzptlk-=-=-";
.
#82:1
$restrict_to_caller(this.utilities, "traverse");
{schema, line} = args;
this.lines = {@this.lines, tostr(line)};
return;
"$restrict_to_caller(this.utilities, \"traverse\")";
"";
"{schema, line} = args";
"";
"this.lines = {@this.lines, tostr(line)}";
"";
"chunk_length:5";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:9E39E2A94B2E9433AC49C14F8CB8F321697C668A";
"-=-=-mxyzptlk-=-=-";
"[\"p\",\"See \",[\"strong\",\"$blink.utilities.context_proto:handle_text()\"],\".\"]";
"";
"chunk_length:1";
"chunk_type:documentation";
"content_type:application/json";
"sha1:AD126944ADB6CFAFD5A8F56E90E496D4D98ABDCC";
"-=-=-mxyzptlk-=-=-";
.
#83:0
$restrict_to_caller(this.utilities, "traverse");
{schema, line} = args;
{tag, attributes, body} = this.utilities:parse_element(line);
original_style_stack = this.style_stack;
if (`this.style[tag]["font-weight"] == "bold" ! E_RANGE')
this.style_stack = {"bold", @this.style_stack};
endif
if (`this.style[tag]["font-style"] == "italic" ! E_RANGE')
this.style_stack = {"underline", @this.style_stack};
endif
if ((tag == "span") && `attributes["class"] == "warning" ! E_RANGE')
this.style_stack = {@this.style_stack, "yellow"};
endif
if ((tag == "span") && `is_member(attributes["class"], {"error", "deletion"}) ! E_RANGE')
this.style_stack = {@this.style_stack, "red"};
endif
if ((tag == "span") && `attributes["class"] == "information" ! E_RANGE')
this.style_stack = {@this.style_stack, "blue"};
endif
if ((tag == "span") && `is_member(attributes["class"], {"success", "insertion"}) ! E_RANGE')
this.style_stack = {@this.style_stack, "green"};
endif
context = this:clone();
context.style_stack = this.style_stack;
before = this.style_stack ? this:_ansify(this.style_stack) | "";
after = this.style_stack ? this:_ansify(original_style_stack) | "";
this.style_stack = original_style_stack;
context.parent = line;
caller:traverse(body, context, schema);
if (`indent = this.style[tag]["indent"] ! E_RANGE')
indent = " ":fill(toint(indent));
for i in [1..length(context.lines)]
context.lines[i] = tostr(indent, context.lines[i]);
endfor
endif
whitespace_preserve = `this.style[tag]["whitespace"] == "preserve" ! E_RANGE => 0';
display_block = `this.style[tag]["display"] == "block" ! E_RANGE => 0';
if (context.block_level || whitespace_preserve)
this.lines = {@this.lines, @context.lines};
else
this.lines = {@this.lines, tostr(before, @context.lines, after)};
endif
if (`this.style[tag]["transform"] == "uppercase" ! E_RANGE')
this.lines[$] = this.lines[$]:to_uppercase();
endif
if (`border = this.style[tag]["border"] ! E_RANGE')
this.lines = {@this.lines, border:fill(this.lines[$]:length())};
endif
if (`this.style[tag]["margin"] == "bottom" ! E_RANGE')
this.lines = {@this.lines, ""};
endif
this.block_level = ((this.block_level || context.block_level) || whitespace_preserve) || display_block;
return;
"$restrict_to_caller(this.utilities, \"traverse\")";
"";
"{schema, line} = args";
"";
"{tag, attributes, body} = this.utilities:parse_element(line)";
"";
"original_style_stack = this.style_stack";
"";
"if (this.style[tag][\"font-weight\"] == \"bold\" !! E_RANGE)";
"  this.style_stack = {\"bold\", @this.style_stack}";
"end";
"if (this.style[tag][\"font-style\"] == \"italic\" !! E_RANGE)";
"  this.style_stack = {\"underline\", @this.style_stack}";
"end";
"if (tag == \"span\" && (attributes[\"class\"] == \"warning\" !! E_RANGE))";
"  this.style_stack = {@this.style_stack, \"yellow\"}";
"end";
"if (tag == \"span\" && (is_member(attributes[\"class\"], {\"error\", \"deletion\"}) !! E_RANGE))";
"  this.style_stack = {@this.style_stack, \"red\"}";
"end";
"if (tag == \"span\" && (attributes[\"class\"] == \"information\" !! E_RANGE))";
"  this.style_stack = {@this.style_stack, \"blue\"}";
"end";
"if (tag == \"span\" && (is_member(attributes[\"class\"], {\"success\", \"insertion\"}) !! E_RANGE))";
"  this.style_stack = {@this.style_stack, \"green\"}";
"end";
"";
"context = this:clone()";
"";
"context.style_stack = this.style_stack";
"";
"before = this.style_stack ? this:_ansify(this.style_stack) | \"\"";
"after = this.style_stack ? this:_ansify(original_style_stack) | \"\"";
"";
"this.style_stack = original_style_stack";
"";
"context.parent = line";
"";
"caller:traverse(body, context, schema)";
"";
"if ((indent = this.style[tag][\"indent\"]) !! E_RANGE)";
"  indent = \" \":fill(toint(indent))";
"  for i in [1..length(context.lines)]";
"    context.lines[i] = tostr(indent, context.lines[i])";
"  end";
"end";
"";
"whitespace_preserve = (this.style[tag][\"whitespace\"] == \"preserve\" !! E_RANGE => 0)";
"display_block = (this.style[tag][\"display\"] == \"block\" !! E_RANGE => 0)";
"";
"if (context.block_level || whitespace_preserve)";
"  this.lines = {@this.lines, @context.lines}";
"else";
"  this.lines = {@this.lines, tostr(before, @context.lines, after)}";
"end";
"";
"if (this.style[tag][\"transform\"] == \"uppercase\" !! E_RANGE)";
"  this.lines[$] = this.lines[$]:to_uppercase()";
"end";
"";
"if ((border = this.style[tag][\"border\"]) !! E_RANGE)";
"  this.lines = {@this.lines, border:fill(this.lines[$]:length())}";
"end";
"";
"if (this.style[tag][\"margin\"] == \"bottom\" !! E_RANGE)";
"  this.lines = {@this.lines, \"\"}";
"end";
"";
"this.block_level = this.block_level || context.block_level || whitespace_preserve || display_block";
"";
"chunk_length:69";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:9EAAE0EC8D63F6ADAF37244338EA39314DF82DCC";
"-=-=-mxyzptlk-=-=-";
.
#83:1
$restrict_to_caller(this.utilities, "traverse");
{schema, line} = args;
this.lines = {@this.lines, tostr(line):strsub("~", "~7E")};
return;
"$restrict_to_caller(this.utilities, \"traverse\")";
"";
"{schema, line} = args";
"";
"this.lines = {@this.lines, tostr(line):strsub(\"~\", \"~7E\")}";
"";
"chunk_length:5";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:2C10E5583CB706C4B0E44C8B1A64C60D94EAAEF1";
"-=-=-mxyzptlk-=-=-";
.
#83:2
$private();
{stack} = args;
output = "~1B[0m";
("bold" in stack) && (output = tostr(output, "~1B[1m"));
("underline" in stack) && (output = tostr(output, "~1B[4m"));
while (stack)
if (stack[$] == "blue")
output = tostr(output, "~1B[34m");
break;
elseif (stack[$] == "green")
output = tostr(output, "~1B[32m");
break;
elseif (stack[$] == "yellow")
output = tostr(output, "~1B[33m");
break;
elseif (stack[$] == "red")
output = tostr(output, "~1B[31m");
break;
endif
stack = stack[1..$ - 1];
endwhile
return output;
return;
"$private()";
"";
"{stack} = args";
"";
"output = \"~1B[0m\"";
"";
"(\"bold\" in stack) && (output = tostr(output, \"~1B[1m\"))";
"(\"underline\" in stack) && (output = tostr(output, \"~1B[4m\"))";
"";
"while (stack)";
"  if (stack[$] == \"blue\")";
"    output = tostr(output, \"~1B[34m\")";
"    break";
"  elseif (stack[$] == \"green\")";
"    output = tostr(output, \"~1B[32m\")";
"    break";
"  elseif (stack[$] == \"yellow\")";
"    output = tostr(output, \"~1B[33m\")";
"    break";
"  elseif (stack[$] == \"red\")";
"    output = tostr(output, \"~1B[31m\")";
"    break";
"  endif";
"  stack = stack[1 .. ($ - 1)]";
"endwhile";
"";
"return output";
"";
"chunk_length:27";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:F8565646376C5E306625BD8E0EBAE61009CC510A";
"-=-=-mxyzptlk-=-=-";
.
#84:0
$restrict_to_caller(this.utilities, "traverse");
{schema, line} = args;
{tag, attributes, body} = this.utilities:parse_element(line);
context = this:clone();
context.parent = line;
caller:traverse(body, context, schema);
attrs = {};
if (attributes)
for v, k in (attributes)
attrs = {@attrs, tostr(k:escape_html_attribute_content(), "=\"", v:escape_html_attribute_content(), "\"")};
endfor
endif
tag_escaped = tag:escape_html_element_content();
open = attrs ? tostr("<", tag_escaped, " ", attrs:join(" "), ">") | tostr("<", tag_escaped, ">");
close = tostr("</", tag_escaped, ">");
whitespace_preserve = `this.style[tag]["whitespace"] == "preserve" ! E_RANGE => 0';
display_block = `this.style[tag]["display"] == "block" ! E_RANGE => 0';
if (context.block_level || whitespace_preserve)
this.lines = {@this.lines, open, @context.lines, close};
else
this.lines = {@this.lines, tostr(open, @context.lines, close)};
endif
this.block_level = ((this.block_level || context.block_level) || whitespace_preserve) || display_block;
return;
"$restrict_to_caller(this.utilities, \"traverse\")";
"";
"{schema, line} = args";
"";
"{tag, attributes, body} = this.utilities:parse_element(line)";
"";
"context = this:clone()";
"";
"context.parent = line";
"";
"caller:traverse(body, context, schema)";
"";
"attrs = {}";
"";
"if (attributes)";
"  for k -> v in (attributes)";
"    attrs = {@attrs, tostr(k:escape_html_attribute_content(), '=\"', v:escape_html_attribute_content(), '\"')}";
"  end";
"end";
"";
"tag_escaped = tag:escape_html_element_content()";
"";
"open = attrs ? tostr(\"<\", tag_escaped, \" \", attrs:join(\" \"), \">\") | tostr(\"<\", tag_escaped, \">\")";
"close = tostr(\"</\", tag_escaped, \">\")";
"";
"whitespace_preserve = (this.style[tag][\"whitespace\"] == \"preserve\" !! E_RANGE => 0)";
"display_block = (this.style[tag][\"display\"] == \"block\" !! E_RANGE => 0)";
"";
"if (context.block_level || whitespace_preserve)";
"  this.lines = {@this.lines, open, @context.lines, close}";
"else";
"  this.lines = {@this.lines, tostr(open, @context.lines, close)}";
"end";
"";
"this.block_level = this.block_level || context.block_level || whitespace_preserve || display_block";
"";
"chunk_length:35";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:E855D90FC608A9945EAB8037A07DDA8541EB8511";
"-=-=-mxyzptlk-=-=-";
"[\"p\",\"See \",[\"strong\",\"$blink.utilities.context_proto:handle_element()\"],\".\"]";
"";
"chunk_length:1";
"chunk_type:documentation";
"content_type:application/json";
"sha1:33B7B92BE633F269960EFED6AE63168E3F461C0E";
"-=-=-mxyzptlk-=-=-";
.
#84:1
$restrict_to_caller(this.utilities, "traverse");
{schema, line} = args;
this.lines = {@this.lines, tostr(line):escape_html_element_content()};
return;
"$restrict_to_caller(this.utilities, \"traverse\")";
"";
"{schema, line} = args";
"";
"this.lines = {@this.lines, tostr(line):escape_html_element_content()}";
"";
"chunk_length:5";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:740D6677D2334B8FDE9B12C59AFB317E48116C96";
"-=-=-mxyzptlk-=-=-";
"[\"p\",\"See \",[\"strong\",\"$blink.utilities.context_proto:handle_text()\"],\".\"]";
"";
"chunk_length:1";
"chunk_type:documentation";
"content_type:application/json";
"sha1:AD126944ADB6CFAFD5A8F56E90E496D4D98ABDCC";
"-=-=-mxyzptlk-=-=-";
.
#85:0
$private();
{context, schema} = args;
if (context == 0)
context = create(this.context_proto, 1);
elseif (!this.context_proto:is_parent_of(context))
raise(E_INVARG, "Invalid context");
endif
if (schema == 0)
schema = this.default_schema;
elseif (!schema:is_map())
raise(E_INVARG, "Invalid schema");
endif
return {context, schema};
return;
"$private()";
"";
"{context, schema} = args";
"";
"if (context == 0)";
"  context = create(this.context_proto, 1)";
"elseif (!this.context_proto:is_parent_of(context))";
"  raise(E_INVARG, \"Invalid context\")";
"end";
"";
"if (schema == 0)";
"  schema = this.default_schema";
"elseif (!schema:is_map())";
"  raise(E_INVARG, \"Invalid schema\")";
"end";
"";
"return {context, schema}";
"";
"chunk_length:17";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:671B5E0970A388E43892123EB3F9FD66C5452C6A";
"-=-=-mxyzptlk-=-=-";
.
#85:1
{element} = args;
{tag, @body} = element;
_1729615197 = $core.utility.regexp;
tags = {};
while (r = tag:rmatch("%(#%|%.%).*$"))
tags = {_1729615197:matched(r), @tags};
tag = _1729615197:pre_match(r);
endwhile
xtra = [];
for t in (tags)
if (t[1] == "#")
xtra["id"] = t[2..$];
elseif (t[1] == ".")
xtra["class"] = t[2..$];
endif
endfor
if (body && body:first():is_map())
{attrs, @body} = body;
else
attrs = 0;
endif
if (xtra && attrs)
attrs = xtra:merge(attrs);
elseif (xtra)
attrs = xtra;
endif
return {tag, attrs, body};
return;
"{element} = args";
"";
"{tag, @body} = element";
"";
"from $core.utility.regexp use matched, pre_match";
"";
"tags = {}";
"";
"while ((r = tag:rmatch(\"%(#%|%.%).*$\")))";
"  tags = {matched(r), @tags}";
"  tag = pre_match(r)";
"end";
"";
"xtra = []";
"";
"for t in (tags)";
"  if (t[1] == \"#\")";
"    xtra[\"id\"] = t[2..$]";
"  elseif (t[1] == \".\")";
"    xtra[\"class\"] = t[2..$]";
"  end";
"end";
"";
"if (body && body:first():is_map())";
"  {attrs, @body} = body";
"else";
"  attrs = 0";
"end";
"";
"if (xtra && attrs)";
"  attrs = xtra:merge(attrs)";
"elseif (xtra)";
"  attrs = xtra";
"end";
"";
"return {tag, attrs, body}";
"";
"chunk_length:36";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:D05670C77B5FEB9C667DCA4B99CF079D4DBE1F1A";
"-=-=-mxyzptlk-=-=-";
.
#85:2
{tag, schema} = args;
try
rule = schema[tag];
except (E_RANGE)
return {};
endtry
valid_attributes = `rule["attributes"] ! E_TYPE, E_RANGE => {}';
valid_tags = `rule["tags"] ! E_TYPE, E_RANGE => {}';
return {tag, valid_attributes, valid_tags};
return;
"{tag, schema} = args";
"";
"try";
"  rule = schema[tag]";
"except (E_RANGE)";
"  return {}";
"end";
"";
"valid_attributes = (rule[\"attributes\"] !! E_TYPE, E_RANGE => {})";
"valid_tags = (rule[\"tags\"] !! E_TYPE, E_RANGE => {})";
"";
"return {tag, valid_attributes, valid_tags}";
"";
"chunk_length:12";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:0890AE7E68E00A13EB19535D3CDCCA6AA650128D";
"-=-=-mxyzptlk-=-=-";
.
#85:3
{body, ?context = 0, ?schema = 0} = args;
{context, schema} = this:_context_and_schema(context, schema);
for line in (body)
$suspend_if_necessary(0);
if (typeof(line) == LIST)
context:handle_element(schema, line);
else
context:handle_text(schema, line);
endif
endfor
return;
"{body, context = 0, schema = 0} = args";
"";
"{context, schema} = this:_context_and_schema(context, schema)";
"";
"/* `body' is the elements/text in the body of the current element, or";
" * the top-level lines.";
" */";
"";
"for line in (body)";
"  $suspend_if_necessary(0)";
"  if (typeof(line) == LIST)";
"    context:handle_element(schema, line)";
"  else";
"    context:handle_text(schema, line)";
"  end";
"end";
"";
"chunk_length:16";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:B7ED1FB99055749DAA338C61BB5F3CB4AA7695E4";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"none\"],\" \",[\"var\",\"$blink.utilities\"],\":\",[\"strong\",\"traverse\"],\"(\",[\"var\",\"LIST body\"],\" [, \",[\"var\",\"ANON context\"],\" [, \",[\"var\",\"MAP schema\"],\"]])\"]]";
"[\"p\",\"Recursively traverses \",[\"var\",\"body\"],\". Invokes handler verbs on \",[\"var\",\"context\"],\" passing in a line from \",[\"var\",\"body\"],\" and the \",[\"var\",\"schema\"],\".\"]";
"";
"chunk_length:2";
"chunk_type:documentation";
"content_type:application/json";
"sha1:C1D6E424234DA7ACCC9BBC8D07A6133080DB3FA6";
"-=-=-mxyzptlk-=-=-";
.
#85:4
{lines, ?schema = 0} = args;
_888857869 = this;
try
_888857869:traverse(lines, create(this.validator_context_proto, 1), schema);
except ex ("-*-invalid-*-")
return ex[2];
endtry
return {};
return;
"{lines, schema = 0} = args";
"";
"from this use traverse";
"";
"try";
"  traverse(lines, create(this.validator_context_proto, 1), schema)";
"except ex (\"-*-invalid-*-\")";
"  return ex[2]";
"end";
"";
"return {}";
"";
"chunk_length:11";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:26FB9D631AEED33F9237ABDA2A82E99ADCA9FFEC";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"none\"],\" \",[\"var\",\"$blink.utilities\"],\":\",[\"strong\",\"validate\"],\"(\",[\"var\",\"LIST body\"],\" [, \",[\"var\",\"MAP schema\"],\"])\"]]";
"[\"p\",\"Validates \",[\"var\",\"body\"],\" using the specified \",[\"var\",\"schema\"],\". Returns a list of errors on failure, or an empty list on success.\"]";
"";
"chunk_length:2";
"chunk_type:documentation";
"content_type:application/json";
"sha1:3EB00DB91912750F35090B75E7BAD3739F5BC015";
"-=-=-mxyzptlk-=-=-";
.
#85:5
{lines, ?schema = 0} = args;
_38697927 = this;
_38697927:traverse(lines, context = create(this.sanitizer_context_proto, 1), schema);
return context.lines;
return;
"{lines, schema = 0} = args";
"";
"from this use traverse";
"";
"traverse(lines, context = create(this.sanitizer_context_proto, 1), schema)";
"";
"return context.lines";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:A0E2F9753D2C7C80D9AADE70E4059160645903A3";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"LIST\"],\" \",[\"var\",\"$blink.utilities\"],\":\",[\"strong\",\"sanitize\"],\"(\",[\"var\",\"LIST body\"],\" [, \",[\"var\",\"MAP schema\"],\"])\"]]";
"[\"p\",\"Sanitizes \",[\"var\",\"body\"],\" using the specified \",[\"var\",\"schema\"],\". Returns the body with the invalid elements removed.\"]";
"";
"chunk_length:2";
"chunk_type:documentation";
"content_type:application/json";
"sha1:036FD5C3BD061B4AF9998215EEBE8BA285F4D3FC";
"-=-=-mxyzptlk-=-=-";
.
#85:6
{lines} = args;
return this:sanitize(lines, []);
return;
"{lines} = args";
"";
"return this:sanitize(lines, [])";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:C8515DC424BD89E20A4326233B8D8377ABD3AA59";
"-=-=-mxyzptlk-=-=-";
"[\"pre\",{\"class\":\"usage\"},[\"code\",{\"class\":\"language-moocode\"},[\"em\",\"LIST\"],\" \",[\"var\",\"$blink.utilities\"],\":\",[\"strong\",\"strip\"],\"(\",[\"var\",\"LIST body\"],\")\"]]";
"[\"p\",\"Strips the \",[\"var\",\"body\"],\", replacing every element with its body text.\"]";
"";
"chunk_length:2";
"chunk_type:documentation";
"content_type:application/json";
"sha1:D6896DAA6A0BB454A037EBA73DADA1FEEBAD86BF";
"-=-=-mxyzptlk-=-=-";
.
#89:0
{target} = args;
set_task_perms(caller_perms());
delim = ("match_verb" == verb) ? ":" | ".";
if (i = rindex(target, delim))
if ((o = this:match_object(target[1..i - 1])) != $failed_match)
return {o, target[i + 1..$]};
endif
endif
return {$failed_match, ""};
return;
"{target} = args;";
"";
"set_task_perms(caller_perms());";
"";
"delim = (\"match_verb\" == verb) ? \":\" | \".\";";
"";
"if ((i = rindex(target, delim)))";
"  if ((o = this:match_object(target[1..i - 1])) != $failed_match)";
"    return {o, target[i + 1..$]};";
"  endif";
"endif";
"";
"return {$failed_match, \"\"};";
"";
"chunk_length:13";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:0C65E4074D90C393874003C18119666DE152059E";
"-=-=-mxyzptlk-=-=-";
.
#89:1
{target} = args;
set_task_perms(cp = caller_perms());
ok = (cp == player) || cp.wizard;
if (ok && ("me" == target))
return player;
elseif (ok && ("here" == target))
return player.location;
elseif ((ok && (`v = player.alt_bindings[target] ! E_RANGE' != E_RANGE)) && `valid(v) ! E_TYPE')
return v;
elseif (m = match(target, "^%(#[0-9]+%|%$[a-z0-9_%.]+%)$"))
if (m[4][m[3][1][1]] == "$")
try
o = $system;
s = m[4][m[3][1][1] + 1..m[3][1][2]] + ".";
while (x = index(s, "."))
o = o.(s[1..x - 1]);
s = s[x + 1..$];
endwhile
except ex (E_RANGE, E_PROPNF)
return $failed_match;
endtry
elseif (m[4][m[3][1][1]] == "#")
o = toobj(m[4][m[3][1][1]..m[3][1][2]]);
endif
if (!valid(o))
return $failed_match;
endif
return o;
endif
return $failed_match;
return;
"{target} = args;";
"";
"/* The targets \"me\" and \"here\", and values from the player's bindings";
" * are only accessible if the caller is the player or is a wizard.";
" */";
"";
"set_task_perms((cp = caller_perms()));";
"";
"ok = (cp == player) || cp.wizard;";
"";
"if (ok && \"me\" == target)";
"  return player;";
"elseif (ok && \"here\" == target)";
"  return player.location;";
"elseif (ok && `v = player.alt_bindings[target] ! E_RANGE' != E_RANGE && `valid(v) ! E_TYPE')";
"  return v;";
"elseif (m = match(target, \"^%(#[0-9]+%|%$[a-z0-9_%.]+%)$\"))";
"  if (m[4][m[3][1][1]] == \"$\")";
"    try";
"      o = $system;";
"      s = m[4][m[3][1][1] + 1..m[3][1][2]] + \".\";";
"      while (x = index(s, \".\"))";
"        o = o.(s[1..x - 1]);";
"        s = s[x + 1..$];";
"      endwhile";
"    except ex (E_RANGE, E_PROPNF)";
"      return $failed_match;";
"    endtry";
"  elseif (m[4][m[3][1][1]] == \"#\")";
"    o = toobj(m[4][m[3][1][1]..m[3][1][2]]);";
"  endif";
"  if (!valid(o))";
"    return $failed_match;";
"  endif";
"  return o;";
"endif";
"";
"return $failed_match;";
"";
"chunk_length:38";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:299D11796815D9977AB762B7C469ABB17B4058BA";
"-=-=-mxyzptlk-=-=-";
.
#89:2
{o, v} = args;
set_task_perms(caller_perms());
info_function = (verb == "_player_controls_verb") ? "verb_info" | "property_info";
return player.wizard || (player == `call_function(info_function, o, v)[1] ! ANY');
.
#89:3
{o} = args;
set_task_perms(caller_perms());
return player.wizard || (player == `o.owner ! ANY');
.
#89:4
{STR} = args;
if (r = match(STR, "%( +[+-][a-z]+%)+ *$"))
cmd = STR[^..r[1] - 1];
tail = STR[r[1] + 1..$]:split();
return {cmd, @tail};
else
return {STR};
endif
return;
"{str} = args;";
"";
"if ((r = match(str, \"%( +[+-][a-z]+%)+ *$\")))";
"  cmd = str[^..r[1] - 1];";
"  tail = str[r[1] + 1..$]:split();";
"  return {cmd, @tail};";
"else";
"  return {str};";
"endif";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:E9E120C913299D9B89F717C31631D48503BFF77D";
"-=-=-mxyzptlk-=-=-";
.
#90:0
callers() && raise(E_PERM, "Server task");
set_task_perms(player);
"very simple, really primitive matching";
if (((prepstr == "with") && (iobjstr == "$composed")) && `valid($composed) ! ANY')
if ((verb in {"@install", "@uninstall", "@list"}) && `respond_to($composed, verb) ! ANY')
return $composed:(verb)(@args);
endif
endif
if (((prepstr == "with") && (iobjstr == "$unit.test")) && `valid($unit.test) ! ANY')
if ((verb in {"@test"}) && `respond_to($unit.test, verb) ! ANY')
return $unit.test:(verb)(@args);
endif
endif
notify(player, "I couldn't understand that.");
.
#90:1
$permit("wizard", "owner");
messages = args;
if (!is_member(this, connected_players()))
return;
endif
format = `this.alt_display_options["format"] ! E_RANGE' || "auto";
if (format == "html")
messages = $blink.render_as_html:render(messages);
binary = 0;
elseif (format == "ansi")
messages = $blink.render_as_ansi:render(messages);
binary = 1;
else
messages = $blink.render_as_text:render(messages);
binary = 0;
endif
try
saved = connection_option(this, "binary");
set_connection_option(this, "binary", binary);
for message in (messages)
$suspend_if_necessary(0);
if (binary)
notify(this, message);
notify(this, "~1B[0m~0D~0A");
else
notify(this, message);
endif
endfor
finally
set_connection_option(this, "binary", saved);
endtry
return;
"$permit(\"wizard\", \"owner\")";
"";
"messages = args";
"";
"if (!is_member(this, connected_players()))";
"  return";
"end";
"";
"format = (this.alt_display_options[\"format\"] !! E_RANGE) || \"auto\"";
"";
"if (format == \"html\")";
"  messages = $blink.render_as_html:render(messages)";
"  binary = 0";
"elseif (format == \"ansi\")";
"  messages = $blink.render_as_ansi:render(messages)";
"  binary = 1";
"else";
"  messages = $blink.render_as_text:render(messages)";
"  binary = 0";
"end";
"";
"try";
"  saved = connection_option(this, \"binary\")";
"  set_connection_option(this, \"binary\", binary)";
"  for message in (messages)";
"    $suspend_if_necessary(0)";
"    if (binary)";
"      notify(this, message) notify(this, \"~1B[0m~0D~0A\")";
"    else";
"      notify(this, message)";
"    end";
"  end";
"finally";
"  set_connection_option(this, \"binary\", saved)";
"end";
"";
"chunk_length:35";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:B925DDDFD1CF6D3FF41487A53ABC3CFC3BF0D147";
"-=-=-mxyzptlk-=-=-";
.
#90:2
boot_player(player);
return;
"boot_player(player)";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:06E4C6E2159E30B201FE00FCBC0B3D33F22FE70F";
"-=-=-mxyzptlk-=-=-";
.
#91:0
$private();
set_task_perms(caller_perms());
{prog} = args;
t = $plastic.tokenizer_proto:create(prog);
p = $plastic.parser_proto:create(t);
try
return {1, p:statements(), t, p};
except ex ("Syntax error")
return {0, t.row, t.column, {ex[2]}, t, p};
endtry
return;
"$private();";
"";
"set_task_perms(caller_perms());";
"";
"{prog} = args;";
"";
"t = $plastic.tokenizer_proto:create(prog);";
"p = $plastic.parser_proto:create(t);";
"";
"try";
"  return {1, p:statements(), t, p};";
"except ex (\"Syntax error\")";
"  return {0, t.row, t.column, {ex[2]}, t, p};";
"endtry";
"";
"chunk_length:14";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:760D716C36B0FCF01FD9426C56CA255CF627F6C3";
"-=-=-mxyzptlk-=-=-";
.
#91:1
if (player != this)
notify(player, "I couldn't understand that.");
return;
elseif (!player.programmer)
notify(player, "You need to be a programmer to evaluate code.");
return;
endif
set_task_perms(player);
try
prog = {argstr};
set_connection_option(player, "hold-input", 1);
while (((({retval, @rest} = this:_parse(prog)) && (!retval)) && ({row, column, errors, t, p} = rest)) && (row > length(prog)))
if (argstr)
player:tell("Enter lines of code.  Enter a single period (\".\") to abort editing.");
argstr = 0;
endif
if ((line = read(player)) == ".")
player:tell("(aborted)");
return;
endif
prog = {@prog, line};
endwhile
finally
set_connection_option(player, "hold-input", 0);
endtry
if (!retval)
for error in (errors)
player:tell("Line ", row, ":  ", error);
endfor
return;
endif
{statements, t, p} = rest;
if ((length(statements) == 1) && (statements[1].type != "statement"))
ret = create($plastic.control_flow_statement_proto, 1);
ret.id = "return";
ret.type = "statement";
ret.first = statements[1];
statements = {ret};
endif
if (statements && (!((statements[$].type == "statement") && (statements[$].id == "return"))))
ret = create($plastic.control_flow_statement_proto, 1);
ret.id = "return";
ret.type = "statement";
ret.first = 0;
statements = {@statements, ret};
endif
variables = [];
for variable in ($plastic.utilities:match(statements, ["type" -> "variable"]))
id = variable.id;
if ((((id[1] != "_") && (id[1] != "$")) && (`variables[id] ! E_RANGE' == E_RANGE)) && (!(variable.id in $plastic.compiler.builtin_names)))
variables[id] = variable;
elseif ((id == "_") && (`variables[id] ! E_RANGE' == E_RANGE))
variables[id] = variable;
endif
endfor
variables = variables:values();
ret = create($plastic.bracket_operator_proto, 1);
ret.id = "[";
ret.type = "unary";
ret.value = {};
for variable in (variables)
key = create($plastic.literal_proto, 1);
key.type = "string";
key.value = variable.id;
value = create($plastic.error_catching_operator_proto, 1);
value.id = "!!";
value.type = "binary";
value.first = variable;
value.second = {create($plastic.name_proto, 1)};
value.second[1].id = "ANY";
value.second[1].type = "keyword";
value.second[1].value = "ANY";
ret.value = {@ret.value, {key, value}};
endfor
for statement in ($plastic.utilities:match(statements, ["type" -> "statement", "id" -> "return"]))
if (statement.first == 0)
statement.first = create($plastic.literal_proto, 1);
statement.first.type = "number";
statement.first.value = 0;
endif
first = create($plastic.brace_operator_proto, 1);
first.id = "{";
first.type = "unary";
first.value = {statement.first, ret};
statement.first = first;
endfor
prefix = {};
if (variables)
prefix = create($plastic.assignment_operator_proto, 1);
prefix.id = "=";
prefix.type = "binary";
prefix.value = "=";
prefix.first = create($plastic.name_proto, 1);
prefix.first.id = "__";
prefix.first.type = "variable";
prefix.first.value = "__";
prefix.second = create($plastic.property_selector_operator_proto, 1);
prefix.second.id = ".";
prefix.second.type = "binary";
prefix.second.first = create($plastic.name_proto, 1);
prefix.second.first.id = "player";
prefix.second.first.type = "variable";
prefix.second.first.value = "player";
prefix.second.second = create($plastic.name_proto, 1);
prefix.second.second.id = "alt_bindings";
prefix.second.second.type = "identifier";
prefix.second.second.value = "alt_bindings";
prefix = {prefix};
endif
for variable in (variables)
k = variable.id;
if (`this.alt_bindings[k] ! E_RANGE' == E_RANGE)
continue;
endif
assignment = create($plastic.assignment_operator_proto, 1);
assignment.id = "=";
assignment.type = "binary";
assignment.value = "=";
assignment.first = create($plastic.name_proto, 1);
assignment.first.id = k;
assignment.first.type = "variable";
assignment.first.value = k;
assignment.second = create($plastic.bracket_operator_proto, 1);
assignment.second.id = "[";
assignment.second.type = "binary";
assignment.second.first = create($plastic.name_proto, 1);
assignment.second.first.id = "__";
assignment.second.first.type = "variable";
assignment.second.first.value = "__";
assignment.second.second = create($plastic.literal_proto, 1);
assignment.second.second.id = k;
assignment.second.second.type = "string";
assignment.second.second.value = k;
prefix = {@prefix, assignment};
endfor
statements = {@prefix, @statements};
compiler = create($plastic.compiler, 1);
source = {};
for statement in (statements)
if (statement.type != "statement")
source = {@source, compiler:p(statement), ";"};
else
source = {@source, @compiler:p(statement)};
endif
endfor
if (!source)
source = {""};
endif
{code, retval} = eval(@source);
if (code)
variables = [];
if (typeof(retval) == LIST)
{retval, ?variables = []} = retval;
endif
variables["_"] = retval;
player.alt_bindings = player.alt_bindings:merge(variables);
t = typeof(retval);
if (((t == OBJ) || (t == ANON)) && valid(retval))
player:tell(toliteral(retval), " ", toliteral(retval.name));
elseif (t == ERR)
player:tell(toliteral(retval), " ", toliteral(tostr(retval)));
else
player:tell(toliteral(retval));
endif
else
for line in (retval)
player:tell(line);
endfor
endif
return;
"if (player != this)";
"  notify(player, \"I couldn't understand that.\");";
"  return;";
"elseif (!player.programmer)";
"  notify(player, \"You need to be a programmer to evaluate code.\");";
"  return;";
"endif";
"";
"set_task_perms(player);";
"";
"/* The strategy is to add lines until we either have a chunk of code";
" * that parses without error (in which case we compile it and evaluate";
" * the result) or is uncorrectable (in which case we output the syntax";
" * errors).  \"Uncorrectable\" means that adding more lines will not";
" * result in a valid chunk of code.";
"*/";
"";
"try";
"  prog = {argstr};";
"";
"  set_connection_option(player, \"hold-input\", 1);";
"";
"  while (({retval, @rest} = this:_parse(prog)) && !retval &&";
"         ({row, column, errors, t, p} = rest) &&";
"         row > length(prog))";
"    if (argstr)";
"      player:tell(\"Enter lines of code.  Enter a single period (\\\".\\\") to abort editing.\");";
"      argstr = 0;";
"    endif";
"    if ((line = read(player)) == \".\")";
"      player:tell(\"(aborted)\");";
"      return;";
"    endif";
"    prog = {@prog, line};";
"  endwhile";
"finally";
"  set_connection_option(player, \"hold-input\", 0);";
"endtry";
"";
"if (!retval)";
"  for error in (errors)";
"    player:tell(\"Line \", row, \":  \", error);";
"  endfor";
"  return;";
"endif";
"";
"{statements, t, p} = rest;";
"";
"/* if it's not a statement, make it a return statement */";
"if (length(statements) == 1 && statements[1].type != \"statement\")";
"  ret = create($plastic.control_flow_statement_proto, 1);";
"  ret.id = \"return\";";
"  ret.type = \"statement\";";
"  ret.first = statements[1];";
"  statements = {ret};";
"endif";
"";
"/* if it doesn't end in a return statement, tack on a return statement */";
"if (statements && !(statements[$].type == \"statement\" && statements[$].id == \"return\"))";
"  ret = create($plastic.control_flow_statement_proto, 1);";
"  ret.id = \"return\";";
"  ret.type = \"statement\";";
"  ret.first = 0;";
"  statements = {@statements, ret};";
"endif";
"";
"/* select the variables */";
"variables = [];";
"for variable in ($plastic.utilities:match(statements, [\"type\" -> \"variable\"]))";
"  id = variable.id;";
"  if (id[1] != \"_\" && id[1] != \"$\" && `variables[id] ! E_RANGE' == E_RANGE && !(variable.id in $plastic.compiler.builtin_names))";
"    variables[id] = variable;";
"  elseif (id == \"_\" && `variables[id] ! E_RANGE' == E_RANGE) /* explicitly include the last result, however */";
"    variables[id] = variable;";
"  endif";
"endfor";
"variables = variables:values();";
"";
"/* build code to return the variables */";
"ret = create($plastic.bracket_operator_proto, 1);";
"ret.id = \"[\";";
"ret.type = \"unary\";";
"ret.value = {};";
"for variable in (variables)";
"  key = create($plastic.literal_proto, 1);";
"  key.type = \"string\";";
"  key.value = variable.id;";
"  value = create($plastic.error_catching_operator_proto, 1);";
"  value.id = \"!!\";";
"  value.type = \"binary\";";
"  value.first = variable;";
"  value.second = {create($plastic.name_proto, 1)};";
"  value.second[1].id = \"ANY\";";
"  value.second[1].type = \"keyword\";";
"  value.second[1].value = \"ANY\";";
"  ret.value = {@ret.value, {key, value}};";
"endfor";
"";
"/* look for and fix up return statements */";
"for statement in ($plastic.utilities:match(statements, [\"type\" -> \"statement\", \"id\" -> \"return\"]))";
"  if (statement.first == 0)";
"    statement.first = create($plastic.literal_proto, 1);";
"    statement.first.type = \"number\";";
"    statement.first.value = 0;";
"  endif";
"  first = create($plastic.brace_operator_proto, 1);";
"  first.id = \"{\";";
"  first.type = \"unary\";";
"  first.value = {statement.first, ret};";
"  statement.first = first;";
"endfor";
"";
"/* prefix with bindings */";
"prefix = {};";
"";
"if (variables)";
"  prefix = create($plastic.assignment_operator_proto, 1);";
"  prefix.id = \"=\";";
"  prefix.type = \"binary\";";
"  prefix.value = \"=\";";
"  prefix.first = create($plastic.name_proto, 1);";
"  prefix.first.id = \"__\";";
"  prefix.first.type = \"variable\";";
"  prefix.first.value = \"__\";";
"  prefix.second = create($plastic.property_selector_operator_proto, 1);";
"  prefix.second.id = \".\";";
"  prefix.second.type = \"binary\";";
"  prefix.second.first = create($plastic.name_proto, 1);";
"  prefix.second.first.id = \"player\";";
"  prefix.second.first.type = \"variable\";";
"  prefix.second.first.value = \"player\";";
"  prefix.second.second = create($plastic.name_proto, 1);";
"  prefix.second.second.id = \"alt_bindings\";";
"  prefix.second.second.type = \"identifier\";";
"  prefix.second.second.value = \"alt_bindings\";";
"  prefix = {prefix};";
"endif";
"";
"for variable in (variables)";
"  k = variable.id;";
"  if (`this.alt_bindings[k] ! E_RANGE' == E_RANGE)";
"    continue;";
"  endif";
"  assignment = create($plastic.assignment_operator_proto, 1);";
"  assignment.id = \"=\";";
"  assignment.type = \"binary\";";
"  assignment.value = \"=\";";
"  assignment.first = create($plastic.name_proto, 1);";
"  assignment.first.id = k;";
"  assignment.first.type = \"variable\";";
"  assignment.first.value = k;";
"  assignment.second = create($plastic.bracket_operator_proto, 1);";
"  assignment.second.id = \"[\";";
"  assignment.second.type = \"binary\";";
"  assignment.second.first = create($plastic.name_proto, 1);";
"  assignment.second.first.id = \"__\";";
"  assignment.second.first.type = \"variable\";";
"  assignment.second.first.value = \"__\";";
"  assignment.second.second = create($plastic.literal_proto, 1);";
"  assignment.second.second.id = k;";
"  assignment.second.second.type = \"string\";";
"  assignment.second.second.value = k;";
"  prefix = {@prefix, assignment};";
"endfor";
"";
"statements = {@prefix, @statements};";
"";
"/* generate the code to eval */";
"compiler = create($plastic.compiler, 1);";
"";
"source = {};";
"";
"for statement in (statements)";
"  if (statement.type != \"statement\")";
"    source = {@source, compiler:p(statement), \";\"};";
"  else";
"    source = {@source, @compiler:p(statement)};";
"  endif";
"endfor";
"";
"if (!source)";
"  source = {\"\"};";
"endif";
"";
"/* and evaluate...! */";
"{code, retval} = eval(@source);";
"";
"if (code)";
"  variables = [];";
"  if (typeof(retval) == LIST)";
"    {retval, ?variables = []} = retval;";
"  endif";
"";
"  variables[\"_\"] = retval;";
"";
"  player.alt_bindings = player.alt_bindings:merge(variables);";
"";
"  t = typeof(retval);";
"  if ((t == OBJ || t == ANON) && valid(retval))";
"    player:tell(toliteral(retval), \" \", toliteral(retval.name));";
"  elseif (t == ERR)";
"    player:tell(toliteral(retval), \" \", toliteral(tostr(retval)));";
"  else";
"    player:tell(toliteral(retval));";
"  endif";
"else";
"  for line in (retval)";
"    player:tell(line);";
"  endfor";
"endif";
"";
"chunk_length:210";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:DAEBE79F2869F3359172850885FC6CAF42A12F1E";
"-=-=-mxyzptlk-=-=-";
.
#91:2
if (player != this)
player:notify("I couldn't understand that.");
return;
elseif (!player.programmer)
player:notify("You need to be a programmer to do that.");
return;
endif
utilities = $lookup("player_utilities");
{o, v} = utilities:match_verb(argstr);
if (v && `vi = verb_info(o, v) ! E_VERBNF')
if (utilities:_player_controls_verb(o, v) || index(vi[2], "r"))
d = $verb_detail(o, v);
if (`d["content_type"] ! E_RANGE')
vc = verb_code(o, v);
else
vc = verb_code(o, v, 0, 1);
endif
if (verb == "@edit")
if (`d["content_type"] ! E_RANGE')
player:notify("Editing ", argstr);
player:notify("#$# edit name: ", argstr, " upload: @program ", argstr, " as ", d["content_type"]);
else
player:notify("Editing ", argstr);
player:notify("#$# edit name: ", argstr, " upload: @program ", argstr);
endif
endif
for i in (vc)
player:notify(i);
endfor
if (verb == "@edit")
player:notify(".");
endif
return;
else
player:notify("You don't have permission to do that.");
return;
endif
elseif (v)
player:notify("That verb doesn't exist.");
return;
endif
{o, p} = utilities:match_property(argstr);
if (p && `pi = property_info(o, p) ! E_PROPNF')
if (utilities:_player_controls_property(o, p) || index(pi[2], "r"))
v = o.(p);
if ((type = typeof(v)) == LIST)
for i in (v)
if (typeof(i) != STR)
type = -1;
break;
endif
endfor
endif
if (verb == "@edit")
if (type == LIST)
player:notify("Editing ", argstr);
player:notify("#$# edit name: ", argstr, " upload: @program ", argstr, " as list");
else
player:notify("Editing ", argstr);
player:notify("#$# edit name: ", argstr, " upload: @program ", argstr);
endif
endif
if (type != LIST)
v = {toliteral(v)};
endif
for i in (v)
player:notify(i);
endfor
if (verb == "@edit")
player:notify(".");
endif
return;
else
player:notify("You don't have permission to do that.");
return;
endif
elseif (p)
player:notify("That property doesn't exist.");
return;
endif
player:notify("I couldn't understand that.");
return;
"if (player != this)";
"  player:notify(\"I couldn't understand that.\");";
"  return;";
"elseif (!player.programmer)";
"  player:notify(\"You need to be a programmer to do that.\");";
"  return;";
"endif";
"";
"utilities = $lookup(\"player_utilities\");";
"";
"{o, v} = utilities:match_verb(argstr);";
"if (v && `vi = verb_info(o, v) ! E_VERBNF')";
"  if (utilities:_player_controls_verb(o, v) || index(vi[2], \"r\"))";
"    d = $verb_detail(o, v);";
"    if (`d[\"content_type\"] ! E_RANGE')";
"      vc = verb_code(o, v);";
"    else";
"      vc = verb_code(o, v, 0, 1);";
"    endif";
"    if (verb == \"@edit\")";
"      if (`d[\"content_type\"] ! E_RANGE')";
"        player:notify(\"Editing \", argstr);";
"        player:notify(\"#$# edit name: \", argstr, \" upload: @program \", argstr, \" as \", d[\"content_type\"]);";
"      else";
"        player:notify(\"Editing \", argstr);";
"        player:notify(\"#$# edit name: \", argstr, \" upload: @program \", argstr);";
"      endif";
"    endif";
"    for i in (vc)";
"      player:notify(i);";
"    endfor";
"    if (verb == \"@edit\")";
"      player:notify(\".\");";
"    endif";
"    return;";
"  else";
"    player:notify(\"You don't have permission to do that.\");";
"    return;";
"  endif";
"elseif (v)";
"  player:notify(\"That verb doesn't exist.\");";
"  return;";
"endif";
"";
"{o, p} = utilities:match_property(argstr);";
"if (p && `pi = property_info(o, p) ! E_PROPNF')";
"  if (utilities:_player_controls_property(o, p) || index(pi[2], \"r\"))";
"    v = o.(p);";
"    /* is it a list of strings? */";
"    if ((type = typeof(v)) == LIST)";
"      for i in (v)";
"        if (typeof(i) != STR)";
"          type = -1;";
"          break;";
"        endif";
"      endfor";
"    endif";
"    if (verb == \"@edit\")";
"      if (type == LIST)";
"        player:notify(\"Editing \", argstr);";
"        player:notify(\"#$# edit name: \", argstr, \" upload: @program \", argstr, \" as list\");";
"      else";
"        player:notify(\"Editing \", argstr);";
"        player:notify(\"#$# edit name: \", argstr, \" upload: @program \", argstr);";
"      endif";
"    endif";
"    if (type != LIST)";
"      v = {toliteral(v)};";
"    endif";
"    for i in (v)";
"      player:notify(i);";
"    endfor";
"    if (verb == \"@edit\")";
"      player:notify(\".\");";
"    endif";
"    return;";
"  else";
"    player:notify(\"You don't have permission to do that.\");";
"    return;";
"  endif";
"elseif (p)";
"  player:notify(\"That property doesn't exist.\");";
"  return;";
"endif";
"";
"player:notify(\"I couldn't understand that.\");";
"";
"chunk_length:86";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:9E3190397CF8BA52EAC3D1B9F599AA8A2ED4A87F";
"-=-=-mxyzptlk-=-=-";
.
#91:3
if (player != this)
player:notify("I couldn't understand that.");
return;
elseif (!player.programmer)
player:notify("You need to be a programmer to program.");
return;
endif
utilities = $lookup("player_utilities");
ll = {};
while ((l = read(player)) != ".")
ll = {@ll, l};
endwhile
{o, v} = utilities:match_verb(dobjstr);
if (v && `vi = verb_info(o, v) ! E_VERBNF')
if (utilities:_player_controls_verb(o, v) || index(vi[2], "w"))
if ((prepstr == "as") && iobjstr)
content_type = $_generate_content_type($_parse_content_type(iobjstr));
elseif (prepstr)
player:notify("I couldn't understand that.");
return;
endif
vd = $verb_detail(o, v);
if (`vd["sha1"] ! E_RANGE' == value_hash(ll, "sha1"))
player:notify("No change.  Nothing to do for ", dobjstr);
return;
endif
set_task_perms(player);
if (`content_type ! E_VARNF')
r = set_verb_code(o, v, ll, content_type);
else
r = set_verb_code(o, v, ll);
endif
if (!r)
player:notify("Programming succeeded for ", dobjstr);
else
player:notify("Programming failed for ", dobjstr);
for rr in (r)
player:notify(rr);
endfor
endif
return;
else
player:notify("You don't have permission to do that.");
return;
endif
elseif (v)
player:notify("That verb doesn't exist.");
return;
endif
{o, p} = utilities:match_property(dobjstr);
if (p && `pi = property_info(o, p) ! E_PROPNF')
if (utilities:_player_controls_property(o, p) || index(pi[2], "w"))
if ((prepstr == "as") && (iobjstr == "list"))
content_type = LIST;
elseif (prepstr)
player:notify("I couldn't understand that.");
return;
endif
set_task_perms(player);
if (`content_type ! E_VARNF')
o.(p) = ll;
else
r = eval(((dobjstr + " = ") + ll:join()) + ";");
endif
if (`r[1] ! E_VARNF => 1')
player:notify("Programming succeeded for ", dobjstr);
else
player:notify("Programming failed for ", dobjstr);
for rr in (r[2])
player:notify(rr);
endfor
endif
return;
else
player:notify("You don't have permission to do that.");
return;
endif
elseif (p)
player:notify("That property doesn't exist.");
return;
endif
player:notify("I couldn't understand that.");
return;
"if (player != this)";
"  player:notify(\"I couldn't understand that.\");";
"  return;";
"elseif (!player.programmer)";
"  player:notify(\"You need to be a programmer to program.\");";
"  return;";
"endif";
"";
"utilities = $lookup(\"player_utilities\");";
"";
"/* snarf lines early to avoid the flood of error messages */";
"ll = {};";
"while ((l = read(player)) != \".\")";
"  ll = {@ll, l};";
"endwhile";
"";
"{o, v} = utilities:match_verb(dobjstr);";
"if (v && `vi = verb_info(o, v) ! E_VERBNF')";
"  if (utilities:_player_controls_verb(o, v) || index(vi[2], \"w\"))";
"    if (prepstr == \"as\" && iobjstr)";
"      content_type = $_generate_content_type($_parse_content_type(iobjstr));";
"    elseif (prepstr)";
"      player:notify(\"I couldn't understand that.\");";
"      return;";
"    endif";
"";
"    vd = $verb_detail(o, v);";
"    if (`vd[\"sha1\"] ! E_RANGE' == value_hash(ll, \"sha1\"))";
"      player:notify(\"No change.  Nothing to do for \", dobjstr);";
"      return;";
"    endif";
"";
"    set_task_perms(player);";
"";
"    if (`content_type ! E_VARNF')";
"      r = set_verb_code(o, v, ll, content_type);";
"    else";
"      r = set_verb_code(o, v, ll);";
"    endif";
"";
"    if (!r)";
"      player:notify(\"Programming succeeded for \", dobjstr);";
"    else";
"      player:notify(\"Programming failed for \", dobjstr);";
"      for rr in (r)";
"        player:notify(rr);";
"      endfor";
"    endif";
"";
"    return;";
"";
"  else";
"    player:notify(\"You don't have permission to do that.\");";
"    return;";
"  endif";
"elseif (v)";
"  player:notify(\"That verb doesn't exist.\");";
"  return;";
"endif";
"";
"{o, p} = utilities:match_property(dobjstr);";
"if (p && `pi = property_info(o, p) ! E_PROPNF')";
"  if (utilities:_player_controls_property(o, p) || index(pi[2], \"w\"))";
"    if (prepstr == \"as\" && iobjstr == \"list\")";
"      content_type = LIST;";
"    elseif (prepstr)";
"      player:notify(\"I couldn't understand that.\");";
"      return;";
"    endif";
"";
"    set_task_perms(player);";
"";
"    if (`content_type ! E_VARNF')";
"      o.(p) = ll;";
"    else";
"      r = eval(dobjstr + \" = \" + ll:join() + \";\");";
"    endif";
"";
"    if (`r[1] ! E_VARNF => 1')";
"      player:notify(\"Programming succeeded for \", dobjstr);";
"    else";
"      player:notify(\"Programming failed for \", dobjstr);";
"      for rr in (r[2])";
"        player:notify(rr);";
"      endfor";
"    endif";
"";
"  return;";
"";
"  else";
"    player:notify(\"You don't have permission to do that.\");";
"    return;";
"  endif";
"elseif (p)";
"  player:notify(\"That property doesn't exist.\");";
"  return;";
"endif";
"";
"player:notify(\"I couldn't understand that.\");";
"";
"chunk_length:99";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:1C4EEFFC1C20EF733CE277B783006D6199A4BD5E";
"-=-=-mxyzptlk-=-=-";
.
#91:4
if (player != this)
player:notify("I couldn't understand that.");
return;
endif
all = 0;
tail = {};
utilities = $lookup("player_utilities");
if (!valid(dobj))
{dobjstr, @tail} = utilities:extract_tail(dobjstr);
dobj = utilities:match_object(dobjstr);
all = ("+all" in tail) && (!("-all" in tail));
endif
if (!valid(dobj))
player:notify("I couldn't understand that.");
return;
endif
if (!tail)
all = !(verbs(dobj) || properties(dobj));
endif
p = n = "";
dobj.r ? p = p + "r" | (n = n + "r");
dobj.w ? p = p + "w" | (n = n + "w");
dobj.f ? p = p + "f" | (n = n + "f");
dobj.a ? p = p + "a" | (n = n + "a");
t = {};
`is_player(dobj) ! E_TYPE' && (t = {@t, "player"});
dobj.programmer && (t = {@t, "programmer"});
dobj.wizard && (t = {@t, "wizard"});
t = t:join();
player:notify({"h2", dobj.name, " (", dobj, ")"});
player:notify({"strong", "Owner:"}, " ", dobj.owner);
player:notify({"strong", "Parents:"}, " ", parents(dobj):join(), "  ", {"strong", "Children:"}, " ", children(dobj):join());
player:notify({"strong", "Location:"}, " ", dobj.location, "  ", {"strong", "Contents:"}, " ", dobj.contents:join());
player:notify({"strong", "Flags:"}, p ? "  +" | "", p, n ? " -" | "", n, " ", t);
if (utilities:_player_controls_object(dobj) || dobj.r)
ancestors = all ? {dobj, @ancestors(dobj)} | {dobj};
for o in (ancestors)
if (utilities:_player_controls_object(o) || o.r)
for i, j in (verbs(o))
if (utilities:_player_controls_verb(o, j))
if ((dobj == o) && (1 == j))
player:notify();
player:notify({"h2", "Verbs defined on \"", o.name, "\" (", o, ")"});
elseif (1 == j)
player:notify();
player:notify({"h2", "Verbs inherited from \"", o.name, "\" (", o, ")"});
else
player:notify();
endif
l = {{"strong", i}, " "};
vd = $verb_detail(o, j);
`vd["state"] == "dirty" ! E_RANGE' && (l = {@l, {"span.warning", "[dirty]"}, " "});
`vd["content_type"] ! E_RANGE' && (l = {@l, vd["content_type"], " "});
player:notify("  ", @l);
player:notify("    ", toliteral(verb_info(o, j)));
player:notify("    ", toliteral(verb_args(o, j)));
else
if (1 == j)
player:notify();
player:notify({"h2", "Verbs inherited from \"", o.name, "\" (", o, ")"});
else
player:notify();
endif
player:notify(i);
player:notify("  <<permission denied>>");
endif
endfor
else
player:notify();
player:notify({"h2", "Verbs from \"", o.name, "\" (", o, ")"});
player:notify("  <<permission denied>>");
endif
endfor
for o in (ancestors)
if (utilities:_player_controls_object(o) || o.r)
for i, j in (properties(o))
if (utilities:_player_controls_property(dobj, i))
if ((dobj == o) && (1 == j))
player:notify();
player:notify({"h2", "Properties defined on \"", o.name, "\" (", o, ")"});
elseif (1 == j)
player:notify();
player:notify({"h2", "Properties inherited from \"", o.name, "\" (", o, ")"});
else
player:notify();
endif
l = {{"strong", i}, " "};
is_clear_property(dobj, i) && (l = {@l, {"span.information", "[clear]"}, " "});
l = {@l, toliteral(dobj.(i)):truncate()};
player:notify("  ", @l);
player:notify("    ", toliteral(property_info(dobj, i)));
else
if (1 == j)
player:notify();
player:notify({"h2", "Properties inherited from \"", o.name, "\" (", o, ")"});
else
player:notify();
endif
player:notify(i);
player:notify("  <<permission denied>>");
endif
endfor
else
player:notify();
player:notify({"h2", "Properties from \"", o.name, "\" (", o, ")"});
player:notify("  <<permission denied>>");
endif
endfor
endif
player:notify();
player:notify("(done)");
return;
"if (player != this)";
"  player:notify(\"I couldn't understand that.\");";
"  return;";
"endif";
"";
"all = 0;";
"tail = {};";
"";
"utilities = $lookup(\"player_utilities\");";
"";
"if (!valid(dobj))";
"  {dobjstr, @tail} = utilities:extract_tail(dobjstr);";
"  dobj = utilities:match_object(dobjstr);";
"  all = (\"+all\" in tail) && !(\"-all\" in tail);";
"endif";
"if (!valid(dobj))";
"  player:notify(\"I couldn't understand that.\");";
"  return;";
"endif";
"";
"/* Default to all detail if the object defines";
" * no verbs or properties and there is no tail.";
" */";
"if (!tail)";
"  all = !(verbs(dobj) || properties(dobj));";
"endif";
"";
"/* everybody can see general information about the object */";
"";
"p = n = \"\";";
"dobj.r ? (p = p + \"r\") | (n = n + \"r\");";
"dobj.w ? (p = p + \"w\") | (n = n + \"w\");";
"dobj.f ? (p = p + \"f\") | (n = n + \"f\");";
"dobj.a ? (p = p + \"a\") | (n = n + \"a\");";
"";
"t = {};";
"`is_player(dobj) ! E_TYPE' && (t = {@t, \"player\"});";
"dobj.programmer && (t = {@t, \"programmer\"});";
"dobj.wizard && (t = {@t, \"wizard\"});";
"t = t:join();";
"";
"player:notify({\"h2\", dobj.name, \" (\", dobj, \")\"});";
"player:notify({\"strong\", \"Owner:\"}, \" \", dobj.owner);";
"player:notify({\"strong\", \"Parents:\"}, \" \", parents(dobj):join(), \"  \", {\"strong\", \"Children:\"}, \" \", children(dobj):join());";
"player:notify({\"strong\", \"Location:\"}, \" \", dobj.location, \"  \", {\"strong\", \"Contents:\"}, \" \", dobj.contents:join());";
"player:notify({\"strong\", \"Flags:\"}, (p ? \"  +\" | \"\"), p, (n ? \" -\" | \"\"), n, \" \", t);";
"";
"";
"/* Only display the details if the object is specifically in the";
" * player's control or generally readable.  If the object or any";
" * of its ancestors are in control/readable, include a section for";
" * the object/ancestor.  If a verb/property is in the player's";
" * control or is readable, include details about the verb/";
" * property.";
" */";
"";
"if (utilities:_player_controls_object(dobj) || dobj.r)";
"  ancestors = all ? {dobj, @ancestors(dobj)} | {dobj};";
"";
"  for o in (ancestors)";
"    if (utilities:_player_controls_object(o) || o.r)";
"      for i, j in (verbs(o))";
"        if (utilities:_player_controls_verb(o, j))";
"          if (dobj == o && 1 == j)";
"            player:notify();";
"            player:notify({\"h2\", \"Verbs defined on \\\"\", o.name, \"\\\" (\", o, \")\"});";
"          elseif (1 == j)";
"            player:notify();";
"            player:notify({\"h2\", \"Verbs inherited from \\\"\", o.name, \"\\\" (\", o, \")\"});";
"          else";
"            player:notify();";
"          endif";
"          l = {{\"strong\", i}, \" \"};";
"          vd = $verb_detail(o, j);";
"          `vd[\"state\"] == \"dirty\" ! E_RANGE' && (l = {@l, {\"span.warning\", \"[dirty]\"}, \" \"});";
"          `vd[\"content_type\"] ! E_RANGE' && (l = {@l, vd[\"content_type\"], \" \"});";
"          player:notify(\"  \", @l);";
"          player:notify(\"    \", toliteral(verb_info(o, j)));";
"          player:notify(\"    \", toliteral(verb_args(o, j)));";
"        else";
"          if (1 == j)";
"            player:notify();";
"            player:notify({\"h2\", \"Verbs inherited from \\\"\", o.name, \"\\\" (\", o, \")\"});";
"          else";
"            player:notify();";
"          endif";
"          player:notify(i);";
"          player:notify(\"  <<permission denied>>\");";
"        endif";
"      endfor";
"    else";
"      player:notify();";
"      player:notify({\"h2\", \"Verbs from \\\"\", o.name, \"\\\" (\", o, \")\"});";
"      player:notify(\"  <<permission denied>>\");";
"    endif";
"  endfor";
"";
"  for o in (ancestors)";
"    if (utilities:_player_controls_object(o) || o.r)";
"      for i, j in (properties(o))";
"        if (utilities:_player_controls_property(dobj, i))";
"          if (dobj == o && 1 == j)";
"            player:notify();";
"            player:notify({\"h2\", \"Properties defined on \\\"\", o.name, \"\\\" (\", o, \")\"});";
"          elseif (1 == j)";
"            player:notify();";
"            player:notify({\"h2\", \"Properties inherited from \\\"\", o.name, \"\\\" (\", o, \")\"});";
"          else";
"            player:notify();";
"          endif";
"          l = {{\"strong\", i}, \" \"};";
"          is_clear_property(dobj, i) && (l = {@l, {\"span.information\", \"[clear]\"}, \" \"});";
"          l = {@l, toliteral(dobj.(i)):truncate()};";
"          player:notify(\"  \", @l);";
"          player:notify(\"    \", toliteral(property_info(dobj, i)));";
"        else";
"          if (1 == j)";
"            player:notify();";
"            player:notify({\"h2\", \"Properties inherited from \\\"\", o.name, \"\\\" (\", o, \")\"});";
"          else";
"            player:notify();";
"          endif";
"          player:notify(i);";
"          player:notify(\"  <<permission denied>>\");";
"        endif";
"      endfor";
"    else";
"      player:notify();";
"      player:notify({\"h2\", \"Properties from \\\"\", o.name, \"\\\" (\", o, \")\"});";
"      player:notify(\"  <<permission denied>>\");";
"    endif";
"  endfor";
"";
"endif";
"";
"player:notify();";
"player:notify(\"(done)\");";
"";
"chunk_length:137";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:E19AA7236288BD87EFB6F35A40E383654364D84F";
"-=-=-mxyzptlk-=-=-";
.
#91:5
if (player != this)
player:notify("I couldn't understand that.");
return;
elseif (!player.programmer)
player:notify("You need to be a programmer to @diff verb code.");
return;
endif
player_utilities = $lookup("player_utilities");
{o, v} = player_utilities:match_verb(dobjstr);
if (!v)
player:notify("I couldn't understand that.");
return;
elseif (v && (`vi = verb_info(o, v) ! E_VERBNF' == E_VERBNF))
player:notify("That verb doesn't exist.");
return;
elseif ((!player_utilities:_player_controls_verb(o, v)) && (!index(vi[2], "r")))
player:notify("You don't have permission to do that.");
return;
endif
vd = $verb_detail(o, v);
if (`vd["state"] ! E_RANGE' != "dirty")
player:notify("There is nothing to diff; the verb is clean.");
return;
endif
if (`vd["revision"] ! E_RANGE => 0' < 2)
player:notify("There is nothing to diff; there is only one revision.");
return;
endif
set_task_perms(player);
r1 = vd["revision"] - 1;
r2 = vd["revision"];
vc1 = verb_code(o, v, ["revision" -> r1]);
vc2 = verb_code(o, v, ["revision" -> r2]);
player:notify({"strong", "--- ", dobjstr, " r", r1});
player:notify({"strong", "+++ ", dobjstr, " r", r2, " (dirty)"});
patience_diff = $lookup("patience_diff|text_tools");
diffs = patience_diff:diff(vc1, vc2);
for diff in (diffs)
pos1 = diff[2];
pos2 = diff[3];
if (diff[1] == "r")
df1 = diff[4];
ln1 = length(df1);
df2 = diff[5];
ln2 = length(df2);
elseif (diff[1] == "+")
df1 = {};
ln1 = 0;
df2 = diff[4];
ln2 = length(df2);
elseif (diff[1] = "-")
df1 = diff[4];
ln1 = length(df1);
df2 = {};
ln2 = 0;
endif
before = (pos1 > 1) ? tostr(" ", vc1[pos1 - 1]) | 0;
after = (((pos1 + ln1) - 1) < length(vc1)) ? tostr(" ", vc1[pos1 + ln1]) | 0;
player:notify({"span.information", "@@ -", pos1, ",", ln1, " +", pos2, ",", ln2, " @@"});
before && player:notify(before);
for l in (df1)
player:notify({"span.deletion", "-" + l});
endfor
for l in (df2)
player:notify({"span.insertion", "+" + l});
endfor
after && player:notify(after);
endfor
player:notify("(done)");
return;
"if (player != this)";
"  player:notify(\"I couldn't understand that.\");";
"  return;";
"elseif (!player.programmer)";
"  player:notify(\"You need to be a programmer to @diff verb code.\");";
"  return;";
"endif";
"";
"player_utilities = $lookup(\"player_utilities\");";
"";
"{o, v} = player_utilities:match_verb(dobjstr);";
"if (!v)";
"  player:notify(\"I couldn't understand that.\");";
"  return;";
"elseif (v && `vi = verb_info(o, v) ! E_VERBNF' == E_VERBNF)";
"  player:notify(\"That verb doesn't exist.\");";
"  return;";
"elseif (!player_utilities:_player_controls_verb(o, v) && !index(vi[2], \"r\"))";
"  player:notify(\"You don't have permission to do that.\");";
"  return;";
"endif";
"";
"vd = $verb_detail(o, v);";
"if (`vd[\"state\"] ! E_RANGE' != \"dirty\")";
"  player:notify(\"There is nothing to diff; the verb is clean.\");";
"  return;";
"endif";
"if (`vd[\"revision\"] ! E_RANGE => 0' < 2)";
"  player:notify(\"There is nothing to diff; there is only one revision.\");";
"  return;";
"endif";
"";
"set_task_perms(player);";
"";
"r1 = vd[\"revision\"] - 1;";
"r2 = vd[\"revision\"];";
"";
"vc1 = verb_code(o, v, [\"revision\" -> r1]);";
"vc2 = verb_code(o, v, [\"revision\" -> r2]);";
"";
"player:notify({\"strong\", \"--- \", dobjstr, \" r\", r1});";
"player:notify({\"strong\", \"+++ \", dobjstr, \" r\", r2, \" (dirty)\"});";
"";
"patience_diff = $lookup(\"patience_diff|text_tools\");";
"";
"diffs = patience_diff:diff(vc1, vc2);";
"";
"for diff in (diffs)";
"  pos1 = diff[2];";
"  pos2 = diff[3];";
"  if (diff[1] == \"r\")";
"    df1 = diff[4];";
"    ln1 = length(df1);";
"    df2 = diff[5];";
"    ln2 = length(df2);";
"  elseif (diff[1] == \"+\")";
"    df1 = {};";
"    ln1 = 0;";
"    df2 = diff[4];";
"    ln2 = length(df2);";
"  elseif (diff[1] = \"-\")";
"    df1 = diff[4];";
"    ln1 = length(df1);";
"    df2 = {};";
"    ln2 = 0;";
"  endif";
"  before = pos1 > 1 ? tostr(\" \", vc1[pos1 - 1]) | 0;";
"  after = pos1 + ln1 - 1 < length(vc1) ? tostr(\" \", vc1[pos1 + ln1]) | 0;";
"  player:notify({\"span.information\", \"@@ -\", pos1, \",\", ln1, \" +\", pos2, \",\", ln2, \" @@\"});";
"  before && player:notify(before);";
"  for l in (df1)";
"    player:notify({\"span.deletion\", \"-\" + l});";
"  endfor";
"  for l in (df2)";
"    player:notify({\"span.insertion\", \"+\" + l});";
"  endfor";
"  after && player:notify(after);";
"endfor";
"";
"player:notify(\"(done)\");";
"";
"chunk_length:80";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:AB5FA12CA20A13F0A60B099C95E434B3B5580B15";
"-=-=-mxyzptlk-=-=-";
.
#91:6
if (player != this)
player:notify("I couldn't understand that.");
return;
elseif (!player.programmer)
player:notify("You need to be a programmer to ", verb, " verb code.");
return;
endif
player_utilities = $lookup("player_utilities");
{o, v} = player_utilities:match_verb(dobjstr);
if (!v)
player:notify("I couldn't understand that.");
return;
elseif (v && (`vi = verb_info(o, v) ! E_VERBNF' == E_VERBNF))
player:notify("That verb doesn't exist.");
return;
elseif ((!player_utilities:_player_controls_verb(o, v)) && (!index(vi[2], "w")))
player:notify("You don't have permission to do that.");
return;
endif
vd = $verb_detail(o, v);
if (`vd["state"] ! E_RANGE' != "dirty")
player:notify("There is nothing to ", verb[2..$], "; the verb is clean.");
return;
endif
if (("@revert" == verb) && (`vd["revision"] ! E_RANGE => 0' < 2))
player:notify("There is nothing to revert; there is only one revision.");
return;
endif
set_task_perms(player);
if ("@commit" == verb)
$verb_commit(o, v);
player:notify("You committed the changes to ", dobjstr);
elseif ("@revert" == verb)
$verb_revert(o, v);
player:notify("You reverted the changes to ", dobjstr);
endif
return;
"if (player != this)";
"  player:notify(\"I couldn't understand that.\");";
"  return;";
"elseif (!player.programmer)";
"  player:notify(\"You need to be a programmer to \", verb, \" verb code.\");";
"  return;";
"endif";
"";
"player_utilities = $lookup(\"player_utilities\");";
"";
"{o, v} = player_utilities:match_verb(dobjstr);";
"if (!v)";
"  player:notify(\"I couldn't understand that.\");";
"  return;";
"elseif (v && `vi = verb_info(o, v) ! E_VERBNF' == E_VERBNF)";
"  player:notify(\"That verb doesn't exist.\");";
"  return;";
"elseif (!player_utilities:_player_controls_verb(o, v) && !index(vi[2], \"w\"))";
"  player:notify(\"You don't have permission to do that.\");";
"  return;";
"endif";
"";
"vd = $verb_detail(o, v);";
"if (`vd[\"state\"] ! E_RANGE' != \"dirty\")";
"  player:notify(\"There is nothing to \", verb[2..$], \"; the verb is clean.\");";
"  return;";
"endif";
"";
"if (\"@revert\" == verb && `vd[\"revision\"] ! E_RANGE => 0' < 2)";
"  player:notify(\"There is nothing to revert; there is only one revision.\");";
"  return;";
"endif";
"";
"set_task_perms(player);";
"";
"if (\"@commit\" == verb)";
"  $verb_commit(o, v);";
"  player:notify(\"You committed the changes to \", dobjstr);";
"elseif (\"@revert\" == verb)";
"  $verb_revert(o, v);";
"  player:notify(\"You reverted the changes to \", dobjstr);";
"endif";
"";
"chunk_length:42";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:39BA28E527A97FD9B68E40D9EC05118E1BE8A11E";
"-=-=-mxyzptlk-=-=-";
.
#92:0
if (player != this)
notify(player, "I couldn't understand that.");
return;
elseif (!player.wizard)
notify(player, "You need to be a wizard to shut down the server.");
return;
endif
player:notify("Goodbye!");
shutdown();
return;
"if (player != this)";
"  notify(player, \"I couldn't understand that.\");";
"  return;";
"elseif (!player.wizard)";
"  notify(player, \"You need to be a wizard to shut down the server.\");";
"  return;";
"endif";
"";
"player:notify(\"Goodbye!\");";
"";
"shutdown();";
"";
"chunk_length:11";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:18873593F31BE54AEC357B9E2B33503F0BBBA9E5";
"-=-=-mxyzptlk-=-=-";
.
#95:0
$restrict_to_caller($system, "authenticate");
if (length(args) == 2)
{name, password} = args;
for player in (descendants($authenticatable))
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
if (name == player.name)
if ($identity.utilities:verify_hashed_password(password, player.hashed_password))
return player;
endif
endif
endfor
endif
return $failed_match;
return;
"$restrict_to_caller($system, \"authenticate\");";
"";
"if (length(args) == 2)";
"  {name, password} = args;";
"  for player in (descendants($authenticatable))";
"    ticks_left() < 10000 || seconds_left() < 2 && suspend(0);";
"    if (name == player.name)";
"      if ($identity.utilities:verify_hashed_password(password, player.hashed_password))";
"        return player;";
"      endif";
"    endif";
"  endfor";
"endif";
"";
"return $failed_match;";
"";
"chunk_length:15";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:50370C512358FE45E8981F60B94CB2993F78E88C";
"-=-=-mxyzptlk-=-=-";
.
#96:0
if (player != this)
notify(player, "I couldn't understand that.");
return;
endif
first_time = !this.hashed_password;
if (!first_time)
notify(player, "To change your password, first specify your old password, and then specify and confirm your new password.");
else
notify(player, "To set your password, specify and confirm your password.");
endif
try
set_connection_option(player, "binary", 1);
set_connection_option(player, "hold-input", 1);
set_connection_option(player, "client-echo", 0);
if (!first_time)
notify(player, "          Old Password: ");
while (!(((old_password = read()) && (old_password = decode_binary(old_password))) && (typeof(old_password = old_password[1]) == STR)))
endwhile
notify(player, "~0A~0D");
endif
notify(player, "          New Password: ");
while (!(((new_password = read()) && (new_password = decode_binary(new_password))) && (typeof(new_password = new_password[1]) == STR)))
endwhile
notify(player, "~0A~0D");
notify(player, "  Confirm New Password: ");
while (!(((confirm_password = read()) && (confirm_password = decode_binary(confirm_password))) && (typeof(confirm_password = confirm_password[1]) == STR)))
endwhile
notify(player, "~0A~0D");
finally
set_connection_option(player, "binary", 0);
set_connection_option(player, "hold-input", 0);
set_connection_option(player, "client-echo", 1);
endtry
utilities = $lookup("utilities");
if (this.hashed_password && (!utilities:verify_hashed_password(old_password, this.hashed_password)))
notify(player, tostr("Old password is incorrect.  Password not ", first_time ? "set" | "changed", "."));
return;
endif
if (new_password != confirm_password)
notify(player, tostr("Password and confirmation do not match.  Password not ", first_time ? "set" | "changed", "."));
return;
endif
this.hashed_password = utilities:hash_password(new_password);
notify(player, tostr("Password ", first_time ? "set" | "changed", "."));
return;
"if (player != this)";
"  notify(player, \"I couldn't understand that.\");";
"  return;";
"endif";
"";
"first_time = !this.hashed_password;";
"";
"if (!first_time)";
"  notify(player, \"To change your password, first specify your old password, and then specify and confirm your new password.\");";
"else";
"  notify(player, \"To set your password, specify and confirm your password.\");";
"endif";
"";
"try";
"  set_connection_option(player, \"binary\", 1);";
"  set_connection_option(player, \"hold-input\", 1);";
"  set_connection_option(player, \"client-echo\", 0);";
"";
"  /* when reading lines, discard telnet commands and empty lines */";
"";
"  if (!first_time)";
"    notify(player, \"          Old Password: \");";
"    while (!((old_password = read()) && (old_password = decode_binary(old_password)) && (typeof(old_password = old_password[1]) == STR)))";
"    endwhile";
"    notify(player, \"~0A~0D\");";
"  endif";
"";
"  notify(player, \"          New Password: \");";
"  while (!((new_password = read()) && (new_password = decode_binary(new_password)) && (typeof(new_password = new_password[1]) == STR)))";
"  endwhile";
"  notify(player, \"~0A~0D\");";
"";
"  notify(player, \"  Confirm New Password: \");";
"  while (!((confirm_password = read()) && (confirm_password = decode_binary(confirm_password)) && (typeof(confirm_password = confirm_password[1]) == STR)))";
"  endwhile";
"  notify(player, \"~0A~0D\");";
"";
"finally";
"  set_connection_option(player, \"binary\", 0);";
"  set_connection_option(player, \"hold-input\", 0);";
"  set_connection_option(player, \"client-echo\", 1);";
"endtry";
"";
"utilities = $lookup(\"utilities\");";
"";
"if (this.hashed_password && !utilities:verify_hashed_password(old_password, this.hashed_password))";
"  notify(player, tostr(\"Old password is incorrect.  Password not \", (first_time ? \"set\" | \"changed\"), \".\" ));";
"  return;";
"endif";
"";
"if (new_password != confirm_password)";
"  notify(player, tostr(\"Password and confirmation do not match.  Password not \", (first_time ? \"set\" | \"changed\"), \".\" ));";
"  return;";
"endif";
"";
"this.hashed_password = utilities:hash_password(new_password);";
"";
"notify(player, tostr(\"Password \", (first_time ? \"set\" | \"changed\"), \".\" ));";
"";
"chunk_length:58";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:8DBF0ACBC439BF88839CCEDB52B304930BF3BCCB";
"-=-=-mxyzptlk-=-=-";
.
#97:0
{password, hashed_password} = args;
try
algo = hashed_password["algo"];
salt = hashed_password["salt"];
hash = hashed_password["hash"];
except (E_RANGE)
raise(E_INVARG, "Invalid hashed password");
endtry
((algo && salt) && hash) || raise(E_INVARG, "Invalid hashed password");
(((typeof(algo) == STR) && (typeof(salt) == STR)) && (typeof(hash) == STR)) || raise(E_INVARG, "Invalid hashed password");
(algo in {"sha256"}) || raise(E_INVARG, "Unsupported algo");
new_hash = string_hash(salt + password, algo);
if ((length = length(new_hash)) != length(hash))
return 0;
endif
count = 0;
for i in [1..length]
count = ((new_hash[i] == hash[i]) ? 1 | 0) + count;
endfor
return length == count;
return;
"{password, hashed_password} = args;";
"try";
"  algo = hashed_password[\"algo\"];";
"  salt = hashed_password[\"salt\"];";
"  hash = hashed_password[\"hash\"];";
"except (E_RANGE)";
"  raise(E_INVARG, \"Invalid hashed password\");";
"endtry";
"algo && salt && hash || raise(E_INVARG, \"Invalid hashed password\");";
"typeof(algo) == STR && typeof(salt) == STR && typeof(hash) == STR || raise(E_INVARG, \"Invalid hashed password\");";
"algo in {\"sha256\"} || raise(E_INVARG, \"Unsupported algo\");";
"/* absolutely use a *constant time* comparison to frustrate timing attacks */";
"new_hash = string_hash(salt + password, algo);";
"if ((length = length(new_hash)) != length(hash))";
"  return 0;";
"endif";
"count = 0;";
"for i in [1..length]";
"  count = (new_hash[i] == hash[i] ? 1 | 0) + count;";
"endfor";
"return length == count;";
"";
"chunk_length:21";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:41112376E5760A2247C86287362A042A8FEC11D9";
"-=-=-mxyzptlk-=-=-";
.
#97:1
{password} = args;
algo = "sha256";
salt = string_hash(tostr(random(), time()), algo);
hash = string_hash(salt + password, algo);
return ["algo" -> algo, "salt" -> salt, "hash" -> hash];
return;
"{password} = args;";
"algo = \"sha256\";";
"salt = string_hash(tostr(random(), time()), algo);";
"hash = string_hash(salt + password, algo);";
"return [\"algo\" -> algo, \"salt\" -> salt, \"hash\" -> hash];";
"";
"chunk_length:5";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:15DD175E1035003708BEFB2AF757479D9FA8D806";
"-=-=-mxyzptlk-=-=-";
.
#102:0
{predicate} = args;
if (!predicate)
elseif (index("\"'", c = predicate[1]))
(n = match(predicate, ("[^\\]" + c) + " *")) || raise(E_INVARG, "Missing end-quote");
return {{STR, predicate[2..n[1]]:strsub({{"\\\\", "\\"}, {"\\\"", "\""}})}, predicate[n[2] + 1..$]};
elseif (((c == "#") && (r = match(predicate, "^%(#-?[0-9]+%) *"))) && ((length(predicate) == r[2]) || (predicate[r[2]] == " ")))
return {{OBJ, toobj(predicate[r[3][1][1]..r[3][1][2]])}, predicate[r[2] + 1..$]};
elseif (index("-+0123456789", c))
if ((r = match(predicate, "^%([-+]?[0-9]+%) *")) && ((length(predicate) == r[2]) || (predicate[r[2]] == " ")))
return {{INT, toint(predicate[r[3][1][1]..r[3][1][2]])}, predicate[r[2] + 1..$]};
elseif ((r = match(predicate, "^%([-+]?[0-9]+%.[0-9]+%) *")) && ((length(predicate) == r[2]) || (predicate[r[2]] == " ")))
return {{FLOAT, tofloat(predicate[r[3][1][1]..r[3][1][2]])}, predicate[r[2] + 1..$]};
endif
elseif ((r = match(predicate, "^%(%?%|%#%|[_a-z][_a-z0-9]*%) *")) && ((length(predicate) == r[2]) || (predicate[r[2]] == " ")))
return {{-1, predicate[r[3][1][1]..r[3][1][2]]}, predicate[r[2] + 1..$]};
endif
raise(E_INVARG, tostr("Unmatched literal or identifier:  ", predicate));
return;
"{predicate} = args;";
"";
"/* the predicate string must _not_ start with whitespace */";
"if (!predicate)";
"  ;";
"elseif (index(\"\\\"'\", (c = predicate[1])))";
"  (n = match(predicate, \"[^\\\\]\" + c + \" *\")) || raise(E_INVARG, \"Missing end-quote\");";
"  return {{STR, predicate[2..n[1]]:strsub({{\"\\\\\\\\\", \"\\\\\"}, {\"\\\\\\\"\", \"\\\"\"}})}, predicate[n[2] + 1..$]};";
"elseif (c == \"#\" && (r = match(predicate, \"^%(#-?[0-9]+%) *\")) && (length(predicate) == r[2] || predicate[r[2]] == \" \"))";
"  return {{OBJ, toobj(predicate[r[3][1][1]..r[3][1][2]])}, predicate[r[2] + 1..$]};";
"elseif (index(\"-+0123456789\", c))";
"  if ((r = match(predicate, \"^%([-+]?[0-9]+%) *\")) && (length(predicate) == r[2] || predicate[r[2]] == \" \"))";
"    return {{INT, toint(predicate[r[3][1][1]..r[3][1][2]])}, predicate[r[2] + 1..$]};";
"  elseif ((r = match(predicate, \"^%([-+]?[0-9]+%.[0-9]+%) *\")) && (length(predicate) == r[2] || predicate[r[2]] == \" \"))";
"    return {{FLOAT, tofloat(predicate[r[3][1][1]..r[3][1][2]])}, predicate[r[2] + 1..$]};";
"  endif";
"elseif ((r = match(predicate, \"^%(%?%|%#%|[_a-z][_a-z0-9]*%) *\")) && (length(predicate) == r[2] || predicate[r[2]] == \" \"))";
"  return {{-1, predicate[r[3][1][1]..r[3][1][2]]}, predicate[r[2] + 1..$]};";
"endif";
"";
"raise(E_INVARG, tostr(\"Unmatched literal or identifier:  \", predicate));";
"";
"chunk_length:21";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:DAEA6192C540D70B5A757640AF059D2ACBB228E9";
"-=-=-mxyzptlk-=-=-";
.
#102:1
{predicate} = args;
if (!predicate)
elseif ((r = match(predicate, "^%(>=?%|<=?%|=[=~]?%|!=%|includes%|in%|is%) *")) && ((length(predicate) == r[2]) || (predicate[r[2]] == " ")))
return {predicate[r[3][1][1]..r[3][1][2]], predicate[r[2] + 1..$]};
endif
raise(E_INVARG, tostr("Unmatched operator:  ", predicate));
return;
"{predicate} = args;";
"";
"/* the predicate string must _not_ start with whitespace */";
"if (!predicate)";
"  ;";
"elseif ((r = match(predicate, \"^%(>=?%|<=?%|=[=~]?%|!=%|includes%|in%|is%) *\")) && (length(predicate) == r[2] || predicate[r[2]] == \" \"))";
"  return {predicate[r[3][1][1]..r[3][1][2]], predicate[r[2] + 1..$]};";
"endif";
"";
"raise(E_INVARG, tostr(\"Unmatched operator:  \", predicate));";
"";
"chunk_length:10";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:AC122D01FE3F4E7A7AFDC9FC85D8A569EDEE82A9";
"-=-=-mxyzptlk-=-=-";
.
#102:2
{predicate, @args} = args;
predicate = predicate:trim();
predicate || raise(E_INVARG, "Empty predicate");
{operand1, predicate} = this:_match_literal_or_identifier(predicate);
{operator, predicate} = this:_match_operator(predicate);
{operand2, predicate} = this:_match_literal_or_identifier(predicate);
predicate && raise(E_INVARG, "Trailing predicate");
if (operator == "is")
if ((operand2[1] < 0) && (operand2[2] == "true"))
operand2 = {INT, 1};
elseif ((operand2[1] < 0) && (operand2[2] == "false"))
operand2 = {INT, 0};
else
raise(E_INVARG, tostr("Invalid operand for `is': ", operand2[2]));
endif
endif
if (operand1[1] < 0)
if (operand1[2] == "?")
{arg, @args} = args;
operand1 = {typeof(arg), arg};
elseif (operand1[2] == "#")
operand1[2] = $ask.ID;
endif
endif
if (operand2[1] < 0)
if (operand2[2] == "?")
{arg, @args} = args;
operand2 = {typeof(arg), arg};
elseif (operand2[2] == "#")
operand2[2] = $ask.ID;
endif
endif
return {operand1, operator, operand2};
return;
"{predicate, @args} = args;";
"";
"predicate = predicate:trim();";
"";
"predicate || raise(E_INVARG, \"Empty predicate\");";
"";
"{operand1, predicate} = this:_match_literal_or_identifier(predicate);";
"{operator, predicate} = this:_match_operator(predicate);";
"{operand2, predicate} = this:_match_literal_or_identifier(predicate);";
"";
"predicate && raise(E_INVARG, \"Trailing predicate\");";
"";
"/* handle the special case \"is true\"/\"is false\" */";
"";
"if (operator == \"is\")";
"  if (operand2[1] < 0 && operand2[2] == \"true\")";
"    operand2 = {INT, 1};";
"  elseif (operand2[1] < 0 && operand2[2] == \"false\")";
"    operand2 = {INT, 0};";
"  else";
"    raise(E_INVARG, tostr(\"Invalid operand for `is': \", operand2[2]));";
"  endif";
"endif";
"";
"/* The first item in the operand list is either -1 or a type value";
" * (INT, FLOAT, STR, etc.).  If the first item is -1, the second item";
" * is either an identifier, \"?\" or \"#\".  \"?\" is replaced by the";
" * appropriate positional argument, just as if it were a literal.  \"#\"";
" * is replaced by the special object number identifier `$ask:id()'.";
" */";
"if (operand1[1] < 0)";
"  if (operand1[2] == \"?\")";
"    {arg, @args} = args;";
"    operand1 = {typeof(arg), arg};";
"  elseif (operand1[2] == \"#\")";
"    operand1[2] = $ask.ID;";
"  endif";
"endif";
"";
"if (operand2[1] < 0)";
"  if (operand2[2] == \"?\")";
"    {arg, @args} = args;";
"    operand2 = {typeof(arg), arg};";
"  elseif (operand2[2] == \"#\")";
"    operand2[2] = $ask.ID;";
"  endif";
"endif";
"";
"return {operand1, operator, operand2};";
"";
"chunk_length:49";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:0A4130D05BB4D1C532E5FB363997D56CE669D96F";
"-=-=-mxyzptlk-=-=-";
.
#102:3
{from} = args;
instance = (this == $ask) ? create(this, 1) | this;
(instance.from == 0) || raise(E_INVARG, "Second from not allowed");
instance.from = from;
return instance;
return;
"{from} = args;";
"";
"instance = (this == $ask) ? create(this, 1) | this;";
"";
"instance.from == 0 || raise(E_INVARG, \"Second from not allowed\");";
"instance.from = from;";
"";
"return instance;";
"";
"chunk_length:8";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:399743308123418C6E9DC37E80DA3D3391EAE8CD";
"-=-=-mxyzptlk-=-=-";
.
#102:4
attributes = args;
instance = (this == $ask) ? create(this, 1) | this;
select = ["select" -> attributes];
instance.operations = instance.operations ? {@instance.operations, select} | {select};
return instance;
return;
"attributes = args;";
"";
"instance = (this == $ask) ? create(this, 1) | this;";
"";
"select = [\"select\" -> attributes];";
"instance.operations = instance.operations ? {@instance.operations, select} | {select};";
"";
"return instance;";
"";
"chunk_length:8";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:979DD4149551202740B6FE74ED36E489F86EB1FC";
"-=-=-mxyzptlk-=-=-";
.
#102:5
{predicate, @args} = args;
instance = (this == $ask) ? create(this, 1) | this;
where = ["where" -> $ask:_parse_predicate(predicate, @args)];
instance.operations = instance.operations ? {@instance.operations, where} | {where};
return instance;
return;
"{predicate, @args} = args;";
"";
"instance = (this == $ask) ? create(this, 1) | this;";
"";
"where = [\"where\" -> $ask:_parse_predicate(predicate, @args)];";
"instance.operations = instance.operations ? {@instance.operations, where} | {where};";
"";
"return instance;";
"";
"chunk_length:8";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:F29FE8B2918492C1B96ACF93F62CA740549F59BC";
"-=-=-mxyzptlk-=-=-";
.
#102:6
(this == $ask) && raise(E_PERM, "Call not allowed on prototype");
res = this.query_utilities:query(this, -1);
return length(res);
return;
"(this == $ask) && raise(E_PERM, \"Call not allowed on prototype\");";
"res = this.query_utilities:query(this, -1);";
"return length(res);";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:104E61B99CA2451A2809603B1C64330E1957BA86";
"-=-=-mxyzptlk-=-=-";
.
#102:7
(this == $ask) && raise(E_PERM, "Call not allowed on prototype");
res = this.query_utilities:query(this, -1);
return res;
return;
"(this == $ask) && raise(E_PERM, \"Call not allowed on prototype\");";
"res = this.query_utilities:query(this, -1);";
"return res;";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:29DD8D06B8AD2994A9A481FB485402A2761DADCE";
"-=-=-mxyzptlk-=-=-";
.
#102:8
(this == $ask) && raise(E_PERM, "Call not allowed on prototype");
res = this.query_utilities:query(this, 1);
return res;
return;
"(this == $ask) && raise(E_PERM, \"Call not allowed on prototype\");";
"res = this.query_utilities:query(this, 1);";
"return res;";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:DBE1452404E71AD84A28F81BC5B7A781A7AC09A7";
"-=-=-mxyzptlk-=-=-";
.
#105:0
$restrict_to_caller($system, "server_started");
try
file_stat(".");
`file_mkdir("private") || server_log(tostr(file_version(), ": created \"files/private\"")) ! E_FILE';
`file_mkdir("private/app") || server_log(tostr(file_version(), ": created \"files/private/app\"")) ! E_FILE';
`file_mkdir("public") || server_log(tostr(file_version(), ": created \"files/public\"")) ! E_FILE';
`file_mkdir("public/app") || server_log(tostr(file_version(), ": created \"files/public/app\"")) ! E_FILE';
`file_mkdir("public/css") || server_log(tostr(file_version(), ": created \"files/public/css\"")) ! E_FILE';
`file_mkdir("public/img") || server_log(tostr(file_version(), ": created \"files/public/img\"")) ! E_FILE';
`file_mkdir("public/js") || server_log(tostr(file_version(), ": created \"files/public/js\"")) ! E_FILE';
`file_mkdir("tmp") || server_log(tostr(file_version(), ": created \"files/tmp\"")) ! E_FILE';
except (ANY)
server_log(tostr(file_version(), ": missing \"files\" directory"));
endtry
return;
"$restrict_to_caller($system, \"server_started\");";
"try";
"  file_stat(\".\");";
"  `file_mkdir(\"private\") || server_log(tostr(file_version(), \": created \\\"files/private\\\"\")) ! E_FILE';";
"  `file_mkdir(\"private/app\") || server_log(tostr(file_version(), \": created \\\"files/private/app\\\"\")) ! E_FILE';";
"  `file_mkdir(\"public\") || server_log(tostr(file_version(), \": created \\\"files/public\\\"\")) ! E_FILE';";
"  `file_mkdir(\"public/app\") || server_log(tostr(file_version(), \": created \\\"files/public/app\\\"\")) ! E_FILE';";
"  `file_mkdir(\"public/css\") || server_log(tostr(file_version(), \": created \\\"files/public/css\\\"\")) ! E_FILE';";
"  `file_mkdir(\"public/img\") || server_log(tostr(file_version(), \": created \\\"files/public/img\\\"\")) ! E_FILE';";
"  `file_mkdir(\"public/js\") || server_log(tostr(file_version(), \": created \\\"files/public/js\\\"\")) ! E_FILE';";
"  `file_mkdir(\"tmp\") || server_log(tostr(file_version(), \": created \\\"files/tmp\\\"\")) ! E_FILE';";
"except (ANY)";
"  server_log(tostr(file_version(), \": missing \\\"files\\\" directory\"));";
"endtry";
"";
"chunk_length:14";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:494FB4EEE91B453CA651336A969FA2E47144B1ED";
"-=-=-mxyzptlk-=-=-";
.
#106:0
$permit("wizard", "owner");
{?full = 1} = args;
if (full)
return mapvalues(this.attachments);
else
return mapkeys(this.attachments);
endif
return;
"$permit(\"wizard\", \"owner\");";
"";
"{?full = 1} = args;";
"";
"if (full)";
"  return mapvalues(this.attachments);";
"else";
"  return mapkeys(this.attachments);";
"endif";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:4B94E55E2C7EDCD795795DEA27557075D64CDF49";
"-=-=-mxyzptlk-=-=-";
.
#106:1
$permit("wizard", "owner");
{attachment, ?option = 0} = args;
if (!option)
return this.attachments[attachment];
elseif (`value = this.attachments[attachment][option] ! E_RANGE')
return value;
elseif (option == "data")
fh = -1;
data = "";
path = this.attachments[attachment]["path"];
size = this.attachments[attachment]["size"];
try
fh = file_open(path, "r-bn");
while ((pos = file_tell(fh)) != size)
chunk = file_read(fh, size - pos);
data = data ? data + chunk | chunk;
endwhile
finally
(fh > -1) && file_close(fh);
endtry
return data;
else
raise(E_INVARG);
endif
return;
"$permit(\"wizard\", \"owner\");";
"";
"{attachment, ?option = 0} = args;";
"";
"if (!option)";
"  return this.attachments[attachment];";
"elseif (`value = this.attachments[attachment][option] ! E_RANGE')";
"  return value;";
"elseif (option == \"data\")";
"  fh = -1;";
"  data = \"\";";
"  path = this.attachments[attachment][\"path\"];";
"  size = this.attachments[attachment][\"size\"];";
"  try";
"    fh = file_open(path, \"r-bn\");";
"    while ((pos = file_tell(fh)) != size)";
"      chunk = file_read(fh, size - pos);";
"      data = data ? data + chunk | chunk;";
"    endwhile";
"  finally";
"    (fh > -1) && file_close(fh);";
"  endtry";
"  return data;";
"else";
"  raise(E_INVARG);";
"endif";
"";
"chunk_length:26";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:09868DF21A3E53C9FD1CE92F4F523BA1F8857827";
"-=-=-mxyzptlk-=-=-";
.
#106:2
$permit("wizard", "owner");
{attachment} = args;
`this.attachments[attachment] ! E_RANGE => raise(E_INVARG, tostr("No such attachment: ", attachment), attachment)';
`file_stat(filename = this.attachments[attachment]["path"]) ! E_RANGE, E_FILE => raise(E_INVARG, tostr("No such attached file: ", filename), filename)';
return 1;
return;
"$permit(\"wizard\", \"owner\");";
"";
"{attachment} = args;";
"";
"/* Raises E_INVARG if the attachment is not an attachment; raises";
" * E_FILE if the associated file does not exist.";
" */";
"`this.attachments[attachment] ! E_RANGE => raise(E_INVARG, tostr(\"No such attachment: \", attachment), attachment)';";
"`file_stat(filename = this.attachments[attachment][\"path\"]) ! E_RANGE, E_FILE => raise(E_INVARG, tostr(\"No such attached file: \", filename), filename)';";
"";
"return 1;";
"";
"chunk_length:11";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:6E03C948540B6FB85C955A0034BC4B4C6152EFD7";
"-=-=-mxyzptlk-=-=-";
.
#106:3
$restrict_to_builtin("recycle");
args && raise(E_ARGS);
for attachment in (this.attachments)
`file_remove(attachment["path"]) ! E_RANGE, E_FILE';
endfor
return;
"$restrict_to_builtin(\"recycle\");";
"";
"args && raise(E_ARGS);";
"";
"for attachment in (this.attachments)";
"  `file_remove(attachment[\"path\"]) ! E_RANGE, E_FILE'; /* if the file is missing, move on... */";
"endfor";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:11679240172E789BD6A0031B98447E9A887C2E2F";
"-=-=-mxyzptlk-=-=-";
.
#106:4
$private();
{name, pool, ?mkdir = 1} = args;
name || raise(E_INVARG, name);
`this.attachment_pools[pool] ! E_RANGE' || raise(E_INVARG, pool);
path = string_hash(tostr(this, name, pool), "md5");
path[3] = "/";
path[6] = "/";
path[9] = "/";
if (mkdir)
parts = {path[1..2], path[1..5], path[1..8]};
for part in (parts)
`file_mkdir(tostr(this.attachment_pools[pool], "/", part)) ! E_FILE';
endfor
endif
return path;
return;
"$private();";
"";
"{name, pool, ?mkdir = 1} = args;";
"";
"name || raise(E_INVARG, name);";
"`this.attachment_pools[pool] ! E_RANGE' || raise(E_INVARG, pool);";
"";
"path = string_hash(tostr(this, name, pool), \"md5\");";
"path[3] = \"/\";";
"path[6] = \"/\";";
"path[9] = \"/\";";
"";
"if (mkdir)";
"  parts = {path[1..2], path[1..5], path[1..8]};";
"  for part in (parts)";
"    `file_mkdir(tostr(this.attachment_pools[pool], \"/\", part)) ! E_FILE';";
"  endfor";
"endif";
"";
"return path;";
"";
"chunk_length:20";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:5011167A064F72953458E0B2BC00F33F0591576A";
"-=-=-mxyzptlk-=-=-";
.
#106:5
$permit("wizard", "owner");
{data, attachment, pool, type, ?processors = []} = args;
this:_check_limit();
(typeof(data) == STR) || raise(E_TYPE);
`this.attachments[attachment] ! E_RANGE' && raise(E_INVARG, tostr("Already an attachment: ", attachment), attachment);
`this.attachment_pools[pool] ! E_RANGE' || raise(E_INVARG, tostr("Invalid pool: ", pool), pool);
path = tostr(this.attachment_pools[pool], "/", this:_path_for(attachment, pool));
fh = -1;
try
fh = file_open(path, "w-bn");
file_write(fh, data);
finally
(fh > -1) && file_close(fh);
endtry
size = file_size(path);
this.attachments[attachment] = {attachment, path, pool, type};
this.attachments[attachment] = ["name" -> attachment, "path" -> path, "size" -> size, "type" -> type, "pool" -> pool];
for _, process in (processors)
if ("thumbnail" == process)
sizes = processors["thumbnail"];
sizes = (typeof(sizes) == STR) ? {sizes} | sizes;
this:_thumbnail(attachment, path, pool, type, sizes);
else
raise(E_INVARG, process);
endif
endfor
return this;
return;
"$permit(\"wizard\", \"owner\");";
"";
"{data, attachment, pool, type, ?processors = []} = args;";
"";
"this:_check_limit();";
"";
"typeof(data) == STR || raise(E_TYPE);";
"`this.attachments[attachment] ! E_RANGE' && raise(E_INVARG, tostr(\"Already an attachment: \", attachment), attachment);";
"`this.attachment_pools[pool] ! E_RANGE' || raise(E_INVARG, tostr(\"Invalid pool: \", pool), pool);";
"";
"path = tostr(this.attachment_pools[pool], \"/\", this:_path_for(attachment, pool));";
"";
"fh = -1;";
"try";
"  fh = file_open(path, \"w-bn\");";
"  file_write(fh, data);";
"finally";
"  (fh > -1) && file_close(fh);";
"endtry";
"";
"size = file_size(path);";
"";
"this.attachments[attachment] = {attachment, path, pool, type};";
"this.attachments[attachment] = [\"name\" -> attachment, \"path\" -> path, \"size\" -> size, \"type\" -> type, \"pool\" -> pool];";
"";
"for _, process in (processors)";
"  if (\"thumbnail\" == process)";
"    sizes = processors[\"thumbnail\"];";
"    sizes = typeof(sizes) == STR ? {sizes} | sizes;";
"    this:_thumbnail(attachment, path, pool, type, sizes);";
"  else";
"    raise(E_INVARG, process);";
"  endif";
"endfor";
"";
"return this;";
"";
"chunk_length:36";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:43B5B4F10D7EC1F96065734938CB29BF72D8D077";
"-=-=-mxyzptlk-=-=-";
.
#106:6
$permit("wizard", "owner");
{filename, attachment, pool, type, ?processors = []} = args;
this:_check_limit();
(typeof(filename) == STR) || raise(E_TYPE);
`this.attachments[attachment] ! E_RANGE' && raise(E_INVARG, tostr("Already an attachment: ", attachment), attachment);
`this.attachment_pools[pool] ! E_RANGE' || raise(E_INVARG, tostr("Invalid pool: ", pool), pool);
match(filename, "^/?tmp/.") || raise(E_INVARG, tostr("Must be a temporary file: ", filename), filename);
(file_type(filename) == "reg") || raise(E_INVARG, tostr("Must be a regular file: ", filename), filename);
for path in ({filename, attachment})
index(path, "./") && raise(E_INVARG, path);
index(path, "..") && raise(E_INVARG, path);
endfor
old_path = filename;
new_path = tostr(this.attachment_pools[pool], "/", this:_path_for(attachment, pool));
file_rename(old_path, new_path);
size = file_size(new_path);
this.attachments[attachment] = {attachment, new_path, pool, type};
this.attachments[attachment] = ["name" -> attachment, "path" -> new_path, "size" -> size, "type" -> type, "pool" -> pool];
for _, process in (processors)
if ("thumbnail" == process)
sizes = processors["thumbnail"];
sizes = (typeof(sizes) == STR) ? {sizes} | sizes;
this:_thumbnail(attachment, new_path, pool, type, sizes);
else
raise(E_INVARG, process);
endif
endfor
return this;
return;
"$permit(\"wizard\", \"owner\");";
"";
"{filename, attachment, pool, type, ?processors = []} = args;";
"";
"this:_check_limit();";
"";
"typeof(filename) == STR || raise(E_TYPE);";
"`this.attachments[attachment] ! E_RANGE' && raise(E_INVARG, tostr(\"Already an attachment: \", attachment), attachment);";
"`this.attachment_pools[pool] ! E_RANGE' || raise(E_INVARG, tostr(\"Invalid pool: \", pool), pool);";
"";
"(match(filename, \"^/?tmp/.\")) || raise(E_INVARG, tostr(\"Must be a temporary file: \", filename), filename);";
"(file_type(filename) == \"reg\") || raise(E_INVARG, tostr(\"Must be a regular file: \", filename), filename);";
"";
"for path in ({filename, attachment})";
"  index(path, \"./\") && raise(E_INVARG, path);";
"  index(path, \"..\") && raise(E_INVARG, path);";
"endfor";
"";
"old_path = filename;";
"new_path = tostr(this.attachment_pools[pool], \"/\", this:_path_for(attachment, pool));";
"file_rename(old_path, new_path);";
"";
"size = file_size(new_path);";
"";
"this.attachments[attachment] = {attachment, new_path, pool, type};";
"this.attachments[attachment] = [\"name\" -> attachment, \"path\" -> new_path, \"size\" -> size, \"type\" -> type, \"pool\" -> pool];";
"";
"for _, process in (processors)";
"  if (\"thumbnail\" == process)";
"    sizes = processors[\"thumbnail\"];";
"    sizes = typeof(sizes) == STR ? {sizes} | sizes;";
"    this:_thumbnail(attachment, new_path, pool, type, sizes);";
"  else";
"    raise(E_INVARG, process);";
"  endif";
"endfor";
"";
"return this;";
"";
"chunk_length:38";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:E8D005C377A1CF4345A68C85CEAEBEC971958B9D";
"-=-=-mxyzptlk-=-=-";
.
#106:7
$permit("wizard", "owner");
{attachment} = args;
`this.attachments[attachment] ! E_RANGE' || raise(E_INVARG, tostr("No such attachment: ", attachment), attachment);
`file_remove(this.attachments[attachment]["path"]) ! E_RANGE, E_FILE';
this.attachments = mapdelete(this.attachments, attachment);
return this;
return;
"$permit(\"wizard\", \"owner\");";
"";
"{attachment} = args;";
"";
"`this.attachments[attachment] ! E_RANGE' || raise(E_INVARG, tostr(\"No such attachment: \", attachment), attachment);";
"";
"`file_remove(this.attachments[attachment][\"path\"]) ! E_RANGE, E_FILE';";
"";
"this.attachments = mapdelete(this.attachments, attachment);";
"";
"return this;";
"";
"chunk_length:11";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:2A1E791398FFB08044F57E069C493272A8E0377E";
"-=-=-mxyzptlk-=-=-";
.
#106:8
$private();
{path} = args;
try
{code, out, ERR} = exec({"identify", "-format", "%m", path});
except (E_INVARG, E_FILE)
return 0;
endtry
code && raise(E_INVARG, tostr("Can't identify: ", decode_binary(ERR)[1]));
return decode_binary(out)[1];
return;
"$private();";
"";
"{path} = args;";
"";
"try";
"  {code, out, err} = exec({\"identify\", \"-format\", \"%m\", path});";
"except (E_INVARG, E_FILE)";
"  return 0;";
"endtry";
"";
"code && raise(E_INVARG, tostr(\"Can't identify: \", decode_binary(err)[1]));";
"";
"return decode_binary(out)[1];";
"";
"chunk_length:13";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:CBC9E169942E62FE158B7341C7A667DB5A5CE85F";
"-=-=-mxyzptlk-=-=-";
.
#106:9
$private();
{attachment, path, pool, type, sizes} = args;
if (!this:_identify(tostr("files/", path)))
return;
endif
for size in (sizes)
this:_check_limit();
match(size, "^%([1-9][0-9][0-9]?%)x%([1-9][0-9][0-9]?%)$") || raise(E_INVARG, size);
attachment = size + ".png";
thumbnail = tostr(this.attachment_pools[pool], "/", this:_path_for(attachment, pool));
exec({"convert", tostr("files/", path), "-thumbnail", size, "-bordercolor", "white", "-border", "60", "-gravity", "center", "-crop", size + "+0+0", "+repage", tostr("files/", thumbnail)});
this.attachments[size + ".png"] = {size + ".png", thumbnail, pool, "image/png"};
this.attachments[attachment] = ["name" -> attachment, "path" -> thumbnail, "size" -> file_size(thumbnail), "type" -> "image/png", "pool" -> pool];
endfor
return;
"$private();";
"";
"{attachment, path, pool, type, sizes} = args;";
"";
"/* raise an error if we can't identify the file type */";
"/* but don't raise an error if we can't identify at all */";
"if (!this:_identify(tostr(\"files/\", path)))";
"  return;";
"endif";
"";
"for size in (sizes)";
"  this:_check_limit();";
"  match(size, \"^%([1-9][0-9][0-9]?%)x%([1-9][0-9][0-9]?%)$\") || raise(E_INVARG, size);";
"  attachment = size + \".png\";";
"  thumbnail = tostr(this.attachment_pools[pool], \"/\", this:_path_for(attachment, pool));";
"  exec({\"convert\", tostr(\"files/\", path), \"-thumbnail\", size, \"-bordercolor\", \"white\", \"-border\", \"60\", \"-gravity\", \"center\", \"-crop\", size + \"+0+0\", \"+repage\", tostr(\"files/\", thumbnail)});";
"  this.attachments[size + \".png\"] = {size + \".png\", thumbnail, pool, \"image/png\"};";
"  this.attachments[attachment] = [\"name\" -> attachment, \"path\" -> thumbnail, \"size\" -> file_size(thumbnail), \"type\" -> \"image/png\", \"pool\" -> pool];";
"endfor";
"";
"chunk_length:19";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:92B08D48B59BD0224852AC07FB4E283C90FE84E9";
"-=-=-mxyzptlk-=-=-";
.
#106:10
$private();
(length(this.attachments) < this.attachment_limit) || raise(E_QUOTA);
return;
"$private();";
"";
"(length(this.attachments) < this.attachment_limit) || raise(E_QUOTA);";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:2605769F71081BDE86193A8F286D9AD2D2F1270A";
"-=-=-mxyzptlk-=-=-";
.
#108:0
set_task_perms(caller_perms());
{prototype, instance, properties, ?loud = 0} = args;
properties = this:_before_validate(prototype, instance, properties);
if (`properties[$model.errors] ! E_RANGE')
return properties;
endif
for constraints, property in (`prototype.constraints ! E_PROPNF => []')
for constraint in (constraints)
if (LIST == typeof(constraint))
{constraint, ?options = []} = constraint;
else
options = [];
endif
if ("" == constraint)
elseif ("present" == constraint)
properties = $model.validates_presence_of:validate(prototype, instance, properties, property, options);
elseif ("unique" == constraint)
properties = $model.validates_uniqueness_of:validate(prototype, instance, properties, property, options);
elseif ("immutable" == constraint)
properties = $model.validates_immutability_of:validate(prototype, instance, properties, property, options);
elseif ("format" == constraint)
properties = $model.validates_format_of:validate(prototype, instance, properties, property, options);
endif
endfor
endfor
(loud && `properties[$model.errors] ! E_RANGE') && raise("-*-invalid-*-", "Validation failed", properties);
properties = this:_after_validate(prototype, instance, properties);
return properties;
return;
"set_task_perms(caller_perms());";
"";
"{prototype, instance, properties, ?loud = 0} = args;";
"";
"properties = this:_before_validate(prototype, instance, properties);";
"if (`properties[$model.errors] ! E_RANGE')";
"  return properties;";
"endif";
"";
"for constraints, property in (`prototype.constraints ! E_PROPNF => []')";
"  for constraint in (constraints)";
"    if (LIST == typeof(constraint))";
"      {constraint, ?options = []} = constraint;";
"    else";
"      options = [];";
"    endif";
"    if (\"\" == constraint)";
"      ;";
"    elseif (\"present\" == constraint)";
"      properties = $model.validates_presence_of:validate(prototype, instance, properties, property, options);";
"    elseif (\"unique\" == constraint)";
"      properties = $model.validates_uniqueness_of:validate(prototype, instance, properties, property, options);";
"    elseif (\"immutable\" == constraint)";
"      properties = $model.validates_immutability_of:validate(prototype, instance, properties, property, options);";
"    elseif (\"format\" == constraint)";
"      properties = $model.validates_format_of:validate(prototype, instance, properties, property, options);";
"    endif";
"  endfor";
"endfor";
"";
"loud && `properties[$model.errors] ! E_RANGE' && raise(\"-*-invalid-*-\", \"Validation failed\", properties);";
"";
"properties = this:_after_validate(prototype, instance, properties);";
"";
"return properties;";
"";
"chunk_length:35";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:996C4D4E8FE6299445840AC49953FAB4F54BE917";
"-=-=-mxyzptlk-=-=-";
.
#108:1
set_task_perms(caller_perms());
{prototype, properties, ?loud = 0} = args;
(typeof(properties) == MAP) || raise(E_INVARG, "properties must be a map");
if ((typeof(prototype) != OBJ) || (!valid(prototype)))
properties[$model.errors] = "invalid prototype";
return properties;
endif
instance = $nothing;
properties = this:validate(prototype, instance, properties, loud);
if (`properties[$model.errors] ! E_RANGE')
return properties;
endif
properties = this:_before_create(prototype, instance, properties);
if (`properties[$model.errors] ! E_RANGE')
return properties;
endif
try
instance = create(prototype);
properties[$model.id] = instance;
except (E_PERM)
properties[$model.errors] = "permission denied";
return properties;
except (E_QUOTA)
properties[$model.errors] = "quota exceeded";
return properties;
endtry
for value, property in (properties)
if (`property in prototype.accessible ! E_PROPNF')
temp = $shapes:write_value(instance, property, ["Value" -> ["value" -> value]]);
if (`error = temp["Error"]["diagnostic"] ! E_RANGE')
properties = properties:set_value_by_path({$model.errors, property}, error);
endif
properties[property] = temp["Value"]["value"];
endif
endfor
if (`properties[$model.errors] ! E_RANGE')
return properties;
endif
properties = this:_after_create(prototype, instance, properties);
if (`properties[$model.errors] ! E_RANGE')
return properties;
endif
return this:read(prototype, instance);
return;
"set_task_perms(caller_perms());";
"";
"{prototype, properties, ?loud = 0} = args;";
"";
"(typeof(properties) == MAP) || raise(E_INVARG, \"properties must be a map\");";
"";
"if (typeof(prototype) != OBJ || !valid(prototype))";
"  properties[$model.errors] = \"invalid prototype\";";
"  return properties;";
"endif";
"";
"instance = $nothing;";
"";
"properties = this:validate(prototype, instance, properties, loud);";
"if (`properties[$model.errors] ! E_RANGE')";
"  return properties;";
"endif";
"";
"properties = this:_before_create(prototype, instance, properties);";
"if (`properties[$model.errors] ! E_RANGE')";
"  return properties;";
"endif";
"";
"try";
"  instance = create(prototype);";
"  properties[$model.id] = instance;";
"except (E_PERM)";
"  properties[$model.errors] = \"permission denied\";";
"  return properties;";
"except (E_QUOTA)";
"  properties[$model.errors] = \"quota exceeded\";";
"  return properties;";
"endtry";
"";
"for value, property in (properties)";
"  if (`property in prototype.accessible ! E_PROPNF')";
"    temp = $shapes:write_value(instance, property, [\"Value\" -> [\"value\" -> value]]);";
"    if (`error = temp[\"Error\"][\"diagnostic\"] ! E_RANGE')";
"      properties = properties:set_value_by_path({$model.errors, property}, error);";
"    endif";
"    properties[property] = temp[\"Value\"][\"value\"];";
"  endif";
"endfor";
"if (`properties[$model.errors] ! E_RANGE')";
"  return properties;";
"endif";
"";
"properties = this:_after_create(prototype, instance, properties);";
"if (`properties[$model.errors] ! E_RANGE')";
"  return properties;";
"endif";
"";
"return this:read(prototype, instance);";
"";
"chunk_length:53";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:9094A3498D54EE7FBAD3193E9D686292F3FDA546";
"-=-=-mxyzptlk-=-=-";
.
#108:2
set_task_perms(caller_perms());
{prototype, instance, properties, ?loud = 0} = args;
(typeof(properties) == MAP) || raise(E_INVARG, "properties must be a map");
if (((typeof(prototype) != OBJ) || (!valid(prototype))) || (!isa(instance, prototype)))
properties[$model.errors] = "invalid prototype";
return properties;
endif
properties = this:validate(prototype, instance, properties, loud);
if (`properties[$model.errors] ! E_RANGE')
return properties;
endif
properties = this:_before_update(prototype, instance, properties);
if (`properties[$model.errors] ! E_RANGE')
return properties;
endif
properties[$model.id] = instance;
for value, property in (properties)
if (`property in prototype.accessible ! E_PROPNF')
temp = $shapes:write_value(instance, property, ["Value" -> ["value" -> value]]);
if (`error = temp["Error"]["diagnostic"] ! E_RANGE')
properties = properties:set_value_by_path({$model.errors, property}, error);
endif
properties[property] = temp["Value"]["value"];
endif
endfor
if (`properties[$model.errors] ! E_RANGE')
return properties;
endif
properties = this:_after_update(prototype, instance, properties);
if (`properties[$model.errors] ! E_RANGE')
return properties;
endif
return this:read(prototype, instance);
return;
"set_task_perms(caller_perms());";
"";
"{prototype, instance, properties, ?loud = 0} = args;";
"";
"(typeof(properties) == MAP) || raise(E_INVARG, \"properties must be a map\");";
"";
"if (typeof(prototype) != OBJ || !valid(prototype) || !isa(instance, prototype))";
"  properties[$model.errors] = \"invalid prototype\";";
"  return properties;";
"endif";
"";
"properties = this:validate(prototype, instance, properties, loud);";
"if (`properties[$model.errors] ! E_RANGE')";
"  return properties;";
"endif";
"";
"properties = this:_before_update(prototype, instance, properties);";
"if (`properties[$model.errors] ! E_RANGE')";
"  return properties;";
"endif";
"";
"properties[$model.id] = instance;";
"";
"for value, property in (properties)";
"  if (`property in prototype.accessible ! E_PROPNF')";
"    temp = $shapes:write_value(instance, property, [\"Value\" -> [\"value\" -> value]]);";
"    if (`error = temp[\"Error\"][\"diagnostic\"] ! E_RANGE')";
"      properties = properties:set_value_by_path({$model.errors, property}, error);";
"    endif";
"    properties[property] = temp[\"Value\"][\"value\"];";
"  endif";
"endfor";
"if (`properties[$model.errors] ! E_RANGE')";
"  return properties;";
"endif";
"";
"properties = this:_after_update(prototype, instance, properties);";
"if (`properties[$model.errors] ! E_RANGE')";
"  return properties;";
"endif";
"";
"return this:read(prototype, instance);";
"";
"chunk_length:42";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:C8EF776DD7FC71F04B9E9471BEF542BE23ECB42E";
"-=-=-mxyzptlk-=-=-";
.
#108:3
set_task_perms(caller_perms());
{prototype, instance} = args;
if (((typeof(prototype) != OBJ) || (!valid(prototype))) || (!isa(instance, prototype)))
return [$model.errors -> "invalid prototype"];
endif
properties = [];
properties[$model.id] = instance;
for property in (`prototype.accessible ! E_PROPNF => {}')
try
properties[property] = instance.(property);
except (E_PERM)
properties = properties:set_value_by_path({$model.errors, property}, "permission denied");
endtry
endfor
return properties;
return;
"set_task_perms(caller_perms());";
"";
"{prototype, instance} = args;";
"";
"if (typeof(prototype) != OBJ || !valid(prototype) || !isa(instance, prototype))";
"  return [$model.errors -> \"invalid prototype\"];";
"endif";
"";
"properties = [];";
"";
"properties[$model.id] = instance;";
"";
"for property in (`prototype.accessible ! E_PROPNF => {}')";
"  try";
"    properties[property] = instance.(property);";
"  except (E_PERM)";
"    properties = properties:set_value_by_path({$model.errors, property}, \"permission denied\");";
"  endtry";
"endfor";
"";
"return properties;";
"";
"chunk_length:21";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:3DEBDE00FB50329462550C19FC51CD38CC9B1634";
"-=-=-mxyzptlk-=-=-";
.
#108:4
$private();
set_task_perms(caller_perms());
{prototype, instance, properties} = args;
if (r = match(verb, "^_%(before%|after%)_%(%validate%|create%|update%)$"))
callback = tostr(verb[r[3][1][1]..r[3][1][2]], "_", verb[r[3][2][1]..r[3][2][2]]);
if (respond_to(prototype, callback))
properties = prototype:(callback)(prototype, instance, properties);
(typeof(properties) == MAP) || raise(E_TYPE, "Invalid returned value", properties);
endif
endif
return properties;
return;
"$private();";
"";
"set_task_perms(caller_perms());";
"";
"{prototype, instance, properties} = args;";
"";
"if (r = match(verb, \"^_%(before%|after%)_%(%validate%|create%|update%)$\"))";
"  callback = tostr(verb[r[3][1][1]..r[3][1][2]], \"_\", verb[r[3][2][1]..r[3][2][2]]);";
"  if (respond_to(prototype, callback))";
"    properties = prototype:(callback)(prototype, instance, properties);";
"    typeof(properties) == MAP || raise(E_TYPE, \"Invalid returned value\", properties);";
"  endif";
"endif";
"";
"return properties;";
"";
"chunk_length:15";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:2E339CD45EAA1B9296CA5424A2EBB4F7F5B16833";
"-=-=-mxyzptlk-=-=-";
.
#108:5
{prototype, @values} = args;
accessible = setadd(`prototype.accessible ! E_PROPNF => {}', $model.id);
if (verb == "find")
return $ask:from(prototype):select(@accessible);
elseif (r = match(verb, "^find_by_%([a-zA-Z0-9_]+%)$"))
name = r[4][r[3][1][1]..r[3][1][2]];
return $ask:from(prototype):select(@accessible):where(tostr(name, " = ?"), @values);
endif
raise(E_INVARG);
return;
"{prototype, @values} = args;";
"";
"accessible = setadd(`prototype.accessible ! E_PROPNF => {}', $model.id);";
"";
"if (verb == \"find\")";
"  return $ask:from(prototype):select(@accessible);";
"";
"elseif (r = match(verb, \"^find_by_%([a-zA-Z0-9_]+%)$\"))";
"  name = r[4][r[3][1][1]..r[3][1][2]];";
"  return $ask:from(prototype):select(@accessible):where(tostr(name, \" = ?\"), @values);";
"";
"endif";
"";
"raise(E_INVARG);";
"";
"chunk_length:14";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:397C76FC5D8E9E8B0EC0BE361357B9E01171E880";
"-=-=-mxyzptlk-=-=-";
.
#110:0
set_task_perms(caller_perms());
return $model:(verb)(this, @args);
return;
"set_task_perms(caller_perms());";
"";
"/* Verbs `create()', `find()' and `find_by_*()' only require a valid";
" * prototype.  Use `this'.";
" */";
"";
"return $model:(verb)(this, @args);";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:9B45952FF2F2F705E3135AB046B4F2DB06AF1C86";
"-=-=-mxyzptlk-=-=-";
.
#110:1
set_task_perms(caller_perms());
if (args && (typeof(args[1]) == OBJ))
return $model:(verb)(this, @args);
else
for parent in (parents(this))
if (isa(parent, $model.model_proto))
return $model:(verb)(parent, this, @args);
endif
endfor
endif
return;
"set_task_perms(caller_perms());";
"";
"/* Verbs `validate()', `update()' and `read()' require a valid";
" * prototype and a valid instance.  If neither are provided,";
" * the prototype is the first parent that is a model prototype";
" * and the instance is `this'.";
" */";
"";
"if (args && typeof(args[1]) == OBJ)";
"  return $model:(verb)(this, @args);";
"else";
"  for parent in (parents(this))";
"    if (isa(parent, $model.model_proto))";
"      return $model:(verb)(parent, this, @args);";
"    endif";
"  endfor";
"endif";
"";
"chunk_length:17";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:B4E95A4D90B448D4686BF0A59C7B0EFA9FA2F2AA";
"-=-=-mxyzptlk-=-=-";
.
#111:0
{prototype, instance, properties, name, ?options = []} = args;
return properties;
return;
"{prototype, instance, properties, name, ?options = []} = args;";
"";
"return properties;";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:67FE5D7C3F0338E4E7C76CB2951354635A13F833";
"-=-=-mxyzptlk-=-=-";
.
#111:1
{properties, name, message} = args;
if (errors = properties:value_by_path({$model.errors, name}))
properties = properties:set_value_by_path({$model.errors, name}, (typeof(errors) == LIST) ? {@errors, message} | {errors, message});
else
properties = properties:set_value_by_path({$model.errors, name}, message);
endif
return properties;
return;
"{properties, name, message} = args;";
"";
"if (errors = properties:value_by_path({$model.errors, name}))";
"  properties = properties:set_value_by_path({$model.errors, name}, typeof(errors) == LIST ? {@errors, message} | {errors, message});";
"else";
"  properties = properties:set_value_by_path({$model.errors, name}, message);";
"endif";
"";
"return properties;";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:C12EC174BC809275A4A14E90F5178CEFD8303C3D";
"-=-=-mxyzptlk-=-=-";
.
#111:2
set_task_perms(caller_perms());
{h, k} = args;
if (typeof(h) == MAP)
present = (typeof(v = `h[k] ! E_RANGE') == STR) ? match(v, "[^ ]") | v;
else
present = (typeof(v = `h.(k) ! E_PROPNF') == STR) ? match(v, "[^ ]") | v;
endif
return ("is_present" == verb) ? !(!present) | (!present);
return;
"set_task_perms(caller_perms());";
"";
"{h, k} = args;";
"";
"if (typeof(h) == MAP)";
"  present = typeof(v = `h[k] ! E_RANGE') == STR ?";
"              match(v, \"[^ ]\") |";
"              v;";
"else";
"  present = typeof(v = `h.(k) ! E_PROPNF') == STR ?";
"              match(v, \"[^ ]\") |";
"              v;";
"endif";
"";
"return (\"is_present\" == verb) ? !!present | !present;";
"";
"chunk_length:15";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:5D3B24A96E58FE63A1849C19C223D4F65011F313";
"-=-=-mxyzptlk-=-=-";
.
#112:0
set_task_perms(caller_perms());
{prototype, instance, properties, name, ?options = []} = args;
if (this:is_blank(properties, name) && (!(valid(instance) && this:is_present(instance, name))))
properties = this:add_error(properties, name, "can't be blank");
endif
return properties;
return;
"set_task_perms(caller_perms());";
"";
"{prototype, instance, properties, name, ?options = []} = args;";
"";
"if (this:is_blank(properties, name) && !(valid(instance) && this:is_present(instance, name)))";
"  properties = this:add_error(properties, name, \"can't be blank\");";
"endif";
"";
"return properties;";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:B646EB67CE2967ABDF993394C5B736CBF6119220";
"-=-=-mxyzptlk-=-=-";
.
#113:0
set_task_perms(caller_perms());
{prototype, instance, properties, name, ?options = []} = args;
if ((`properties[name] ! E_RANGE' != E_RANGE) && (!(valid(instance) && (properties[name] == instance.(name)))))
if (valid($ask:from(prototype):where(name + " = ?", properties[name]):one()))
properties = this:add_error(properties, name, "is already taken");
endif
endif
return properties;
return;
"set_task_perms(caller_perms());";
"";
"{prototype, instance, properties, name, ?options = []} = args;";
"";
"if (`properties[name] ! E_RANGE' != E_RANGE && !(valid(instance) && properties[name] == instance.(name)))";
"  if (valid($ask:from(prototype):where(name + \" = ?\", properties[name]):one()))";
"    properties = this:add_error(properties, name, \"is already taken\");";
"  endif";
"endif";
"";
"return properties;";
"";
"chunk_length:11";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:63D90B2847224BDDA7400772E0D7BC9D74207EA1";
"-=-=-mxyzptlk-=-=-";
.
#114:0
set_task_perms(caller_perms());
{prototype, instance, properties, name, ?options = []} = args;
if ((`properties[name] ! E_RANGE' != E_RANGE) && (valid(instance) && (properties[name] != instance.(name))))
properties = this:add_error(properties, name, "can't be changed");
endif
return properties;
return;
"set_task_perms(caller_perms());";
"";
"{prototype, instance, properties, name, ?options = []} = args;";
"";
"if (`properties[name] ! E_RANGE' != E_RANGE && (valid(instance) && properties[name] != instance.(name)))";
"  properties = this:add_error(properties, name, \"can't be changed\");";
"endif";
"";
"return properties;";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:38D76B88B8BD9959CC3564E753DFC10D4D8C97EE";
"-=-=-mxyzptlk-=-=-";
.
#115:0
{prototype, instance, properties, name, ?options = []} = args;
pattern = `options["pattern"] ! E_RANGE => "^$"';
message = `options["message"] ! E_RANGE => "is not valid"';
if ((`properties[name] ! E_RANGE' != E_RANGE) && (!match(properties[name], pattern)))
properties = this:add_error(properties, name, message);
endif
return properties;
return;
"{prototype, instance, properties, name, ?options = []} = args;";
"";
"pattern = `options[\"pattern\"] ! E_RANGE => \"^$\"';";
"message = `options[\"message\"] ! E_RANGE => \"is not valid\"';";
"";
"if (`properties[name] ! E_RANGE' != E_RANGE && !match(properties[name], pattern))";
"  properties = this:add_error(properties, name, message);";
"endif";
"";
"return properties;";
"";
"chunk_length:10";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:52898C132056483AE48A3E3D89923F6E938A81A6";
"-=-=-mxyzptlk-=-=-";
.
#116:0
set_task_perms(caller_perms());
{prototype, instance, properties, name, ?options = []} = args;
if (valid(instance))
if (!(`properties[name] ! E_RANGE' != E_RANGE))
return this:add_error(properties, name, "is required");
elseif (properties[name] != instance.(name))
return this:add_error(properties, name, "is invalid");
endif
else
if (`properties[name] ! E_RANGE' != E_RANGE)
return this:add_error(properties, name, "is invalid");
endif
endif
properties[name] = `properties[name] ! E_RANGE => 0' + 1;
return properties;
return;
"set_task_perms(caller_perms());";
"";
"{prototype, instance, properties, name, ?options = []} = args;";
"";
"if (valid(instance))";
"  if (!(`properties[name] ! E_RANGE' != E_RANGE))";
"    return this:add_error(properties, name, \"is required\");";
"  elseif (properties[name] != instance.(name))";
"    return this:add_error(properties, name, \"is invalid\");";
"  endif";
"else";
"  if (`properties[name] ! E_RANGE' != E_RANGE)";
"    return this:add_error(properties, name, \"is invalid\");";
"  endif";
"endif";
"";
"properties[name] = `properties[name] ! E_RANGE => 0' + 1;";
"";
"return properties;";
"";
"chunk_length:19";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:00949BFF81FF829D374CB54CF26FAF20FC2A09FA";
"-=-=-mxyzptlk-=-=-";
.
#117:0
$restrict_to_caller($composed);
return;
"$restrict_to_caller($composed);";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:43EC437995D2B286E71AB2D966AB5FA752BDC714";
"-=-=-mxyzptlk-=-=-";
.
#117:1
$restrict_to_caller($composed);
return;
"$restrict_to_caller($composed);";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:43EC437995D2B286E71AB2D966AB5FA752BDC714";
"-=-=-mxyzptlk-=-=-";
.
#120:0
{h, ?p = ""} = args;
q = "";
for vl, k in (h)
for v in ((typeof(vl) == LIST) ? vl | {vl})
q = q ? q + "&" | q;
if (typeof(v) == MAP)
q = tostr(q, this:generate_query_string(v, ((p + "[") + k) + "]"));
else
q = tostr(q, p, k, "=", v);
endif
endfor
endfor
return q;
return;
"{h, ?p = \"\"} = args;";
"q = \"\";";
"for vl, k in (h)";
"  for v in (typeof(vl) == LIST ? vl | {vl})";
"    q = q ? q + \"&\" | q;";
"    if (typeof(v) == MAP)";
"      q = tostr(q, this:generate_query_string(v, p + \"[\" + k + \"]\"));";
"    else";
"      q = tostr(q, p, k, \"=\", v);";
"    endif";
"  endfor";
"endfor";
"return q;";
"";
"chunk_length:13";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:32835C46F41640AEE7452E0D62262B8F0FCB33D7";
"-=-=-mxyzptlk-=-=-";
.
#120:1
{s, ?c = 0} = args;
if (!s)
return [];
endif
h = [];
l = {};
s = s + "&";
while (s)
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
if (c >= 1000)
raise("-*-parameters-is-too-long-*-");
endif
c = c + 1;
i = index(s, "&");
l = {@l, s[1..i - 1]};
s[1..i] = "";
endwhile
for p in (l)
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
i = index(p, "=");
f = i ? p[1..i - 1] | p;
v = i ? p[i + 1..$] | "";
if (`h[f] ! E_RANGE' != E_RANGE)
h[f] = (typeof(h[f]) == LIST) ? {@h[f], v} | {h[f], v};
else
h[f] = v;
endif
endfor
return h;
return;
"{s, ?c = 0} = args;";
"/* Limit query strings to 1000 items to prevent DOS attacks.";
" * Start at `c', the count of parameters so far.";
" * See http://permalink.gmane.org/gmane.comp.security.full-disclosure/83694";
" *     http://www.ocert.org/advisories/ocert-2011-003.html";
" */";
"if (!s)";
"  return [];";
"endif";
"h = [];";
"l = {};";
"s = s + \"&\";";
"while (s)";
"  ticks_left() < 10000 || seconds_left() < 2 && suspend(0);";
"  if (c >= 1000)";
"    raise(\"-*-parameters-is-too-long-*-\");";
"  endif";
"  c = c + 1;";
"  i = index(s, \"&\");";
"  l = {@l, s[1..i - 1]};";
"  s[1..i] = \"\";";
"endwhile";
"for p in (l)";
"  ticks_left() < 10000 || seconds_left() < 2 && suspend(0);";
"  i = index(p, \"=\");";
"  f = i ? p[1..i - 1] | p;";
"  v = i ? p[i + 1..$] | \"\";";
"  if (`h[f] ! E_RANGE' != E_RANGE)";
"    h[f] = (typeof(h[f]) == LIST) ? {@h[f], v} | {h[f], v};";
"  else";
"    h[f] = v;";
"  endif";
"endfor";
"return h;";
"";
"chunk_length:34";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:3752CD009AA2FD5ED7AD88DDCE84E582C84DB28E";
"-=-=-mxyzptlk-=-=-";
.
#120:2
{uri} = args;
new = "";
while (uri)
if (r = match(uri, "[][!*'();:@&=+$,?#/ ]"))
i = uri[r[1]..r[2]] in this.reserved;
new = (new + uri[1..r[1] - 1]) + this.escaped[i];
uri[1..r[2]] = "";
else
new = tostr(new, uri);
uri = "";
endif
endwhile
return new;
return;
"{uri} = args";
"";
"new = \"\"";
"";
"while (uri)";
"  if (r = match(uri, \"[][!*'();:@&=+$,?#/ ]\"))";
"    i = uri[r[1]..r[2]] in this.reserved";
"    new = new + uri[1..r[1] - 1] + this.escaped[i]";
"    uri[1..r[2]] = \"\"";
"  else";
"    new = tostr(new, uri)";
"    uri = \"\"";
"  end";
"end";
"";
"return new";
"";
"chunk_length:16";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:BBD635EAF09F7FA515493E69956BECCF33D66AB8";
"-=-=-mxyzptlk-=-=-";
.
#120:3
{uri} = args;
new = "";
while (uri)
if (r = match(uri, "%%[a-fA-F0-9][a-fA-F0-9]%|%+"))
chr = (uri[r[1]] != "+") ? "~" + uri[r[1] + 1..r[2]] | "~20";
new = (new + uri[1..r[1] - 1]) + ((typeof(c = decode_binary(chr)[1]) == INT) ? chr | c);
uri[1..r[2]] = "";
else
new = tostr(new, uri);
uri = "";
endif
endwhile
return new;
return;
"{uri} = args";
"";
"new = \"\"";
"";
"while (uri)";
"  if (r = match(uri, \"%%[a-fA-F0-9][a-fA-F0-9]%|%+\"))";
"    chr = uri[r[1]] != \"+\" ? \"~\" + uri[r[1] + 1..r[2]] | \"~20\"";
"    new = new + uri[1..r[1] - 1] + (typeof(c = decode_binary(chr)[1]) == INT ? chr | c)";
"    uri[1..r[2]] = \"\"";
"  else";
"    new = tostr(new, uri)";
"    uri = \"\"";
"  end";
"end";
"";
"return new";
"";
"chunk_length:16";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:30AB2824CDB5BFE9CFD74CD095C75E5628D957CA";
"-=-=-mxyzptlk-=-=-";
.
#121:0
$private();
server_log(tostr(@args));
return;
"$private();";
"";
"server_log(tostr(@args));";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:650D9D9FCADD450749A1A67E616832EAFF78DC8D";
"-=-=-mxyzptlk-=-=-";
.
#121:1
$private();
bytes = {};
for i in [1..128 / 3]
n = random((256 * 256) * 256);
while (n)
bytes = {n % 256, @bytes};
n = n / 256;
endwhile
endfor
return encode_binary(bytes);
return;
"$private();";
"";
"bytes = {};";
"for i in [1..128 / 3]";
"  n = random(256 * 256 * 256);";
"  while (n)";
"    bytes = {n % 256, @bytes};";
"    n = n / 256;";
"  endwhile";
"endfor";
"";
"return encode_binary(bytes);";
"";
"chunk_length:12";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:BE0F8436461794647C35BFCB578C81BDC32E0C55";
"-=-=-mxyzptlk-=-=-";
.
#121:2
$permit("owner", "wizard");
`{port} = args ! E_ARGS => raise(E_ARGS, "Incorrect number of arguments:  port")';
this.key = this:_key();
listen(this, port, 0);
this.port = port;
return;
"$permit(\"owner\", \"wizard\");";
"";
"`{port} = args ! E_ARGS => raise(E_ARGS, \"Incorrect number of arguments:  port\")';";
"";
"this.key = this:_key();";
"";
"listen(this, port, 0);";
"";
"this.port = port;";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:7F76AD640411783E10EA4C1E47BEFF625870BD6F";
"-=-=-mxyzptlk-=-=-";
.
#121:3
$permit("owner", "wizard");
args && raise(E_ARGS);
port = 0;
for listener in (listeners())
if (listener[1] == this)
port = listener[2];
break;
endif
endfor
(!port) && raise(E_INVARG, "Server not running");
unlisten(port);
this.key = 0;
return;
"$permit(\"owner\", \"wizard\");";
"";
"args && raise(E_ARGS);";
"";
"port = 0;";
"";
"for listener in (listeners())";
"  if (listener[1] == this)";
"    port = listener[2];";
"    break;";
"  endif";
"endfor";
"";
"!port && raise(E_INVARG, \"Server not running\");";
"";
"unlisten(port);";
"";
"this.key = 0;";
"";
"chunk_length:18";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:3BDA0CFA5F590ECE040EEEA832C47E8AFDE9836E";
"-=-=-mxyzptlk-=-=-";
.
#121:4
$private();
return read_http("request", @args);
return;
"$private();";
"";
"/* provides a place to redefine network behavior in a child */";
"return read_http(\"request\", @args);";
"";
"chunk_length:4";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:00D751116B2CEA7C7EF4819AF89A1BA8E462315E";
"-=-=-mxyzptlk-=-=-";
.
#121:5
$private();
return notify(@args);
return;
"$private();";
"";
"/* provides a place to redefine network behavior in a child */";
"return notify(@args);";
"";
"chunk_length:4";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:EA8C0826FC0A7CFF737A580317BDF00143C24910";
"-=-=-mxyzptlk-=-=-";
.
#121:6
$private();
if (verb == "_session_cookie_name")
return this.session_cookie_name;
elseif (verb == "_flash_socket_policy")
return this.flash_socket_policy;
endif
return;
"$private();";
"";
"/* centralizes wiz-perm code for access to `c' properties on children */";
"if (verb == \"_session_cookie_name\")";
"  return this.session_cookie_name;";
"elseif (verb == \"_flash_socket_policy\")";
"  return this.flash_socket_policy;";
"endif";
"";
"chunk_length:8";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:41E5EEE5DB4FEB501050CBE720AC9ED755B7C38C";
"-=-=-mxyzptlk-=-=-";
.
#121:7
$private();
return this:_read_http(@args);
return;
"$private();";
"";
"return this:_read_http(@args);";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:00EB877D350D7E0552F9EACA0CE5461743A46C88";
"-=-=-mxyzptlk-=-=-";
.
#121:8
$private();
{connection, response} = args;
status_codes = this.status_codes;
status = `response["status"] ! E_RANGE => 0';
`status_codes[status] ! E_RANGE' || raise(E_INVARG, tostr("Status code must be one of:  ", status_codes:keys():join(", ")));
if (`body = response["body"] ! E_RANGE' != E_RANGE)
content_type = response["headers"]["content-type"];
content_length = response["headers"]["content-length"];
this:_notify(connection, tostr("HTTP/1.1 ", status, " ", status_codes[status], "~0D~0A"));
this:_notify(connection, tostr("Content-Type: ", content_type, "~0D~0A"));
this:_notify(connection, tostr("Content-Length: ", content_length, "~0D~0A"));
for value, field in (`response["headers"] ! E_RANGE => []')
if (!(field in {"Content-Type", "Content-Length"}))
this:_notify(connection, tostr(field, ": ", value, "~0D~0A"));
endif
endfor
this:_notify(connection, "~0D~0A");
this:_notify(connection, body);
else
this:_notify(connection, tostr("HTTP/1.1 ", status, " ", status_codes[status], "~0D~0A"));
this:_notify(connection, tostr("Content-Length: ", 0, "~0D~0A"));
for value, field in (`response["headers"] ! E_RANGE => []')
this:_notify(connection, tostr(field, ": ", value, "~0D~0A"));
endfor
this:_notify(connection, "~0D~0A");
endif
return;
"$private();";
"";
"{connection, response} = args;";
"";
"status_codes = this.status_codes;";
"status = `response[\"status\"] ! E_RANGE => 0';";
"`status_codes[status] ! E_RANGE' || raise(E_INVARG, tostr(\"Status code must be one of:  \", status_codes:keys():join(\", \")));";
"";
"if (`body = response[\"body\"] ! E_RANGE' != E_RANGE)";
"  content_type = response[\"headers\"][\"content-type\"];";
"  content_length = response[\"headers\"][\"content-length\"];";
"";
"  this:_notify(connection, tostr(\"HTTP/1.1 \", status, \" \", status_codes[status], \"~0D~0A\"));";
"  this:_notify(connection, tostr(\"Content-Type: \", content_type, \"~0D~0A\"));";
"  this:_notify(connection, tostr(\"Content-Length: \", content_length, \"~0D~0A\"));";
"  for value, field in (`response[\"headers\"] ! E_RANGE => []')";
"    if (!(field in {\"Content-Type\", \"Content-Length\"}))";
"      this:_notify(connection, tostr(field, \": \", value, \"~0D~0A\"));";
"    endif";
"  endfor";
"  this:_notify(connection, \"~0D~0A\");";
"  this:_notify(connection, body);";
"";
"else";
"  this:_notify(connection, tostr(\"HTTP/1.1 \", status, \" \", status_codes[status], \"~0D~0A\"));";
"  this:_notify(connection, tostr(\"Content-Length: \", 0, \"~0D~0A\"));";
"  for value, field in (`response[\"headers\"] ! E_RANGE => []')";
"    this:_notify(connection, tostr(field, \": \", value, \"~0D~0A\"));";
"  endfor";
"  this:_notify(connection, \"~0D~0A\");";
"";
"endif";
"";
"chunk_length:32";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:DB748D8D8C5AC6023EEF06939CDE38ABF5472F90";
"-=-=-mxyzptlk-=-=-";
.
#121:9
$private();
{connection, chain} = args;
try
request = create(this.request_proto, 1);
response = create(this.response_proto, 1);
try
raw_request = this:_read_from_connection(connection);
raw_response = [];
except (E_INVARG)
return 0;
endtry
if (`raw_request["error"] ! E_RANGE')
this:_log("DIALOG: ", player, " bad request: ", raw_request["error"][1], ": ", raw_request["error"][2]);
return 0;
endif
for v, k in (raw_request)
request.(k) = v;
endfor
{request, response} = this:_do_chain(request, response, chain);
for v in ({"status", "headers", "body"})
if (!is_clear_property(response, v))
raw_response[v] = response.(v);
endif
endfor
this:_write_to_connection(connection, raw_response);
finally
recycle(request);
recycle(response);
endtry
return 1;
return;
"$private()";
"";
"{connection, chain} = args";
"";
"try";
"  request = create(this.request_proto, 1)";
"  response = create(this.response_proto, 1)";
"";
"  try";
"    raw_request = this:_read_from_connection(connection)";
"    raw_response = []";
"  except (E_INVARG) // client closed connection or timeout";
"    return 0";
"  end";
"";
"  if (raw_request[\"error\"] !! E_RANGE)";
"    this:_log(\"DIALOG: \", player, \" bad request: \", raw_request[\"error\"][1], \": \", raw_request[\"error\"][2])";
"    return 0";
"  end";
"";
"  for v, k in (raw_request)";
"    request.(k) = v";
"  end";
"";
"  {request, response} = this:_do_chain(request, response, chain)";
"";
"  for v in ({\"status\", \"headers\", \"body\"})";
"    if (!is_clear_property(response, v))";
"      raw_response[v] = response.(v)";
"    endif";
"  end";
"";
"  this:_write_to_connection(connection, raw_response)";
"";
"finally";
"  recycle(request)";
"  recycle(response)";
"end";
"";
"return 1";
"";
"chunk_length:40";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:A1C70F70FDAE76192DF469451BDC325A939E39BA";
"-=-=-mxyzptlk-=-=-";
.
#121:10
$restrict_to_server();
set_connection_option(player, "hold-input", 1);
set_connection_option(player, "disable-oob", 1);
set_connection_option(player, "binary", 1);
if (flash_socket_policy = this:_flash_socket_policy())
if ((line = read(player)) == "<policy-file-request/>~00")
this:_log("DIALOG: serving policy file: ", flash_socket_policy);
notify(player, flash_socket_policy);
boot_player(player);
return;
else
force_input(player, line, 1);
endif
endif
while (1)
if (!this:_do_request(player, this.default_chain))
boot_player(player);
break;
endif
endwhile
return;
"$restrict_to_server();";
"";
"set_connection_option(player, \"hold-input\", 1);";
"set_connection_option(player, \"disable-oob\", 1);";
"set_connection_option(player, \"binary\", 1);";
"";
"/* If a flash socket policy is set, peek at the first line.  If it's a";
" * policy file request, serve the policy and finish; otherwise, put";
" * the line back and continue.";
" *";
" * A reasonable socket policy for localhost is:";
" * \"<?xml version=\\\"1.0\\\"?><cross-domain-policy><allow-access-from domain=\\\"localhost\\\" to-ports=\\\"*\\\"/></cross-domain-policy>\"";
" *";
" */";
"if (flash_socket_policy = this:_flash_socket_policy())";
"  if ((line = read(player)) == \"<policy-file-request/>~00\")";
"    this:_log(\"DIALOG: serving policy file: \", flash_socket_policy);";
"    notify(player, flash_socket_policy);";
"    boot_player(player);";
"    return;";
"  else";
"    force_input(player, line, 1);";
"  endif";
"endif";
"";
"/* Loop forever (or until the client closes the connection or until";
" * failure or until something else happens).";
" */";
"while (1)";
"  if (!this:_do_request(player, this.default_chain))";
"    boot_player(player);";
"    break;";
"  endif";
"endwhile";
"";
"chunk_length:34";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:60C47FCCDA2F5078D4BC25D74E6BFC3A69F8BB8C";
"-=-=-mxyzptlk-=-=-";
.
#121:11
$private();
{request, response, chain} = args;
try
cookies = request:cookies();
try
if (`cookie = cookies[this:_session_cookie_name()] ! E_RANGE')
i = cookie:index("-");
hmac = decode_base64(cookie[1..i - 1]);
session = decode_base64(cookie[i + 1..$]);
if ((hmac && session) && (string_hmac(session, this.key) == hmac))
session = parse_json(session, "embedded-types");
if ((session["stamp"] + 604800) > time())
session["data"];
else
this:_log("DIALOG: session cookie has expired");
session = [];
endif
else
this:_log("DIALOG: session cookie hmac does not match");
session = [];
endif
else
session = [];
endif
except (ANY)
this:_log("DIALOG: session cookie is invalid");
session = [];
endtry
if (session)
session = session["data"];
endif
if (!`session["authenticity_token"] ! E_RANGE')
token = string_hash(tostr(random(), time()));
for i in [1..10 + random(100)]
token = string_hash(tostr(random(), token));
endfor
session["authenticity_token"] = token;
endif
if (`session["player"] ! E_RANGE' != E_RANGE)
player = `session["player"] ! E_RANGE => $nothing';
player = (((typeof(player) == OBJ) && valid(player)) && is_player(player)) ? player | $nothing;
session["player"] = player;
endif
local = task_local();
local["http"] = ["session" -> session];
set_task_local(local);
return {request, response, chain};
except ex (ANY)
request = request:set_exception(ex);
return {request, response, {"cleanup", "500"}};
endtry
return;
"$private();";
"";
"{request, response, chain} = args;";
"";
"/* Validate the session and transfer it to a tamper-proof container.";
" * Create a new session if necessary.";
" */";
"";
"try";
"  cookies = request:cookies();";
"";
"  try";
"    if (`cookie = cookies[this:_session_cookie_name()] ! E_RANGE')";
"      i = cookie:index(\"-\");";
"      hmac = decode_base64(cookie[1..i - 1]);";
"      session = decode_base64(cookie[i + 1..$]);";
"      if (hmac && session && string_hmac(session, this.key) == hmac)";
"        session = parse_json(session, \"embedded-types\");";
"        if (session[\"stamp\"] + 604800 > time())";
"          /* probe the value */";
"          session[\"data\"];";
"        else";
"          this:_log(\"DIALOG: session cookie has expired\");";
"          session = [];";
"        endif";
"      else";
"        this:_log(\"DIALOG: session cookie hmac does not match\");";
"        session = [];";
"      endif";
"    else";
"      /* no session cookie */";
"      session = [];";
"    endif";
"  except (ANY)";
"    this:_log(\"DIALOG: session cookie is invalid\");";
"    session = [];";
"  endtry";
"";
"  if (session)";
"    session = session[\"data\"];";
"  endif";
"";
"  /* add an authenticity_token if missing */";
"  if (!`session[\"authenticity_token\"] ! E_RANGE')";
"    token = string_hash(tostr(random(), time()));";
"    for i in [1..10 + random(100)]";
"      token = string_hash(tostr(random(), token));";
"    endfor";
"    session[\"authenticity_token\"] = token;";
"  endif";
"";
"  /* validate the player if present */";
"  if (`session[\"player\"] ! E_RANGE' != E_RANGE)";
"    player = `session[\"player\"] ! E_RANGE => $nothing';";
"    player = typeof(player) == OBJ && valid(player) && is_player(player) ? player | $nothing;";
"    session[\"player\"] = player;";
"  endif";
"";
"  local = task_local();";
"  local[\"http\"] = [\"session\" -> session];";
"  set_task_local(local);";
"";
"  return {request, response, chain};";
"";
"except ex (ANY)";
"  request = request:set_exception(ex);";
"  return {request, response, {\"cleanup\", \"500\"}};";
"endtry";
"";
"chunk_length:68";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:15AB144A52452936167909CBE136B94E014A3C0B";
"-=-=-mxyzptlk-=-=-";
.
#121:12
{request, response, chain} = args;
$private();
for item in (this.contents)
if (isa(item, this.route_proto))
if (route = item:match(request))
{object, verb, parameters} = route;
request = request:set_parameters(`request:parameters() ! E_RANGE => []':merge(parameters));
request = request:set_handler({object, verb});
break;
endif
endif
endfor
return {request, response, chain};
return;
"{request, response, chain} = args;";
"";
"$private();";
"";
"for item in (this.contents)";
"  if (isa(item, this.route_proto))";
"    if (route = item:match(request))";
"      {object, verb, parameters} = route;";
"      request = request:set_parameters(`request:parameters() ! E_RANGE => []':merge(parameters));";
"      request = request:set_handler({object, verb});";
"      break;";
"    endif";
"  endif";
"endfor";
"";
"return {request, response, chain};";
"";
"chunk_length:16";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:4D54E4ABBFEE9D7B0330F92ED66848FF6D4407F8";
"-=-=-mxyzptlk-=-=-";
.
#121:13
{request, response, chain} = args;
$private();
try
connection = player;
parameters = [];
plen = 0;
parameters = parameters:merge(this.utilities:parse_query_string(this.utilities:unescape(request:query()), plen));
plen = length(parameters);
if (`{type, ?mtparams = []} = request:type("full") ! E_RANGE')
if (type == "application/x-www-form-urlencoded")
parameters = parameters:merge(this.utilities:parse_query_string(this.utilities:unescape(`request:body() ! E_RANGE => ""'), plen));
plen = length(parameters);
elseif (type == "multipart/form-data")
if (mtparams && `boundary = mtparams["boundary"] ! E_RANGE')
body = request:body():trimr(tostr("--", boundary, "--~0D~0A"));
for part in (body:split(tostr("--", boundary, "~0D~0A")))
content_disposition = {};
content_type = {"text/plain"};
while (c = part:index("~0D~0A"))
if (c > 1)
header = part[1..c - 1]:split(":");
field = header[1]:trim();
value = header[2]:trim():split(";");
for i in [1..length(value)]
if (i > 1)
j = value[i]:index("=");
value[i] = {value[i][1..j - 1]:trim(), value[i][j + 1..$]:trim()};
else
value[i] = value[i]:trim();
endif
endfor
if (field == "Content-Disposition")
content_disposition = value;
elseif (field == "Content-Type")
content_type = value;
endif
part = part[c + 6..$];
else
part = part[c + 6..$];
break;
endif
endwhile
value = part[1..$ - 6];
if (((len = length(content_disposition)) > 0) && (content_disposition[1] == "form-data"))
for attr in (content_disposition[2..$])
if (attr[1] == "name")
name = attr[2]:trim("\"");
elseif (attr[1] == "filename")
filename = attr[2]:trim("\"");
value = ["__filename__" -> filename, "__content-type__" -> content_type, "__data__" -> value];
endif
endfor
if (`name ! E_VARNF')
if (plen >= 1000)
raise("-*-parameters-is-too-long-*-");
endif
plen = plen + 1;
parameters[name] = value;
endif
endif
endfor
endif
endif
endif
for v, k in (parameters)
parameters = parameters:delete(k);
ll = {};
while (k)
if (r = match(k, "^%[[^][]*%]"))
if (match(p = r[4][r[1] + 1..r[2] - 1], "^ *__"))
ll = 0;
break;
endif
ll = {@ll, p};
k[r[1]..r[2]] = "";
else
if (match(k, "^ *__"))
ll = 0;
break;
endif
ll = {@ll, k};
k = "";
endif
endwhile
if (ll)
if (((typeof(v) == MAP) && `v["__filename__"] ! E_RANGE') && `v["__data__"] ! E_RANGE')
file_mkdir(tostr("tmp/", task_id()));
filename = tostr("tmp/", task_id(), "/", value_hash(random(), "md5"));
f = -1;
try
f = file_open(filename, "w-bn");
file_write(f, v["__data__"]);
finally
(f > -1) && file_close(f);
endtry
v["__data__"] = filename;
endif
if ((z = parameters:value_by_path(ll)) != E_RANGE)
parameters = parameters:set_value_by_path(ll, (typeof(z) == LIST) ? {@z, v} | {z, v});
else
parameters = parameters:set_value_by_path(ll, v);
endif
endif
endfor
session = `task_local()["http"]["session"] ! E_RANGE => []';
if (`authenticity_token = session["authenticity_token"] ! E_RANGE')
parameters["__authenticity_token__"] = authenticity_token;
endif
if (`valid(player = session["player"]) ! E_RANGE')
parameters["__player__"] = ["id" -> player, "name" -> player.name];
endif
headers = request:headers();
if (`headers["X-Requested-With"] == "XMLHttpRequest" ! E_RANGE')
parameters["__xhr__"] = 1;
else
parameters["__xhr__"] = 0;
endif
if (`headers["X-Forwarded-Proto"] == "https" ! E_RANGE')
parameters["__ssl__"] = 1;
protocol = "https";
else
parameters["__ssl__"] = 0;
protocol = "http";
endif
{?host = "", ?port = ""} = (`headers["X-Forwarded-Host"]:split(":") ! E_RANGE' || `headers["Host"]:split(":") ! E_RANGE') || {};
if (host && port)
parameters["__url_base__"] = tostr(protocol, "://", host, ":", port);
elseif (host)
parameters["__url_base__"] = tostr(protocol, "://", host);
endif
if (`clients = headers["X-Forwarded-For"] ! E_RANGE')
parameters["__remote_client__"] = clients:split(",")[$]:trim(" ");
elseif (`name = connection_name(connection) ! E_INVARG')
parameters["__remote_client__"] = name:split(" ")[4]:trim(",");
else
parameters["__remote_client__"] = "";
endif
request = request:set_parameters(parameters);
return {request, response, chain};
except ex ("-*-parameters-is-too-long-*-")
request = request:set_exception(ex);
return {request, response, {"cleanup", "413"}};
except ex (ANY)
request = request:set_exception(ex);
return {request, response, {"cleanup", "500"}};
endtry
return;
"{request, response, chain} = args;";
"";
"$private();";
"";
"try";
"  /* Save the player/connection.  This may be trounced";
"   * by the session, later.";
"   */";
"  connection = player;";
"";
"  /* Parameters derived from the query string and from the body are";
"   * under the control of an external user and therefore we can't";
"   * trust them.  Therefore, add them first, and then add all other";
"   * parameters from more-trusted/trusted sources (like the";
"   * convenience parameters).";
"   */";
"  parameters = [];";
"  plen = 0;";
"";
"  /* parameters from the query string */";
"  parameters = parameters:merge(this.utilities:parse_query_string(this.utilities:unescape(request:query()), plen));";
"  plen = length(parameters);";
"";
"  /* parameters from the body */";
"  if (`{type, ?mtparams = []} = request:type(\"full\") ! E_RANGE')";
"";
"    /* urlencoded parameters from the POST body */";
"    if (type == \"application/x-www-form-urlencoded\")";
"      parameters = parameters:merge(this.utilities:parse_query_string(this.utilities:unescape(`request:body() ! E_RANGE => \"\"'), plen));";
"      plen = length(parameters);";
"";
"    /* multipart form-data parameters from the POST body */";
"    elseif (type == \"multipart/form-data\")";
"      if (mtparams && `boundary = mtparams[\"boundary\"] ! E_RANGE')";
"        /* trim the fat and process each part */";
"        body = request:body():trimr(tostr(\"--\", boundary, \"--~0D~0A\"));";
"        for part in (body:split(tostr(\"--\", boundary, \"~0D~0A\")))";
"          content_disposition = {};";
"          content_type = {\"text/plain\"};";
"          /* process headers */";
"          while (c = part:index(\"~0D~0A\"))";
"            if (c > 1)";
"              header = part[1..c - 1]:split(\":\");";
"              field = header[1]:trim();";
"              value = header[2]:trim():split(\";\");";
"              for i in [1..length(value)]";
"                if (i > 1)";
"                  j = value[i]:index(\"=\");";
"                  value[i] = {value[i][1..j - 1]:trim(), value[i][j + 1..$]:trim()};";
"                else";
"                  value[i] = value[i]:trim();";
"                endif";
"              endfor";
"              if (field == \"Content-Disposition\")";
"                content_disposition = value;";
"              elseif (field == \"Content-Type\")";
"                content_type = value;";
"              endif";
"              part = part[c + 6..$];";
"            else";
"              part = part[c + 6..$];";
"              break;";
"            endif";
"          endwhile";
"          /* the value is what remains */";
"          value = part[1..$ - 6];";
"          /* add parameter */";
"          if ((len = length(content_disposition)) > 0 && content_disposition[1] == \"form-data\")";
"            for attr in (content_disposition[2..$])";
"              if (attr[1] == \"name\")";
"                name = attr[2]:trim(\"\\\"\");";
"              elseif (attr[1] == \"filename\")";
"                filename = attr[2]:trim(\"\\\"\");";
"                value = [\"__filename__\" -> filename, \"__content-type__\" -> content_type, \"__data__\" -> value];";
"              endif";
"            endfor";
"            if (`name ! E_VARNF')";
"              if (plen >= 1000)";
"                raise(\"-*-parameters-is-too-long-*-\");";
"              endif";
"              plen = plen + 1;";
"              parameters[name] = value;";
"            endif";
"          endif";
"        endfor";
"      endif";
"    endif";
"  endif";
"";
"  /* At this point the parameters map is flat, except for form data";
"   * upload parameters.  Step through the key/value pairs, strip out";
"   * pairs where the key begins with a double-underscore, create";
"   * nested parameters, create temporary files for upload data.";
"   */";
"  for v, k in (parameters)";
"    parameters = parameters:delete(k);";
"";
"    ll = {};";
"    while (k)";
"      if (r = match(k, \"^%[[^][]*%]\"))";
"        if (match((p = r[4][r[1] + 1..r[2] - 1]), \"^ *__\"))";
"          ll = 0;";
"          break;";
"        endif";
"        ll = {@ll, p};";
"        k[r[1]..r[2]] = \"\";";
"      else";
"        if (match(k, \"^ *__\"))";
"          ll = 0;";
"          break;";
"        endif";
"        ll = {@ll, k};";
"        k = \"\";";
"      endif";
"    endwhile";
"";
"    if (ll)";
"      if (typeof(v) == MAP && `v[\"__filename__\"] ! E_RANGE' && `v[\"__data__\"] ! E_RANGE')";
"        file_mkdir(tostr(\"tmp/\", task_id()));";
"        filename = tostr(\"tmp/\", task_id(), \"/\", value_hash(random(), \"md5\"));";
"        f = -1;";
"        try";
"          f = file_open(filename, \"w-bn\");";
"          file_write(f, v[\"__data__\"]);";
"        finally";
"          (f > -1) && file_close(f);";
"        endtry";
"        v[\"__data__\"] = filename;";
"      endif";
"";
"      if ((z = parameters:value_by_path(ll)) != E_RANGE)";
"        parameters = parameters:set_value_by_path(ll, typeof(z) == LIST ? {@z, v} | {z, v});";
"      else";
"        parameters = parameters:set_value_by_path(ll, v);";
"      endif";
"    endif";
"";
"  endfor";
"";
"  /* Add system/convenience parameters after _all_ _user supplied";
"   * parameters_ are added to prevent accidental/intentional redefinition.";
"   */";
"  session = `task_local()[\"http\"][\"session\"] ! E_RANGE => []';";
"";
"  if (`(authenticity_token = session[\"authenticity_token\"]) ! E_RANGE')";
"    parameters[\"__authenticity_token__\"] = authenticity_token;";
"  endif";
"  if (`valid(player = session[\"player\"]) ! E_RANGE')";
"    parameters[\"__player__\"] = [\"id\" -> player, \"name\" -> player.name];";
"  endif";
"";
"  headers = request:headers();";
"";
"  if (`headers[\"X-Requested-With\"] == \"XMLHttpRequest\" ! E_RANGE')";
"    parameters[\"__xhr__\"] = 1;";
"  else";
"    parameters[\"__xhr__\"] = 0;";
"  endif";
"";
"  if (`headers[\"X-Forwarded-Proto\"] == \"https\" ! E_RANGE')";
"    parameters[\"__ssl__\"] = 1;";
"    protocol = \"https\";";
"  else";
"    parameters[\"__ssl__\"] = 0;";
"    protocol = \"http\";";
"  endif";
"";
"  {?host = \"\", ?port = \"\"} = `headers[\"X-Forwarded-Host\"]:split(\":\") ! E_RANGE' || `headers[\"Host\"]:split(\":\") ! E_RANGE' || {};";
"  if (host && port)";
"    parameters[\"__url_base__\"] = tostr(protocol, \"://\", host, \":\", port);";
"  elseif (host)";
"    parameters[\"__url_base__\"] = tostr(protocol, \"://\", host);";
"  endif";
"";
"  if (`clients = headers[\"X-Forwarded-For\"] ! E_RANGE')";
"    parameters[\"__remote_client__\"] = clients:split(\",\")[$]:trim(\" \");";
"  elseif (`name = connection_name(connection) ! E_INVARG')";
"    parameters[\"__remote_client__\"] = name:split(\" \")[4]:trim(\",\");";
"  else";
"    parameters[\"__remote_client__\"] = \"\";";
"  endif";
"";
"  request = request:set_parameters(parameters);";
"";
"  return {request, response, chain};";
"";
"except ex (\"-*-parameters-is-too-long-*-\")";
"  request = request:set_exception(ex);";
"  return {request, response, {\"cleanup\", \"413\"}};";
"";
"except ex (ANY)";
"  request = request:set_exception(ex);";
"  return {request, response, {\"cleanup\", \"500\"}};";
"endtry";
"";
"chunk_length:194";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:BCDBB7AE54D48668254EAF60C8C7C5D4FA2FFD63";
"-=-=-mxyzptlk-=-=-";
.
#121:14
{request, response, chain} = args;
$private();
try
if (((!(request:method() in {"GET", "HEAD"})) && ((token = `task_local()["http"]["session"]["authenticity_token"] ! E_RANGE') != `request:parameters()["authenticity_token"] ! E_RANGE')) && (token != `request:headers()["X-Authenticity-Token"] ! E_RANGE'))
return {request, response, {"cleanup", "422"}};
else
return {request, response, chain};
endif
except ex (ANY)
request = request:set_exception(ex);
return {request, response, {"cleanup", "500"}};
endtry
return;
"{request, response, chain} = args;";
"";
"$private();";
"";
"/* Per 9.1.1 Safe Methods, RFC 2616, GET and HEAD are explicitly safe";
" * methods and do not require the authenticity token.  POST, PUT and";
" * DELETE are explicitly non-safe; however, assume that all methods";
" * that are not explicitly safe are non-safe.";
" */";
"";
"try";
"  if (!(request:method() in {\"GET\", \"HEAD\"}) &&";
"      (token = `task_local()[\"http\"][\"session\"][\"authenticity_token\"] ! E_RANGE') != `request:parameters()[\"authenticity_token\"] ! E_RANGE' &&";
"      token != `request:headers()[\"X-Authenticity-Token\"] ! E_RANGE')";
"    return {request, response, {\"cleanup\", \"422\"}};";
"  else";
"    return {request, response, chain};";
"  endif";
"";
"except ex (ANY)";
"  request = request:set_exception(ex);";
"  return {request, response, {\"cleanup\", \"500\"}};";
"endtry";
"";
"chunk_length:23";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:EB7CB40EF0C82FC88B927AA59E60BC0690A8A59B";
"-=-=-mxyzptlk-=-=-";
.
#121:15
$private();
{request, response, chain} = args;
if (handler = `request:handler() ! E_RANGE')
{object, verb} = handler;
if (respond_to(object, verb))
start = time();
player = `task_local()["http"]["session"]["player"] ! E_RANGE => $nothing';
try
object = create({object, $dialog.handler_proto}, object.owner, 1);
object.name = tostr("#<HTTP @ ", ctime(start), ">");
object.session = task_local()["http"]["session"];
object.request = request;
object.response = response;
this:_drop_perms_and_call_verb(object, verb, request, response);
task_local = task_local();
task_local["http"]["start"] = start;
task_local["http"]["session"] = object.session;
set_task_local(task_local);
finally
recycle(object);
endtry
chain = chain:setremove("404");
endif
endif
return {request, response, chain};
return;
"$private()";
"";
"{request, response, chain} = args";
"";
"if (handler = request:handler() !! E_RANGE)";
"  {object, verb} = handler";
"";
"  if (respond_to(object, verb))";
"    start = time()";
"";
"    /* Set player and then drop perms in a wrapper verb so that the";
"     * dropped perms don't make us lose the player change.";
"     */";
"    player = (task_local()[\"http\"][\"session\"][\"player\"] !! E_RANGE => $nothing)";
"";
"    try";
"      object = create({object, $dialog.handler_proto}, object.owner, 1)";
"      object.name = tostr(\"#<HTTP @ \", ctime(start), \">\")";
"      object.session = task_local()[\"http\"][\"session\"]";
"      object.request = request";
"      object.response = response";
"";
"      this:_drop_perms_and_call_verb(object, verb, request, response)";
"";
"      task_local = task_local()";
"      task_local[\"http\"][\"start\"] = start";
"      task_local[\"http\"][\"session\"] = object.session";
"      set_task_local(task_local)";
"    finally";
"      recycle(object)";
"    end";
"";
"    /* If successful, remove the 404 -- if 404 is present, it";
"     * should be the first, last and only 404.";
"     */";
"    chain = chain:setremove(\"404\")";
"  end";
"end";
"";
"return {request, response, chain}";
"";
"chunk_length:40";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:640B915671AF84A1097E0645172034ECFAE48DA3";
"-=-=-mxyzptlk-=-=-";
.
#121:16
{request, response, chain} = args;
$private();
try
data = `task_local()["http"]["session"] ! E_RANGE => []';
headers = `response:headers() ! E_RANGE => []';
session = ["data" -> data, "stamp" -> time()];
session = generate_json(session, "embedded-types");
hmac = string_hmac(session, this.key);
session = encode_base64(session);
hmac = encode_base64(hmac);
set_cookie = `headers["Set-Cookie"] ! E_RANGE => {}';
set_cookie = {@set_cookie, tostr(this.session_cookie_name, "=", hmac, "-", session, ";path=/;HttpOnly")};
headers["Set-Cookie"] = set_cookie:join(",");
package = $lookup("package");
headers["Server"] = tostr(package.identifier, "/", package.version);
headers["Date"] = this.utilities.time:rfc1123_time();
response = response:set_headers(headers);
try
for file in (file_list(tostr("tmp/", task_id())))
file_remove(tostr("tmp/", task_id(), "/", file));
endfor
file_rmdir(tostr("tmp/", task_id()));
except (E_FILE)
endtry
if (!is_clear_property(response, "body"))
body = response:body();
if ((t = typeof(body)) == LIST)
body = body:join("~0D~0A") + "~0D~0A";
elseif (t != STR)
body = tostr(body) + "~0D~0A";
endif
headers["Content-Type"] = `headers["Content-Type"] ! E_RANGE => "text/plain"';
headers["Content-Length"] = `headers["Content-Length"] ! E_RANGE => length(decode_binary(body, 1))';
response = response:set_headers(headers):set_body(body);
endif
return {request, response, chain};
except ex (ANY)
request = request:set_exception(ex);
return {request, response, {"500"}};
endtry
return;
"{request, response, chain} = args;";
"";
"$private();";
"";
"try";
"  data = `task_local()[\"http\"][\"session\"] ! E_RANGE => []';";
"";
"  headers = `response:headers() ! E_RANGE => []';";
"";
"  /* secure session */";
"  session = [\"data\" -> data, \"stamp\" -> time()];";
"  session = generate_json(session, \"embedded-types\");";
"  hmac = string_hmac(session, this.key);";
"  session = encode_base64(session);";
"  hmac = encode_base64(hmac);";
"";
"  /* store in cookie */";
"  set_cookie = `headers[\"Set-Cookie\"] ! E_RANGE => {}';";
"  set_cookie = {@set_cookie, tostr(this.session_cookie_name, \"=\", hmac, \"-\", session, \";path=/;HttpOnly\")};";
"  headers[\"Set-Cookie\"] = set_cookie:join(\",\");";
"";
"  /* add Server header */";
"  package = $lookup(\"package\");";
"  headers[\"Server\"] = tostr(package.identifier, \"/\", package.version);";
"";
"  /* add Date header */";
"  headers[\"Date\"] = this.utilities.time:rfc1123_time();";
"";
"  response = response:set_headers(headers);";
"";
"  /* clean temporary files */";
"  try";
"    for file in (file_list(tostr(\"tmp/\", task_id())))";
"      file_remove(tostr(\"tmp/\", task_id(), \"/\", file));";
"    endfor";
"    file_rmdir(tostr(\"tmp/\", task_id()));";
"  except (E_FILE)";
"  endtry";
"";
"  /* Deal with the body.  Processing can fail with E_QUOTA/E_INVARG";
"   * when concatenating strings and computing the length of the body.";
"   */";
"  if (!is_clear_property(response, \"body\"))";
"    body = response:body();";
"    /* if the body is not a string, make it a string */";
"    if ((t = typeof(body)) == LIST)";
"      body = body:join(\"~0D~0A\") + \"~0D~0A\";";
"    elseif (t != STR)";
"      body = tostr(body) + \"~0D~0A\";";
"    endif";
"";
"    /* ensure we have content type and content length */";
"    headers[\"Content-Type\"] = `headers[\"Content-Type\"] ! E_RANGE => \"text/plain\"';";
"    headers[\"Content-Length\"] = `headers[\"Content-Length\"] ! E_RANGE => length(decode_binary(body, 1))';";
"";
"    response = response:set_headers(headers):set_body(body);";
"  endif";
"";
"  return {request, response, chain};";
"";
"except ex (ANY)";
"  request = request:set_exception(ex);";
"  return {request, response, {\"500\"}};";
"endtry";
"";
"chunk_length:64";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:CEC4DCCC593C5D89F648554018E5D79871486D6F";
"-=-=-mxyzptlk-=-=-";
.
#121:17
$private();
{request, response, chain} = args;
try
code = toint(verb);
description = this.status_codes[code];
except (E_RANGE)
code = 500;
description = "Internal Server Error";
endtry
body = "<html><head><title>%m</title></head><body><h1>%m</h1>%c</body></html>";
if (`ex = request:exception() ! E_RANGE')
body = body:strsub(["%m" -> description, "%c" -> this:traceback(ex)]);
response = response:set_status(code):set_type("text/html"):set_length(length(body)):set_body(body);
else
body = body:strsub(["%m" -> description, "%c" -> ""]);
response = response:set_status(code):set_type("text/html"):set_length(length(body)):set_body(body);
endif
return {request, response, chain};
return;
"$private();";
"";
"{request, response, chain} = args;";
"";
"try";
"  code = toint(verb);";
"  description = this.status_codes[code];";
"except (E_RANGE)";
"  code = 500;";
"  description = \"Internal Server Error\";";
"endtry";
"";
"body = \"<html><head><title>%m</title></head><body><h1>%m</h1>%c</body></html>\";";
"";
"if (`ex = request:exception() ! E_RANGE')";
"  body = body:strsub([\"%m\" -> description, \"%c\" -> this:traceback(ex)]);";
"  response = response:set_status(code):set_type(\"text/html\"):set_length(length(body)):set_body(body);";
"else";
"  body = body:strsub([\"%m\" -> description, \"%c\" -> \"\"]);";
"  response = response:set_status(code):set_type(\"text/html\"):set_length(length(body)):set_body(body);";
"endif";
"";
"return {request, response, chain};";
"";
"chunk_length:23";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:0B52F53CCFC46208D5C43BF16F2BA2BEC5BFB623";
"-=-=-mxyzptlk-=-=-";
.
#121:18
{ex} = args;
$private();
{l, @r} = ex[4];
tb = "<ol>";
tb = tostr(tb, "<li><code>", l[4], ":", l[2], @(l[4] != l[1]) ? {" (this == ", toliteral(l[1]), ")"} | {}, ", line ", l[6], ": ", ex[2], "</code></li>");
for l in (r)
tb = tostr(tb, "<li><code>... called from ", l[4], ":", l[2], @(l[4] != l[1]) ? {" (this == ", toliteral(l[1]), ")"} | {}, ", line ", l[6], "</code></li>");
endfor
tb = tostr(tb, "<li><code>(End of traceback)</code></li>");
tb = tostr(tb, "</ol>");
return tb;
return;
"{ex} = args;";
"$private();";
"{l, @r} = ex[4];";
"tb = \"<ol>\";";
"tb = tostr(tb, \"<li><code>\", l[4], \":\", l[2], @l[4] != l[1] ? {\" (this == \", toliteral(l[1]), \")\"} | {}, \", line \", l[6], \": \", ex[2], \"</code></li>\");";
"for l in (r)";
"  tb = tostr(tb, \"<li><code>... called from \", l[4], \":\", l[2], @l[4] != l[1] ? {\" (this == \", toliteral(l[1]), \")\"} | {}, \", line \", l[6], \"</code></li>\");";
"endfor";
"tb = tostr(tb, \"<li><code>(End of traceback)</code></li>\");";
"tb = tostr(tb, \"</ol>\");";
"return tb;";
"";
"chunk_length:11";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:7D865CCCDBB718C6F8351AC45C64C5A9CF06D7FF";
"-=-=-mxyzptlk-=-=-";
.
#121:19
{verb, @args} = args;
$permit("wizard");
set_task_perms(caller_perms());
(verb in {"_do_request", "external", "session", "player", "route", "parameters", "protect_from_forgery", "serve", "cleanup", "404", "500"}) || raise(E_INVARG);
return this:(verb)(@args);
return;
"{verb, @args} = args;";
"$permit(\"wizard\");";
"set_task_perms(caller_perms());";
"verb in {\"_do_request\", \"external\", \"session\", \"player\", \"route\", \"parameters\", \"protect_from_forgery\", \"serve\", \"cleanup\", \"404\", \"500\"} || raise(E_INVARG);";
"return this:(verb)(@args);";
"";
"chunk_length:5";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:CD7E4970FACB9D0130ACEEDDE6A3CD618FBBE8E6";
"-=-=-mxyzptlk-=-=-";
.
#121:20
$private();
{object, verb, request, response} = args;
set_task_perms(player);
try
object:(verb)(request:parameters());
return {request, response};
except (E_ARGS)
{request, response} = object:(verb)(request, response);
return {request, response};
endtry
return;
"$private()";
"";
"{object, verb, request, response} = args";
"";
"set_task_perms(player)";
"";
"/* For now, attempt both the new and old styles";
" * of delivery.  Assumes the verbs use scattering";
" * to distribute `args'.";
" */";
"try";
"  object:(verb)(request:parameters())";
"  return {request, response}";
"except (E_ARGS)";
"  {request, response} =  object:(verb)(request, response)";
"  return {request, response}";
"end";
"";
"chunk_length:17";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:6EE9652577C963B12456D95A504992FE72079D54";
"-=-=-mxyzptlk-=-=-";
.
#121:21
$private();
{request, response, chain} = args;
set_task_perms($nothing);
try
while (chain)
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
{top, @chain} = chain;
if (typeof(top) == LIST)
{object, verb} = top;
else
object = this;
verb = top;
endif
if (!((object == this) || (object in this.contents)))
raise(E_PERM, tostr("Permission denied:  couldn't chain to ", object, ":", verb));
elseif (!respond_to(object, verb))
raise(E_VERBNF, tostr("Verb not found:  couldn't chain to ", object, ":", verb));
else
{request, response, chain} = object:(verb)(request, response, chain);
endif
endwhile
except ex (ANY)
request = request:set_exception(ex);
if ("cleanup" in chain)
{request, response, chain} = this:cleanup(request, response, chain);
endif
{request, response, chain} = this:("500")(request, response, chain);
endtry
return {request, response};
return;
"$private();";
"";
"{request, response, chain} = args;";
"";
"/* Drop perms here as a precaution.  Any special (wiz) verbs called";
" * below won't see themselves as having been called with special (wiz)";
" * permissions.";
" */";
"set_task_perms($nothing);";
"";
"try";
"";
"  while (chain)";
"    ticks_left() < 10000 || seconds_left() < 2 && suspend(0);";
"";
"    {top, @chain} = chain;";
"";
"    if (typeof(top) == LIST)";
"      {object, verb} = top;";
"    else";
"      object = this;";
"      verb = top;";
"    endif";
"";
"    /* For boots and suspenders, make sure the object on which the";
"     * verb is being invoked is on this or in the contents of this.";
"     * And make sure it's callable.";
"     */";
"    if (!(object == this || object in this.contents))";
"      raise(E_PERM, tostr(\"Permission denied:  couldn't chain to \", object, \":\", verb));";
"    elseif (!respond_to(object, verb))";
"      raise(E_VERBNF, tostr(\"Verb not found:  couldn't chain to \", object, \":\", verb));";
"    else";
"      {request, response, chain} = object:(verb)(request, response, chain);";
"    endif";
"  endwhile";
"";
"/* Try to be smart about failure.  No matter what's left in the chain,";
" * only do the \"cleanup\" and \"500\" steps -- if we fail while doing";
" * them, _don't_ fail again.";
" */";
"except ex (ANY)";
"  request = request:set_exception(ex);";
"";
"  if (\"cleanup\" in chain)";
"    {request, response, chain} = this:cleanup(request, response, chain);";
"  endif";
"";
"  {request, response, chain} = this:(\"500\")(request, response, chain);";
"endtry";
"";
"return {request, response};";
"";
"chunk_length:52";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:E06C52C1D9541FAA362F8ABEFEE46817BCAC4768";
"-=-=-mxyzptlk-=-=-";
.
#122:0
property = verb;
return this.(property);
return;
"property = verb;";
"return this.(property);";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:DE435FF968D67DDC75EFF17144A65E2A61CAD871";
"-=-=-mxyzptlk-=-=-";
.
#122:1
{value} = args;
property = verb[5..$];
this.(property) = value;
return this;
return;
"{value} = args;";
"property = verb[5..$];";
"this.(property) = value;";
"return this;";
"";
"chunk_length:4";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:53C593653EFB12DF7A88C698495B2B8D25084617";
"-=-=-mxyzptlk-=-=-";
.
#122:2
cookies = [];
cookie = `this.headers["cookie"] ! ANY => ""';
for cookie in (cookie:split(";"))
i = index(cookie, "=");
key = cookie[1..i - 1]:trim();
value = cookie[i + 1..$]:trim();
cookies[key] = value;
endfor
return cookies;
return;
"cookies = [];";
"cookie = `this.headers[\"cookie\"] ! ANY => \"\"';";
"for cookie in (cookie:split(\";\"))";
"  i = index(cookie, \"=\");";
"  key = cookie[1..i - 1]:trim();";
"  value = cookie[i + 1..$]:trim();";
"  cookies[key] = value;";
"endfor";
"return cookies;";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:D76FDFB46B9B95363AE174571AE09C2248412A19";
"-=-=-mxyzptlk-=-=-";
.
#122:3
i = this.uri:index("?");
return i ? this.uri[1..i - 1] | this.uri;
return;
"i = this.uri:index(\"?\");";
"return i ? this.uri[1..i - 1] | this.uri;";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:9215FEDB92107E86EFFE7CB971B3B1FF835E97CF";
"-=-=-mxyzptlk-=-=-";
.
#122:4
i = this.uri:index("?");
return i ? this.uri[i + 1..$] | "";
return;
"i = this.uri:index(\"?\");";
"return i ? this.uri[i + 1..$] | \"\";";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:421B26D75F80E176C56505F7D6046F5E7071D9B6";
"-=-=-mxyzptlk-=-=-";
.
#122:5
{?full = 0} = args;
{type, ?parameters = ""} = this.headers["Content-Type"]:split(";");
if (full)
temp = [];
for parameter in (parameters:split(","))
{k, v} = parameter:split("=");
temp[k:trim()] = v:trim();
endfor
return {type:trim(), temp};
else
return type:trim();
endif
return;
"{?full = 0} = args;";
"";
"{type, ?parameters = \"\"} = this.headers[\"Content-Type\"]:split(\";\");";
"";
"if (full)";
"  temp = [];";
"  for parameter in (parameters:split(\",\"))";
"    {k, v} = parameter:split(\"=\");";
"    temp[k:trim()] = v:trim();";
"  endfor";
"  return {type:trim(), temp};";
"else";
"  return type:trim();";
"endif";
"";
"chunk_length:14";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:5DCC09F7B82DB57F280018DB38F0AB98980165D6";
"-=-=-mxyzptlk-=-=-";
.
#122:6
{type, ?parameters = []} = args;
if (parameters)
temp = {};
for v, k in (parameters)
temp = {@temp, tostr(k, "=", v)};
endfor
this.headers["Content-Type"] = tostr(type, "; ", temp:join());
else
this.headers["Content-Type"] = type;
endif
return this;
return;
"{type, ?parameters = []} = args;";
"";
"if (parameters)";
"  temp = {};";
"  for v, k in (parameters)";
"    temp = {@temp, tostr(k, \"=\", v)};";
"  endfor";
"  this.headers[\"Content-Type\"] = tostr(type, \"; \", temp:join());";
"else";
"  this.headers[\"Content-Type\"] = type;";
"endif";
"";
"return this;";
"";
"chunk_length:13";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:6909B5C41C68B53EB9C0D643BCFAB8ADA30975DD";
"-=-=-mxyzptlk-=-=-";
.
#122:7
args && raise(E_ARGS);
return this.headers["Content-Length"];
return;
"args && raise(E_ARGS);";
"";
"return this.headers[\"Content-Length\"];";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:6B9D45DE29C3416F9244F5293CD9E0DA18FB8E45";
"-=-=-mxyzptlk-=-=-";
.
#122:8
{length} = args;
this.headers["Content-Length"] = length;
return this;
return;
"{length} = args;";
"";
"this.headers[\"Content-Length\"] = length;";
"";
"return this;";
"";
"chunk_length:5";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:D12550F8D598B99DD1D5947056326B966D997322";
"-=-=-mxyzptlk-=-=-";
.
#123:0
property = verb;
return this.(property);
return;
"property = verb;";
"return this.(property);";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:DE435FF968D67DDC75EFF17144A65E2A61CAD871";
"-=-=-mxyzptlk-=-=-";
.
#123:1
{value} = args;
property = verb[5..$];
this.(property) = value;
return this;
return;
"{value} = args;";
"property = verb[5..$];";
"this.(property) = value;";
"return this;";
"";
"chunk_length:4";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:53C593653EFB12DF7A88C698495B2B8D25084617";
"-=-=-mxyzptlk-=-=-";
.
#123:2
{?full = 0} = args;
{type, ?parameters = ""} = this.headers["Content-Type"]:split(";");
if (full)
temp = [];
for parameter in (parameters:split(","))
{k, v} = parameter:split("=");
temp[k:trim()] = v:trim();
endfor
return {type:trim(), temp};
else
return type:trim();
endif
return;
"{?full = 0} = args;";
"";
"{type, ?parameters = \"\"} = this.headers[\"Content-Type\"]:split(\";\");";
"";
"if (full)";
"  temp = [];";
"  for parameter in (parameters:split(\",\"))";
"    {k, v} = parameter:split(\"=\");";
"    temp[k:trim()] = v:trim();";
"  endfor";
"  return {type:trim(), temp};";
"else";
"  return type:trim();";
"endif";
"";
"chunk_length:14";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:5DCC09F7B82DB57F280018DB38F0AB98980165D6";
"-=-=-mxyzptlk-=-=-";
.
#123:3
{type, ?parameters = []} = args;
if (parameters)
temp = {};
for v, k in (parameters)
temp = {@temp, tostr(k, "=", v)};
endfor
this.headers["Content-Type"] = tostr(type, "; ", temp:join());
else
this.headers["Content-Type"] = type;
endif
return this;
return;
"{type, ?parameters = []} = args;";
"";
"if (parameters)";
"  temp = {};";
"  for v, k in (parameters)";
"    temp = {@temp, tostr(k, \"=\", v)};";
"  endfor";
"  this.headers[\"Content-Type\"] = tostr(type, \"; \", temp:join());";
"else";
"  this.headers[\"Content-Type\"] = type;";
"endif";
"";
"return this;";
"";
"chunk_length:13";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:6909B5C41C68B53EB9C0D643BCFAB8ADA30975DD";
"-=-=-mxyzptlk-=-=-";
.
#123:4
args && raise(E_ARGS);
fields = ["length" -> "Content-Length", "location" -> "Location"];
return this.headers[fields[verb]];
return;
"args && raise(E_ARGS);";
"";
"fields = [\"length\" -> \"Content-Length\", \"location\" -> \"Location\"];";
"";
"return this.headers[fields[verb]];";
"";
"chunk_length:5";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:FE66217513FEA4C464F462910F36C00AE0BF4F4D";
"-=-=-mxyzptlk-=-=-";
.
#123:5
{value} = args;
fields = ["set_length" -> "Content-Length", "set_location" -> "Location"];
this.headers[fields[verb]] = value;
return this;
return;
"{value} = args;";
"";
"fields = [\"set_length\" -> \"Content-Length\", \"set_location\" -> \"Location\"];";
"";
"this.headers[fields[verb]] = value;";
"";
"return this;";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:A694D806221EB41BFC94352365127F1133728337";
"-=-=-mxyzptlk-=-=-";
.
#124:0
return {};
return;
"/* A route can match on anything in a request -- common criteria are";
" * HTTP method and URI.  A matched route returns the object/verb that";
" * will handle the request, as well as parameters that will be added";
" * to the other parameters in the request.";
" *";
" * In:";
" *  MAP request";
" * Out:";
" *  OBJ receiver";
" *  STR verb";
" *  MAP parameters";
" */";
"return {};";
"";
"chunk_length:13";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:4BD935C3BDE051C54B2484EC2D8E80EEFD6205EC";
"-=-=-mxyzptlk-=-=-";
.
#125:0
$private();
return this.request;
return;
"$private()";
"";
"return this.request // limited, secure access to the request";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:4F1E66619CCEB5BDCFEF503B0E63BF7FA01C3C3F";
"-=-=-mxyzptlk-=-=-";
.
#125:1
$private();
return this.response;
return;
"$private()";
"";
"return this.response // limited, secure access to the response";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:92CB24D6887D08B8C6AB2F4E902E51AAB6D71611";
"-=-=-mxyzptlk-=-=-";
.
#125:2
$private();
this._ensure_once && raise(E_INVARG, "Multiple calls to helpers");
this._ensure_once = this._ensure_once + 1;
return;
"$private()";
"";
"this._ensure_once && raise(E_INVARG, \"Multiple calls to helpers\")";
"";
"this._ensure_once += 1";
"";
"chunk_length:5";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:A968E1606D3F823583B0D8C312BFA8DB598F28C5";
"-=-=-mxyzptlk-=-=-";
.
#125:3
$protected();
{body, ?type = "text/html", ?code = 200} = args;
this:_ensure_once();
this:_response():set_status(code):set_type(type):set_body(body);
return;
"$protected()";
"";
"{body, type = \"text/html\", code = 200} = args";
"";
"this:_ensure_once()";
"";
"this:_response():set_status(code):set_type(type):set_body(body)";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:D792358C3E37FA977E3256F0B474ACC5DB67E188";
"-=-=-mxyzptlk-=-=-";
.
#125:4
$protected();
{?code = 400} = args;
this:_ensure_once();
this:_response():set_status(code);
return;
"$protected()";
"";
"{code = 400} = args";
"";
"this:_ensure_once()";
"";
"this:_response():set_status(code)";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:E1631C1495C0546D523F4DC046B5295350CB828A";
"-=-=-mxyzptlk-=-=-";
.
#125:5
$protected();
{?code = 403} = args;
this:_ensure_once();
this:_response():set_status(code);
return;
"$protected()";
"";
"{code = 403} = args";
"";
"this:_ensure_once()";
"";
"this:_response():set_status(code)";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:A16D781CDF9BEB2854103FC982EA1CB7288D316A";
"-=-=-mxyzptlk-=-=-";
.
#125:6
$protected();
{body, ?type = "text/html", ?code = 404} = args;
this:_ensure_once();
this:_response():set_status(code):set_type(type):set_body(body);
return;
"$protected()";
"";
"{body, type = \"text/html\", code = 404} = args";
"";
"this:_ensure_once()";
"";
"this:_response():set_status(code):set_type(type):set_body(body)";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:B2ED5773046177A2BB8BB0BA9BD1B39B7CC92FBF";
"-=-=-mxyzptlk-=-=-";
.
#125:7
$protected();
{?code = 406} = args;
this:_ensure_once();
this:_response():set_status(code);
return;
"$protected()";
"";
"{code = 406} = args";
"";
"this:_ensure_once()";
"";
"this:_response():set_status(code)";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:8B4568336842137F438E3C2E5D39DC4742320304";
"-=-=-mxyzptlk-=-=-";
.
#125:8
$protected();
{?code = 413} = args;
this:_ensure_once();
this:_response():set_status(code);
return;
"$protected()";
"";
"{code = 413} = args";
"";
"this:_ensure_once()";
"";
"this:_response():set_status(code)";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:EC1EBE95F675141B59084E1FAE2F7C12E00E45DC";
"-=-=-mxyzptlk-=-=-";
.
#125:9
$protected();
{body, ?type = "text/html", ?code = 500} = args;
this:_ensure_once();
this:_response():set_status(code):set_type(type):set_body(body);
return;
"$protected()";
"";
"{body, type = \"text/html\", code = 500} = args";
"";
"this:_ensure_once()";
"";
"this:_response():set_status(code):set_type(type):set_body(body)";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:46A21BD2A5E94AD17715E0AB088F4EAF8CF3E6B2";
"-=-=-mxyzptlk-=-=-";
.
#125:10
$protected();
{location, ?code = 302} = args;
this:_ensure_once();
this:_response():set_status(code):set_location(location);
return;
"$protected()";
"";
"{location, code = 302} = args";
"";
"this:_ensure_once()";
"";
"this:_response():set_status(code):set_location(location)";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:13782343138F69F3D887D7035024D9DB8B95495B";
"-=-=-mxyzptlk-=-=-";
.
#126:0
$permit("owner", "wizard");
{player} = args;
(valid(player) || (player == $nothing)) || raise(E_INVARG, tostr("Invalid argument:  ", player), player);
(valid(player) && (player.wizard || player.programmer)) && raise(E_INVARG, tostr("Invalid argument:  ", player), player);
if (valid(player))
valid = 0;
for prototype in (this.prototypes)
if (isa(player, prototype))
valid = 1;
break;
endif
endfor
else
valid = 1;
endif
(!valid) && raise(E_PERM);
set_task_local(task_local():merge(["http" -> ["session" -> ["player" -> player]]]));
return;
"$permit(\"owner\", \"wizard\")";
"";
"{player} = args";
"";
"(valid(player) || player == $nothing) || raise(E_INVARG, tostr(\"Invalid argument:  \", player), player)";
"valid(player) && (player.wizard || player.programmer) && raise(E_INVARG, tostr(\"Invalid argument:  \", player), player)";
"";
"if (valid(player))";
"  valid = 0";
"  for prototype in (this.prototypes)";
"    if (isa(player, prototype))";
"      valid = 1";
"      break";
"    endif";
"  endfor";
"else";
"  valid = 1";
"endif";
"";
"!valid && raise(E_PERM)";
"";
"set_task_local(task_local():merge([\"http\" -> [\"session\" -> [\"player\" -> player]]]))";
"";
"chunk_length:22";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:A36EF059D8B0DA28AB4D1714BEF3F4C4E9D39F0C";
"-=-=-mxyzptlk-=-=-";
.
#126:1
$permit("owner", "wizard");
return task_local()["http"]["session"]["player"];
return;
"$permit(\"owner\", \"wizard\")";
"";
"return task_local()[\"http\"][\"session\"][\"player\"]";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:E63E4A886C997A9E1D2AAE6232B4FBB55F3E291D";
"-=-=-mxyzptlk-=-=-";
.
#127:0
$restrict_to_caller(this.location);
{request} = args;
if (request:uri() == "/")
return {this, "it_works!", []};
else
return {};
endif
return;
"$restrict_to_caller(this.location)";
"";
"{request} = args";
"";
"if (request:uri() == \"/\")";
"  return {this, \"it_works!\", []}";
"else";
"  return {}";
"endif";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:DA1A4B86E074DF149917F0CC4D6F67EACF452994";
"-=-=-mxyzptlk-=-=-";
.
#127:1
_2095175818 = this;
$restrict_to_caller(parent(this).location);
{parameters} = args;
_2095175818:ok({"<html>", "<head>", "<title>Welcome to Stunt!</title>", "</head>", "<body>", "<h1>Welcome to Stunt!</h1>", "<p>It works!  For information about Stunt, check out <a href=\"http://stunt.io/\">http://stunt.io/</a>.</p>", ("<!-- " + this.name) + " -->", "</body>", "</html>"});
return;
"from this use ok";
"";
"$restrict_to_caller(parent(this).location)";
"";
"{parameters} = args";
"";
"ok({";
"  '<html>',";
"    '<head>',";
"      '<title>Welcome to Stunt!</title>',";
"    '</head>',";
"    '<body>',";
"      '<h1>Welcome to Stunt!</h1>',";
"      '<p>It works!  For information about Stunt, check out <a href=\"http://stunt.io/\">http://stunt.io/</a>.</p>',";
"      '<!-- ' + this.name + ' -->',";
"    '</body>',";
"  '</html>'";
"})";
"";
"chunk_length:18";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:A75C1E6770AAB09E9B3F05DD1DF5C1A5A38B3B4D";
"-=-=-mxyzptlk-=-=-";
.
#130:0
$restrict_to_caller($dialog.server, "route");
{request} = args;
uri = request:uri();
uri = uri:strsub(["%20" -> " "]);
if (index(uri, this.database_server.prefix) == 1)
return {};
endif
if (uri[$] == "/")
uri = uri + "index.html";
endif
file = "public" + uri;
if (`stat = file_stat(file) ! E_FILE, E_INVARG, E_PERM' && (stat[2] == "reg"))
return {this, "get", ["__sendfile__" -> file]};
endif
return {};
return;
"$restrict_to_caller($dialog.server, \"route\");";
"";
"{request} = args;";
"";
"uri = request:uri();";
"";
"/* replace common URI escapes */";
"uri = uri:strsub([\"%20\" ->\" \"]);";
"";
"/* avoid URIs that start with the database server path prefix */";
"if (index(uri, this.database_server.prefix) == 1)";
"  return {};";
"endif";
"";
"/* handle the common case of directory access */";
"if (uri[$] == \"/\")";
"  uri = uri + \"index.html\";";
"endif";
"";
"file = \"public\" + uri;";
"";
"if (`(stat = file_stat(file)) ! E_FILE, E_INVARG, E_PERM' && stat[2] == \"reg\")";
"  return {this, \"get\", [\"__sendfile__\" -> file]};";
"endif";
"";
"return {};";
"";
"chunk_length:26";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:082A06B81AAD5EEFD7005AA6AF98C1C3D2C07939";
"-=-=-mxyzptlk-=-=-";
.
#130:1
$restrict_to_caller($dialog.server, "_drop_perms_and_call_verb", "serve");
{request, response} = args;
try
file = request:parameters()["__sendfile__"];
headers = `response:headers() ! E_RANGE => []';
headers["Last-Modified"] = last_modified = $core.utility.time:rfc1123_time(file_stat(file)[7]);
response = response:set_headers(headers);
if (`request:headers()["If-Modified-Since"] ! E_RANGE' == last_modified)
response = response:set_status(304);
return {request, response};
endif
data = "";
size = file_size(file);
fh = -1;
try
fh = file_open(file, "r-bn");
while ((pos = file_tell(fh)) != size)
chunk = file_read(fh, size - pos);
data = data ? data + chunk | chunk;
endwhile
finally
(fh > -1) && file_close(fh);
endtry
type = "application/octet-stream";
ext = (length(parts = file:split(".")) > 1) ? parts[$] | "";
if ("txt" == ext)
type = "text/plain";
elseif (("html" == ext) || ("htm" == ext))
type = "text/html";
elseif ("jpeg" == ext)
type = "image/jpeg";
elseif ("jpg" == ext)
type = "image/jpeg";
elseif ("png" == ext)
type = "image/png";
elseif ("gif" == ext)
type = "image/gif";
elseif ("css" == ext)
type = "text/css";
elseif ("less" == ext)
type = "text/css";
elseif ("js" == ext)
type = "text/javascript";
elseif ("json" == ext)
type = "application/json";
elseif ("xml" == ext)
type = "application/xml";
elseif ("swf" == ext)
type = "application/x-shockwave-flash";
elseif (("moo" == ext) || ("moocode" == ext))
type = "application/x-moocode";
else
try
{code, out, ERR} = exec({"identify", "-format", "%m", "files/" + file});
if (!code)
if ("JPEG" == (out = decode_binary(out)[1]))
type = "image/jpeg";
elseif ("PNG" == out)
type = "image/png";
elseif ("GIF" == out)
type = "image/gif";
endif
endif
except (E_INVARG, E_EXEC)
endtry
endif
server_log(tostr("HTTP: serving file: ", file));
response = response:set_status(200):set_body(data):set_type(type):set_length(size);
return {request, response};
except (E_FILE)
endtry
return {request, response};
return;
"$restrict_to_caller($dialog.server, \"_drop_perms_and_call_verb\", \"serve\");";
"";
"{request, response} = args;";
"";
"try";
"  /* \"__sendfile__\" is the file to send */";
"  file = request:parameters()[\"__sendfile__\"];";
"";
"  /* set Last-Modified header */";
"  headers = `response:headers() ! E_RANGE => []';";
"  headers[\"Last-Modified\"] = last_modified = $core.utility.time:rfc1123_time(file_stat(file)[7]);";
"  response = response:set_headers(headers);";
"";
"  /* don't serve the file if it hasn't changed */";
"  if (`request:headers()[\"If-Modified-Since\"] ! E_RANGE' == last_modified)";
"    response = response:set_status(304);";
"    return {request, response};";
"  endif";
"";
"  /* read data */";
"  data = \"\";";
"  size = file_size(file);";
"  fh = -1;";
"";
"  try";
"    fh = file_open(file, \"r-bn\");";
"    while ((pos = file_tell(fh)) != size)";
"      chunk = file_read(fh, size - pos);";
"      data = data ? data + chunk | chunk;";
"    endwhile";
"  finally";
"    (fh > -1) && file_close(fh);";
"  endtry";
"";
"  /* determine the type */";
"  type = \"application/octet-stream\";";
"";
"  ext = length(parts = file:split(\".\")) > 1 ? parts[$] | \"\";";
"";
"  if (\"txt\" == ext)";
"    type = \"text/plain\";";
"  elseif (\"html\" == ext || \"htm\" == ext)";
"    type = \"text/html\";";
"  elseif (\"jpeg\" == ext)";
"    type = \"image/jpeg\";";
"  elseif (\"jpg\" == ext)";
"    type = \"image/jpeg\";";
"  elseif (\"png\" == ext)";
"    type = \"image/png\";";
"  elseif (\"gif\" == ext)";
"    type = \"image/gif\";";
"  elseif (\"css\" == ext)";
"    type = \"text/css\";";
"  elseif (\"less\" == ext)";
"    type = \"text/css\";";
"  elseif (\"js\" == ext)";
"    type = \"text/javascript\";";
"  elseif (\"json\" == ext)";
"    type = \"application/json\";";
"  elseif (\"xml\" == ext)";
"    type = \"application/xml\";";
"  elseif (\"swf\" == ext)";
"    type = \"application/x-shockwave-flash\";";
"  elseif (\"moo\" == ext || \"moocode\" == ext)";
"    type = \"application/x-moocode\";";
"  else";
"    /* last ditch effort, try to exec `identify' */";
"    try";
"      {code, out, err} = exec({\"identify\", \"-format\", \"%m\", \"files/\" + file});";
"      if (!code)";
"        if (\"JPEG\" == (out = decode_binary(out)[1]))";
"          type = \"image/jpeg\";";
"        elseif (\"PNG\" == out)";
"          type = \"image/png\";";
"        elseif (\"GIF\" == out)";
"          type = \"image/gif\";";
"        endif";
"      endif";
"    except (E_INVARG, E_EXEC)";
"    endtry";
"  endif";
"";
"  server_log(tostr(\"HTTP: serving file: \", file));";
"";
"  response = response:set_status(200):set_body(data):set_type(type):set_length(size);";
"";
"  return {request, response};";
"";
"except (E_FILE)";
"endtry";
"";
"return {request, response};";
"";
"chunk_length:92";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:D94F0FEFE6BFCA8C80AD9C3266AD37CDEFFF3C0F";
"-=-=-mxyzptlk-=-=-";
.
#131:0
$restrict_to_caller($dialog.server, "route");
{request} = args;
uri = request:uri();
if (uri:index(this.prefix) == 1)
if (request:method() == "get")
return {this, "get", []};
elseif (request:method() == "put")
return {this, "put", []};
elseif (request:method() == "post")
return {this, "post", []};
elseif (request:method() == "delete")
return {this, "delete", []};
endif
endif
return {};
return;
"$restrict_to_caller($dialog.server, \"route\");";
"";
"{request} = args;";
"";
"uri = request:uri();";
"";
"if (uri:index(this.prefix) == 1)";
"  if (request:method() == \"get\")";
"    return {this, \"get\", []};";
"  elseif (request:method() == \"put\")";
"    return {this, \"put\", []};";
"  elseif (request:method() == \"post\")";
"    return {this, \"post\", []};";
"  elseif (request:method() == \"delete\")";
"    return {this, \"delete\", []};";
"  endif";
"endif";
"";
"return {};";
"";
"chunk_length:19";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:ABEC08B01F6B2837A28D0D32941D0D9489DDDC3D";
"-=-=-mxyzptlk-=-=-";
.
#131:1
$private();
{uri} = args;
if (uri:index(this.prefix) == 1)
if ((r = uri:triml(this.prefix):split("/")):length() < 5)
{?a = "", ?b = "", ?c = "", ?d = ""} = r;
return {a, b, c, d};
endif
endif
return 0;
return;
"$private();";
"";
"{uri} = args;";
"";
"if (uri:index(this.prefix) == 1)";
"  if ((r = uri:triml(this.prefix):split(\"/\")):length() < 5)";
"    {?a = \"\", ?b = \"\", ?c = \"\", ?d = \"\"} = r;";
"    return {a, b, c, d};";
"  endif";
"endif";
"";
"return 0;";
"";
"chunk_length:12";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:E259C05BD4BBEDFDC1B55C7A439745982902F45E";
"-=-=-mxyzptlk-=-=-";
.
#131:2
{o} = args;
if (match(o, "^#?-?[0-9]+$"))
return toobj(o);
else
return $nothing;
endif
return;
"{o} = args;";
"if (match(o, \"^#?-?[0-9]+$\"))";
"  return toobj(o);";
"else";
"  return $nothing;";
"endif";
"";
"chunk_length:6";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:0FA2F2DA5428FB786F77073FE5616CAA57888902";
"-=-=-mxyzptlk-=-=-";
.
#131:3
$restrict_to_caller($dialog.server, "_drop_perms_and_call_verb", "serve");
set_task_perms(caller_perms());
{request, response} = args;
uri = request:uri();
if (r = this:_match_uri(uri))
{a1, a2, b1, b2} = r;
if ((((!a1) && (!a2)) && (!b1)) && (!b2))
response = response:set_status(200);
response = response:set_type("application/json");
response = response:set_body("{}");
elseif (((("objects" == a1) && (!a2)) && (!b1)) && (!b2))
response = response:set_status(200);
response = response:set_type("application/json");
response = response:set_body("{}");
elseif (((("objects" == a1) && a2) && (!b1)) && (!b2))
o = this:_toobj(a2);
o = $shapes:read_object(o);
status = o["Meta"]["status"];
status = (status == "invalid") ? 404 | ((status == "denied") ? 403 | 200);
response = response:set_status(status);
response = response:set_type("application/json");
response = response:set_body(generate_json(o, "embedded-types"):strsub("~", "~7E"));
else
response = response:set_status(404);
response = response:set_type("application/json");
response = response:set_body("{}");
endif
else
response = response:set_status(404);
response = response:set_type("application/json");
response = response:set_body("{}");
endif
return {request, response};
return;
"$restrict_to_caller($dialog.server, \"_drop_perms_and_call_verb\", \"serve\");";
"";
"set_task_perms(caller_perms());";
"";
"{request, response} = args;";
"";
"uri = request:uri();";
"";
"if (r = this:_match_uri(uri))";
"  {a1, a2, b1, b2} = r;";
"  if (!a1 && !a2 && !b1 && !b2)";
"    response = response:set_status(200);";
"    response = response:set_type(\"application/json\");";
"    response = response:set_body(\"{}\");";
"  elseif (\"objects\" == a1 && !a2 && !b1 && !b2)";
"    response = response:set_status(200);";
"    response = response:set_type(\"application/json\");";
"    response = response:set_body(\"{}\");";
"  elseif (\"objects\" == a1 && a2 && !b1 && !b2)";
"    o = this:_toobj(a2);";
"    o = $shapes:read_object(o);";
"    status = o[\"Meta\"][\"status\"];";
"    status = (status == \"invalid\" ? 404 | (status == \"denied\" ? 403 | 200));";
"    response = response:set_status(status);";
"    response = response:set_type(\"application/json\");";
"    response = response:set_body(generate_json(o, \"embedded-types\"):strsub(\"~\", \"~7E\"));";
"  /*";
"  elseif (\"objects\" == a1 && a2 && \"attributes\" == b1 && b2)";
"    response = response:set_status(200);";
"    response = response:set_type(\"application/json\");";
"    response = response:set_body(generate_json($shapes:read_attribute(this:_toobj(a2), b2), \"embedded-types\"));";
"  elseif (\"objects\" == a1 && a2 && \"properties\" == b1 && b2)";
"    response = response:set_status(200);";
"    response = response:set_type(\"application/json\");";
"    response = response:set_body(generate_json($shapes:read_property(this:_toobj(a2), toint(b2)), \"embedded-types\"));";
"  elseif (\"objects\" == a1 && a2 && \"verbs\" == b1 && b2)";
"    response = response:set_status(200);";
"    response = response:set_type(\"application/json\");";
"    response = response:set_body(generate_json($shapes:read_verb(this:_toobj(a2), toint(b2)), \"embedded-types\"));";
"  */";
"  else";
"    response = response:set_status(404);";
"    response = response:set_type(\"application/json\");";
"    response = response:set_body(\"{}\");";
"  endif";
"else";
"  response = response:set_status(404);";
"  response = response:set_type(\"application/json\");";
"  response = response:set_body(\"{}\");";
"endif";
"";
"return {request, response};";
"";
"chunk_length:52";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:40DF01BD0DCE5EABC26CFD68538904B0F49DD264";
"-=-=-mxyzptlk-=-=-";
.
#131:4
$restrict_to_caller($dialog.server, "_drop_perms_and_call_verb", "serve");
set_task_perms(caller_perms());
{request, response} = args;
if (((`request:type() ! E_RANGE' != "application/json") || (`body = request:body() ! E_RANGE' == E_RANGE)) || (`body = parse_json(body, "embedded-types") ! E_INVARG' == E_INVARG))
response = response:set_status(415);
return {request, response};
endif
uri = request:uri();
if (r = this:_match_uri(uri))
{type, id, x1, x2} = r;
if (((("objects" == type) && id) && (!x1)) && (!x2))
if (!valid(o = this:_toobj(id)))
response = response:set_status(404);
return {request, response};
elseif (!$shapes:controls(player, o))
response = response:set_status(403);
return {request, response};
endif
body = $shapes:write_object(o, body);
body = generate_json(body, "embedded-types");
response = response:set_status(200):set_type("application/json"):set_body(body);
return {request, response};
endif
endif
response = response:set_status(404);
return {request, response};
return;
"$restrict_to_caller($dialog.server, \"_drop_perms_and_call_verb\", \"serve\");";
"";
"set_task_perms(caller_perms());";
"";
"{request, response} = args;";
"";
"if (`request:type() ! E_RANGE' != \"application/json\" ||";
"    `(body = request:body()) ! E_RANGE' == E_RANGE ||";
"    `(body = parse_json(body, \"embedded-types\")) ! E_INVARG' == E_INVARG)";
"  response = response:set_status(415);";
"  return {request, response};";
"endif";
"";
"uri = request:uri();";
"";
"if (r = this:_match_uri(uri))";
"  {type, id, x1, x2} = r;";
"  if (\"objects\" == type && id && !x1 && !x2)";
"    if (!valid(o = this:_toobj(id)))";
"      response = response:set_status(404);";
"      return {request, response};";
"    elseif (!$shapes:controls(player, o))";
"      response = response:set_status(403);";
"      return {request, response};";
"    endif";
"    body = $shapes:write_object(o, body);";
"    body = generate_json(body, \"embedded-types\");";
"    response = response:set_status(200):set_type(\"application/json\"):set_body(body);";
"    return {request, response};";
"  endif";
"endif";
"";
"response = response:set_status(404);";
"return {request, response};";
"";
"chunk_length:34";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:5FC18E0AD92A5A2A1C47D188D6EDB39CBFBFCDF0";
"-=-=-mxyzptlk-=-=-";
.
#131:5
$restrict_to_caller($dialog.server, "_drop_perms_and_call_verb", "serve");
set_task_perms(caller_perms());
{request, response} = args;
if (((`request:type() ! E_RANGE' != "application/json") || (`body = request:body() ! E_RANGE' == E_RANGE)) || (`body = parse_json(body, "embedded-types") ! E_INVARG' == E_INVARG))
response = response:set_status(415);
return {request, response};
endif
uri = request:uri();
if (r = this:_match_uri(uri))
{type, x0, x1, x2} = r;
if (((("objects" == type) && (!x0)) && (!x1)) && (!x2))
if (!valid(player))
response = response:set_status(403);
return {request, response};
endif
o = create($nothing);
body = $shapes:write_object(o, body);
body = generate_json(body, "embedded-types");
response = response:set_status(201):set_location(tostr(this.prefix, "objects/", toint(o))):set_type("application/json"):set_body(body);
return {request, response};
endif
endif
response = response:set_status(404);
return {request, response};
return;
"$restrict_to_caller($dialog.server, \"_drop_perms_and_call_verb\", \"serve\");";
"";
"set_task_perms(caller_perms());";
"";
"{request, response} = args;";
"";
"if (`request:type() ! E_RANGE' != \"application/json\" ||";
"    `(body = request:body()) ! E_RANGE' == E_RANGE ||";
"    `(body = parse_json(body, \"embedded-types\")) ! E_INVARG' == E_INVARG)";
"  response = response:set_status(415);";
"  return {request, response};";
"endif";
"";
"uri = request:uri();";
"";
"if (r = this:_match_uri(uri))";
"  {type, x0, x1, x2} = r;";
"  if (\"objects\" == type && !x0 && !x1 && !x2)";
"    if (!valid(player))";
"      response = response:set_status(403);";
"      return {request, response};";
"    endif";
"    o = create($nothing);";
"    body = $shapes:write_object(o, body);";
"    body = generate_json(body, \"embedded-types\");";
"    response = response:set_status(201):set_location(tostr(this.prefix, \"objects/\", toint(o))):set_type(\"application/json\"):set_body(body);";
"    return {request, response};";
"  endif";
"endif";
"";
"response = response:set_status(404);";
"return {request, response};";
"";
"chunk_length:32";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:1DBD5C3CC4BAF1CA2FDB0357518F346E6173B0FC";
"-=-=-mxyzptlk-=-=-";
.
#131:6
$restrict_to_caller($dialog.server, "_drop_perms_and_call_verb", "serve");
set_task_perms(caller_perms());
{request, response} = args;
uri = request:uri();
if (r = this:_match_uri(uri))
{type, id, x1, x2} = r;
if (((("objects" == type) && id) && (!x1)) && (!x2))
if (!valid(o = this:_toobj(id)))
response = response:set_status(404);
return {request, response};
elseif (!$shapes:controls(player, o))
response = response:set_status(403);
return {request, response};
endif
`recycle(o) ! ANY';
if (valid(o))
response = response:set_status(500);
return {request, response};
endif
response = response:set_status(204);
return {request, response};
endif
endif
response = response:set_status(404);
return {request, response};
return;
"$restrict_to_caller($dialog.server, \"_drop_perms_and_call_verb\", \"serve\");";
"";
"set_task_perms(caller_perms());";
"";
"{request, response} = args;";
"";
"uri = request:uri();";
"";
"if (r = this:_match_uri(uri))";
"  {type, id, x1, x2} = r;";
"  if (\"objects\" == type && id && !x1 && !x2)";
"    if (!valid(o = this:_toobj(id)))";
"      response = response:set_status(404);";
"      return {request, response};";
"    elseif (!$shapes:controls(player, o))";
"      response = response:set_status(403);";
"      return {request, response};";
"    endif";
"    `recycle(o) ! ANY';";
"    if (valid(o)) /* if it's stil around... */";
"      response = response:set_status(500);";
"      return {request, response};";
"    endif";
"    response = response:set_status(204);";
"    return {request, response};";
"  endif";
"endif";
"";
"response = response:set_status(404);";
"return {request, response};";
"";
"chunk_length:30";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:D63893C8EA33B24FE5D829B1FE0A95154BC6377C";
"-=-=-mxyzptlk-=-=-";
.
#132:0
$restrict_to_caller($dialog.server, "_do_chain");
{request, response, chain} = args;
if (request:upgrade())
if ((`request:headers()["upgrade"] ! E_RANGE' == "moo") && (`request:headers()["X-Break-A-Leg"] ! E_RANGE' == "stunt"))
if (((typeof(new_player = `task_local()["http"]["session"]["player"] ! E_RANGE') == OBJ) && valid(new_player)) && is_player(new_player))
set_connection_option(player, "hold-input", 0);
set_connection_option(player, "disable-oob", 0);
set_connection_option(player, "binary", 0);
switch_player(player, new_player);
kill_task(task_id());
endif
boot_player(player);
return {request, response, {}};
endif
endif
return {request, response, chain};
return;
"$restrict_to_caller($dialog.server, \"_do_chain\");";
"";
"{request, response, chain} = args;";
"";
"if (request:upgrade())";
"  if (`request:headers()[\"upgrade\"] ! E_RANGE' == \"moo\" && `request:headers()[\"X-Break-A-Leg\"] ! E_RANGE' == \"stunt\")";
"    if (typeof(new_player = `task_local()[\"http\"][\"session\"][\"player\"] ! E_RANGE') == OBJ && valid(new_player) && is_player(new_player))";
"      /* put the connection into interactive mode */";
"      set_connection_option(player, \"hold-input\", 0);";
"      set_connection_option(player, \"disable-oob\", 0);";
"      set_connection_option(player, \"binary\", 0);";
"      switch_player(player, new_player);";
"      /* This is clumsy, but... when we successfully upgrade the";
"       * connection, end the task/request without booting the player";
"       * and let MOO's own command handling take over.";
"       */";
"      kill_task(task_id());";
"    endif";
"";
"    /* It's a valid upgrade, but the session is out-of-date or bogus.";
"     * For safety's sake, close the connection.";
"     */";
"    boot_player(player);";
"    return {request, response, {}};";
"  endif";
"endif";
"";
"/* continue if not upgrading */";
"return {request, response, chain};";
"";
"chunk_length:29";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:3DA5626BEDD8B12ECEFE3181CD693BBBB7315DD3";
"-=-=-mxyzptlk-=-=-";
.
#132:1
$restrict_to_caller($dialog.server, "_do_chain");
{request, response, chain} = args;
if (request:path() == "/__long_poll")
if (`request:headers()["X-Break-A-Leg"] ! E_RANGE' == "stunt")
if (((typeof(new_player = `task_local()["http"]["session"]["player"] ! E_RANGE') == OBJ) && valid(new_player)) && is_player(new_player))
notify(player, tostr("HTTP/1.1 ", 200, " ", "Ok", "~0D~0A"));
notify(player, tostr("Content-Type: ", "text/plain", "~0D~0A"));
notify(player, "~0D~0A");
for i in [1..16]
notify(player, "                                                                                                                                ");
endfor
set_connection_option(player, "hold-input", 0);
set_connection_option(player, "disable-oob", 0);
set_connection_option(player, "binary", 0);
switch_player(player, new_player);
if (cmd = `request:body() ! E_RANGE')
force_input(new_player, cmd);
endif
kill_task(task_id());
endif
boot_player(player);
return {request, response, {}};
endif
endif
return {request, response, chain};
return;
"$restrict_to_caller($dialog.server, \"_do_chain\");";
"";
"{request, response, chain} = args;";
"";
"if (request:path() == \"/__long_poll\")";
"  if (`request:headers()[\"X-Break-A-Leg\"] ! E_RANGE' == \"stunt\")";
"    if (typeof(new_player = `task_local()[\"http\"][\"session\"][\"player\"] ! E_RANGE') == OBJ && valid(new_player) && is_player(new_player))";
"      /* write a minimal header */";
"      notify(player, tostr(\"HTTP/1.1 \", 200, \" \", \"Ok\", \"~0D~0A\"));";
"      notify(player, tostr(\"Content-Type: \", \"text/plain\", \"~0D~0A\"));";
"      notify(player, \"~0D~0A\");";
"      /* write 2048 bytes to get chrome off its ass */";
"      for i in [1..16]";
"        notify(player, \"                                                                                                                                \");";
"      endfor";
"      /* put the connection into interactive mode */";
"      set_connection_option(player, \"hold-input\", 0);";
"      set_connection_option(player, \"disable-oob\", 0);";
"      set_connection_option(player, \"binary\", 0);";
"      switch_player(player, new_player);";
"      /* finally, force the body as a command */";
"      if (cmd = `request:body() ! E_RANGE')";
"        force_input(new_player, cmd);";
"      endif";
"      /* This is clumsy, but... when we successfully set up the";
"       * connection, end the task/request without booting the player";
"       * and let MOO's own command handling take over.";
"       */";
"      kill_task(task_id());";
"    endif";
"";
"    /* It's a valid poll, but the session is out-of-date or bogus.";
"     * For safety's sake, close the connection.";
"     */";
"    boot_player(player);";
"    return {request, response, {}};";
"  endif";
"";
"endif";
"";
"return {request, response, chain};";
"";
"chunk_length:41";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:C9DA4A4709AB750ED4339CFBC6B47CDFFF176FD2";
"-=-=-mxyzptlk-=-=-";
.
#133:0
$restrict_to_caller($dialog.server, "_do_chain");
{request, response, chain} = args;
finish = time();
start = `task_local()["http"]["start"] ! E_RANGE => finish';
client = `request:parameters()["__remote_client__"] ! E_RANGE => "NA"';
player = `task_local()["http"]["session"]["player"] ! E_RANGE => $nothing';
name = `player.name ! E_TYPE, E_INVIND => ""';
server_log(tostr("HTTP: ", client, " ", toliteral(name), " (", player, ") ", request:method(), " ", request:uri(), " ", response:status(), " ", finish - start));
return {request, response, chain};
return;
"$restrict_to_caller($dialog.server, \"_do_chain\")";
"";
"{request, response, chain} = args";
"";
"finish = time()";
"";
"start = (task_local()[\"http\"][\"start\"] !! E_RANGE => finish)";
"client = (request:parameters()[\"__remote_client__\"] !! E_RANGE => \"NA\")";
"player = (task_local()[\"http\"][\"session\"][\"player\"] !! E_RANGE => $nothing)";
"name = (player.name !! E_TYPE, E_INVIND => \"\")";
"";
"server_log(tostr(\"HTTP: \", client, \" \", toliteral(name), \" (\", player, \") \", request:method(), \" \", request:uri(), \" \", response:status(), \" \", finish - start))";
"";
"return {request, response, chain}";
"";
"chunk_length:14";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:07DF7F582068D0F8208AE222C368658830183C5B";
"-=-=-mxyzptlk-=-=-";
.
#134:0
{context} = args;
return `context["__authenticity_token__"]:escape_html_attribute_content() ! E_RANGE => ""';
return;
"{context} = args";
"return context[\"__authenticity_token__\"]:escape_html_attribute_content() !! E_RANGE => \"\"";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:B3536822CAA3782DC9922F7C738D8584E36E1FB4";
"-=-=-mxyzptlk-=-=-";
"[\"pre.usage\",[\"code.language-moocode\",[\"em\",\"STR\"],\" \",[\"em\",\"<view_helpers>\"],\":\",[\"strong\",\"authenticity_token\"],\"(\",[\"var\",\"MAP context\"],\")\"]]";
"[\"p\",\"Extracts the authenticity token from the \",[\"var\",\"context\"],\" and returns it.\"]";
"";
"chunk_length:2";
"chunk_type:documentation";
"content_type:application/json";
"sha1:625F25F716B2A13A499FED4650B40FD81494DA56";
"-=-=-mxyzptlk-=-=-";
.
#134:1
{context, @stack} = args;
return tostr("<meta name=\"authenticity_token\" content=\"", this:authenticity_token(context), "\"/>");
return;
"{context, @stack} = args";
"return tostr('<meta name=\"authenticity_token\" content=\"', this:authenticity_token(context), '\"/>')";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:445E04C2D0ECB7191FF3D75D972C0EE24F59A9EE";
"-=-=-mxyzptlk-=-=-";
"[\"pre.usage\",[\"code.language-mustache\",\"{{>\",[\"strong\",\"authenticity_token_meta_tag\"],\"}}\"]]";
"[\"p\",\"Inserts the authenticity token in a meta tag into the current mustache template.\"]";
"";
"chunk_length:2";
"chunk_type:documentation";
"content_type:application/json";
"sha1:4E001D3F88744B5D243BFAEA1C84203717BC0B93";
"-=-=-mxyzptlk-=-=-";
.
#134:2
{context, @stack} = args;
return tostr("<input type=\"hidden\" name=\"authenticity_token\" value=\"", this:authenticity_token(context), "\">");
return;
"{context, @stack} = args";
"return tostr('<input type=\"hidden\" name=\"authenticity_token\" value=\"', this:authenticity_token(context), '\">')";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:87B093FD9A78277610CB6A48F3F670F8177DA1E7";
"-=-=-mxyzptlk-=-=-";
"[\"pre.usage\",[\"code.language-mustache\",\"{{>\",[\"strong\",\"authenticity_token_form_input\"],\"}}\"]]";
"[\"p\",\"Inserts the authenticity token in a form input tag into the current mustache template.\"]";
"";
"chunk_length:2";
"chunk_type:documentation";
"content_type:application/json";
"sha1:5E09637C2ABA7985804D94E98F74357E73421D25";
"-=-=-mxyzptlk-=-=-";
.
#134:3
{context} = args;
return `this.database_server.prefix:escape_html_attribute_content() ! E_RANGE => ""';
return;
"{context} = args";
"return this.database_server.prefix:escape_html_attribute_content() !! E_RANGE => \"\"";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:98CB3C2373EE1AF8B40EEE4987B759B9C94F311F";
"-=-=-mxyzptlk-=-=-";
"[\"pre.usage\",[\"code.language-moocode\",[\"em\",\"STR\"],\" \",[\"em\",\"<view_helpers>\"],\":\",[\"strong\",\"service_url\"],\"(\",[\"var\",\"MAP context\"],\")\"]]";
"[\"p\",\"Returns the service URL. This is the starting URL for RESTful access to the database.\"]";
"";
"chunk_length:2";
"chunk_type:documentation";
"content_type:application/json";
"sha1:5F294588F4CC3B31EEA364908A66C6841EAC14B4";
"-=-=-mxyzptlk-=-=-";
.
#134:4
{context, @stack} = args;
return tostr("<meta name=\"service_url\" content=\"", this:service_url(context), "\"/>");
return;
"{context, @stack} = args";
"return tostr('<meta name=\"service_url\" content=\"', this:service_url(context), '\"/>')";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:A2712830C1BE08849A7C75BF46F371B780650B32";
"-=-=-mxyzptlk-=-=-";
"[\"pre.usage\",[\"code.language-mustache\",\"{{>\",[\"strong\",\"service_url_meta_tag\"],\"}}\"]]";
"[\"p\",\"Inserts the service URL in a meta tag into the current mustache template.\"]";
"";
"chunk_length:2";
"chunk_type:documentation";
"content_type:application/json";
"sha1:10FEB11576460BDE4095F73F60809536ABB509ED";
"-=-=-mxyzptlk-=-=-";
.
#135:0
$restrict_to_caller($composed);
$external_compilers["application/x-mustache"] = $mustache.compiler;
return;
"$restrict_to_caller($composed);";
"";
"$external_compilers[\"application/x-mustache\"] = $mustache.compiler;";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:20B0254B84F3C85A0B3F9FBD3FA91AB168AEDFAE";
"-=-=-mxyzptlk-=-=-";
.
#135:1
$restrict_to_caller($composed);
$external_compilers = $external_compilers:delete("application/x-mustache");
return;
"$restrict_to_caller($composed);";
"";
"$external_compilers = $external_compilers:delete(\"application/x-mustache\");";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:28F56276ABB1EBEE63718214A624DBB6D74EE42C";
"-=-=-mxyzptlk-=-=-";
.
#138:0
$private();
server_log(tostr(@args));
return;
"$private();";
"server_log(tostr(@args));";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:5C711D4BD9B9002572DB2CFAFFD7E9106FB3C119";
"-=-=-mxyzptlk-=-=-";
.
#138:1
{source, ?options = []} = args;
(typeof(source) == LIST) || raise(E_TYPE, "Source must be a list");
code = {"stack = args;", "output = {};"};
start_delim = "{{";
end_delim = "}}";
had_partial = 0;
in_comment = 0;
tag_count = 0;
tag_stack = {};
linec = 0;
for line in (source)
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
linec = linec + 1;
if (in_comment)
e = end_delim;
if (!(i = line:index(e)))
line = "";
else
line = line[i + length(e)..$];
tag_count = tag_count + 1;
in_comment = 0;
endif
else
tag_count = 0;
if (line == "")
code = {@code, "output = {@output, \"\", 0};"};
endif
endif
while (line)
escaped = 1;
start_new_context = 0;
start_new_inverted_context = 0;
end_context = 0;
include_partial = 0;
set_delimiters = 0;
comment = 0;
s = start_delim;
if (!(i = line:index(s)))
code = {@code, tostr("output = {@output, ", toliteral(line), ", ", tag_count, "};")};
tag_count = 0;
line = "";
continue;
endif
if ((c = line[i + length(s)]) == "{")
escaped = 0;
s = start_delim + "{";
e = "}" + end_delim;
elseif (c == "&")
escaped = 0;
s = start_delim + "&";
e = end_delim;
elseif (c == "#")
start_new_context = 1;
s = start_delim + "#";
e = end_delim;
elseif (c == "^")
start_new_inverted_context = 1;
s = start_delim + "^";
e = end_delim;
elseif (c == "/")
end_context = 1;
s = start_delim + "/";
e = end_delim;
elseif (c == ">")
include_partial = 1;
s = start_delim + ">";
e = end_delim;
elseif (c == "=")
set_delimiters = 1;
s = start_delim + "=";
e = "=" + end_delim;
elseif (c == "!")
comment = 1;
s = start_delim + "!";
e = end_delim;
else
s = start_delim;
e = end_delim;
endif
content = line[1..i - 1];
rest = line[i + length(s)..$];
if ((!(j = rest:index(e))) && comment)
code = {@code, tostr("output = {@output, ", toliteral(content), "};")};
in_comment = 1;
line = "";
continue;
elseif (!j)
code = {@code, tostr("output = {@output, ", toliteral(line), ", ", tag_count, "};")};
tag_count = 0;
line = "";
continue;
endif
j = ((j + i) + length(s)) - 1;
tag = original_tag = line[i + length(s)..j - 1]:trim();
tag_list = original_tag_list = (tag != ".") ? tag:split(".") | {"."};
code = {@code, tostr("output = {@output, ", toliteral(content), "};")};
line = line[j + length(e)..$];
if (comment)
tag_count = tag_count + 1;
elseif (include_partial)
had_partial = 1;
code = {@code, tostr("verb = `this:(\"", original_tag, "\")(@stack) ! E_VERBNF => {}';")};
code = {@code, "output = {@output, verb};"};
tag_count = tag_count + 1;
elseif (set_delimiters)
{start_delim, end_delim} = original_tag:split();
tag_count = tag_count + 1;
elseif (start_new_context)
tag_stack = {tag, @tag_stack};
if ((l = length(original_tag_list)) > 1)
code = {@code, "failed = 0;"};
tag = original_tag_list[1];
code = {@code, tostr("if (top = `stack[1][\"", tag, "\"] ! E_RANGE')")};
code = {@code, "stack = {stack[1]:merge(typeof(top) == MAP ? top | []), @stack};"};
code = {@code, "else"};
code = {@code, "stack = {[], @stack}; failed = 1;"};
code = {@code, "endif"};
for tag in (original_tag_list[2..$ - 1])
code = {@code, tostr("if (top = `stack[1][\"", tag, "\"] ! E_RANGE')")};
code = {@code, "stack = {typeof(top) == MAP ? top | [], @stack};"};
code = {@code, "else"};
code = {@code, "stack = {[], @stack}; failed = 1;"};
code = {@code, "endif"};
endfor
tag = original_tag_list[$];
code = {@code, tostr("if (!failed && (top = `stack[1][\"", tag, "\"] ! E_RANGE'))")};
code = {@code, "for item in (typeof(top) == LIST ? top | {top})"};
code = {@code, "ticks_left() < 10000 || seconds_left() < 2 && suspend(0);"};
code = {@code, "stack = {typeof(item) == MAP ? item | [\".\" -> item], @stack};"};
else
tag = original_tag_list[1];
code = {@code, tostr("if (top = `stack[1][\"", tag, "\"] ! E_RANGE')")};
code = {@code, "for item in (typeof(top) == LIST ? top | {top})"};
code = {@code, "ticks_left() < 10000 || seconds_left() < 2 && suspend(0);"};
code = {@code, "stack = {stack[1]:merge(typeof(item) == MAP ? item | [\".\" -> item]), @stack};"};
endif
tag_count = tag_count + 1;
elseif (start_new_inverted_context)
tag_stack = {tag, @tag_stack};
if ((l = length(original_tag_list)) > 1)
code = {@code, "failed = 0;"};
tag = original_tag_list[1];
code = {@code, tostr("if (top = `stack[1][\"", tag, "\"] ! E_RANGE')")};
code = {@code, "stack = {stack[1]:merge(typeof(top) == MAP ? top | []), @stack};"};
code = {@code, "else"};
code = {@code, "stack = {[], @stack}; failed = 1;"};
code = {@code, "endif"};
for tag in (original_tag_list[2..$ - 1])
code = {@code, tostr("if (top = `stack[1][\"", tag, "\"] ! E_RANGE')")};
code = {@code, "stack = {typeof(top) == MAP ? top | [], @stack};"};
code = {@code, "else"};
code = {@code, "stack = {[], @stack}; failed = 1;"};
code = {@code, "endif"};
endfor
tag = original_tag_list[$];
code = {@code, tostr("if (failed || !(top = `stack[1][\"", tag, "\"] ! E_RANGE'))")};
code = {@code, "for item in ({\"\"})"};
code = {@code, "ticks_left() < 10000 || seconds_left() < 2 && suspend(0);"};
code = {@code, "stack = {typeof(item) == MAP ? item | [\".\" -> item], @stack};"};
else
tag = original_tag_list[1];
code = {@code, tostr("if (!(top = `stack[1][\"", tag, "\"] ! E_RANGE'))")};
code = {@code, "for item in ({\"\"})"};
code = {@code, "ticks_left() < 10000 || seconds_left() < 2 && suspend(0);"};
code = {@code, "stack = {stack[1]:merge(typeof(item) == MAP ? item | [\".\" -> item]), @stack};"};
endif
tag_count = tag_count + 1;
elseif (end_context)
if (!tag_stack)
return {0, {tostr("Line ", linec, ":  dangling end tag:  ", tag)}};
endif
{top, @tag_stack} = tag_stack;
if (top != tag)
return {0, {tostr("Line ", linec, ":  mismatched end tag:  ", tag)}};
endif
code = {@code, "stack = stack[2..$];", "endfor", "endif"};
if ((l = length(original_tag_list)) > 1)
code = {@code, tostr("stack = stack[", l, "..$];")};
endif
tag_count = tag_count + 1;
else
if ((l = length(original_tag_list)) > 1)
for tag in (original_tag_list[1..$ - 1])
code = {@code, tostr("top = `stack[1][\"", tag, "\"] ! E_RANGE';")};
code = {@code, "stack = {typeof(top) == MAP ? top | [], @stack};"};
endfor
endif
if (!original_tag_list)
return {0, {tostr("Line ", linec, ":  empty tag")}};
endif
tag = original_tag_list[$];
if (escaped)
code = {@code, tostr("output = {@output, strsub(strsub(strsub(strsub(", "`tostr(stack[1][\"", tag, "\"]) ! E_RANGE => \"\"'", ", \"&\", \"&amp;\"), \"<\", \"&lt;\"), \">\", \"&gt;\"), \"\\\"\", \"&quot;\")};")};
else
code = {@code, tostr("output = {@output, `tostr(stack[1][\"", tag, "\"]) ! E_RANGE => \"\"'};")};
endif
if (l > 1)
code = {@code, tostr("stack = stack[", l, "..$];")};
endif
tag_count = tag_count + 1;
endif
endwhile
if ((!in_comment) && tag_count)
code = {@code, tostr("output = {@output, ", tag_count, "};")};
endif
endfor
if (tag_stack)
return {0, {tostr("Line ", linec, ":  missing end tag:  ", tag_stack[1])}};
endif
code = {@code, "out = {}; acc = {}; indent = \"\";"};
code = {@code, "while (output)"};
code = {@code, "{line, @output} = output;"};
code = {@code, "ticks_left() < 10000 || seconds_left() < 2 && suspend(0);"};
code = {@code, "if (typeof(line) == LIST)"};
if (had_partial)
code = {@code, "if (lines = line)"};
code = {@code, "if (length(lines) > 1)"};
code = {@code, "temp = {lines[1], 0};"};
code = {@code, "for line in (lines[2..$ - 1])"};
code = {@code, "temp = {@temp, indent + line, 0};"};
code = {@code, "endfor"};
code = {@code, "temp = {@temp, indent + lines[$]};"};
code = {@code, "output = {@temp, @output};"};
code = {@code, "else"};
code = {@code, "output = {lines[1], @output};"};
code = {@code, "endif"};
code = {@code, "endif"};
endif
code = {@code, "elseif (typeof(line) == INT)"};
code = {@code, "if (line > 0)"};
code = {@code, "if (match(acc = tostr(@acc), \"[^ ]\"))"};
code = {@code, "out = {@out, acc};"};
code = {@code, "endif"};
code = {@code, "else"};
code = {@code, "out = {@out, tostr(@acc)};"};
code = {@code, "endif"};
code = {@code, "acc = {};"};
if (had_partial)
code = {@code, "indent = \"\";"};
endif
code = {@code, "else"};
if (had_partial)
code = {@code, "if (!match(line, \"[^ ]\"))"};
code = {@code, "indent = line;"};
code = {@code, "endif"};
endif
code = {@code, "acc = {@acc, line};"};
code = {@code, "endif"};
code = {@code, "endwhile"};
code = {@code, "return out;"};
return {1, code};
return;
"{source, ?options = []} = args;";
"";
"(typeof(source) == LIST) || raise(E_TYPE, \"Source must be a list\");";
"";
"/* NOTES */";
"/* LambdaMOO currently only has one kind of whitespace -- a single";
" * space -- therefore many of the associated tests from the";
" * specification don't quite work as-is.  In sames cases, I have";
" * replaced tab (\\t) and newline (\\n) with a single space.  In other";
" * cases, I have used lists to represent lines separated by a newline";
" * (or return/newline).  Other tests just won't pass as-is without";
" * finer control over line-endings.";
" */";
"";
"code = {\"stack = args;\", \"output = {};\"};";
"";
"/* the initial delimiters */";
"start_delim = \"{{\";";
"end_delim = \"}}\";";
"";
"/* if true, the template had a partial */";
"had_partial = 0;";
"";
"/* if true, we're processing a multiline comment */";
"in_comment = 0;";
"";
"/* the number of tags in the line */";
"tag_count = 0;";
"";
"/* for matching tags */";
"tag_stack = {};";
"";
"/* line count */";
"linec = 0;";
"";
"/* process each line */";
"for line in (source)";
"  ticks_left() < 10000 || seconds_left() < 2 && suspend(0);";
"";
"  linec = linec + 1;";
"";
"  /* if we're processing a multiline comment, look for the end";
"   * delimiter -- once found, continue with the rest of the line as if";
"   * it were a continuation of the line on which the comment started";
"   */";
"  if (in_comment)";
"    e = end_delim;";
"    if (!(i = line:index(e)))";
"      line = \"\";";
"    else";
"      line = line[i + length(e)..$];";
"      tag_count = tag_count + 1;";
"      in_comment = 0;";
"    endif";
"";
"  else";
"    tag_count = 0;";
"";
"    /* preserve empty lines */";
"    if (line == \"\")";
"      code = {@code, \"output = {@output, \\\"\\\", 0};\"};";
"    endif";
"";
"  endif";
"";
"  /* chop each line into pieces of content separated by tags -- each";
"   * pass through the loop tries to find a tag and the piece of";
"   * content preceding it";
"   */";
"  while (line)";
"    escaped = 1;";
"    start_new_context = 0;";
"    start_new_inverted_context = 0;";
"    end_context = 0;";
"    include_partial = 0;";
"    set_delimiters = 0;";
"    comment = 0;";
"";
"    /* look for a starting delimiter */";
"    s = start_delim;";
"    if (!(i = line:index(s)))";
"      /* no delimiter! */";
"      code = {@code, tostr(\"output = {@output, \", toliteral(line), \", \", tag_count, \"};\")};";
"      tag_count = 0;";
"      line = \"\";";
"      continue;";
"    endif";
"";
"    if ((c = line[i + length(s)]) == \"{\")";
"      escaped = 0;";
"      s = start_delim + \"{\";";
"      e = \"}\" + end_delim;";
"    elseif (c == \"&\")";
"      escaped = 0;";
"      s = start_delim + \"&\";";
"      e = end_delim;";
"    elseif (c == \"#\")";
"      start_new_context = 1;";
"      s = start_delim + \"#\";";
"      e = end_delim;";
"    elseif (c == \"^\")";
"      start_new_inverted_context = 1;";
"      s = start_delim + \"^\";";
"      e = end_delim;";
"    elseif (c == \"/\")";
"      end_context = 1;";
"      s = start_delim + \"/\";";
"      e = end_delim;";
"    elseif (c == \">\")";
"      include_partial = 1;";
"      s = start_delim + \">\";";
"      e = end_delim;";
"    elseif (c == \"=\")";
"      set_delimiters = 1;";
"      s = start_delim + \"=\";";
"      e = \"=\" + end_delim;";
"    elseif (c == \"!\")";
"      comment = 1;";
"      s = start_delim + \"!\";";
"      e = end_delim;";
"    else";
"      s = start_delim;";
"      e = end_delim;";
"    endif";
"";
"    content = line[1..i - 1];";
"    rest = line[i + length(s)..$];";
"";
"    /* look for an ending delimiter */";
"    if (!(j = rest:index(e)) && comment)";
"      /* no delimiter! but we're inside a comment */";
"      code = {@code, tostr(\"output = {@output, \", toliteral(content), \"};\")};";
"      in_comment = 1;";
"      line = \"\";";
"      continue;";
"    elseif (!j)";
"      /* no delimiter! */";
"      code = {@code, tostr(\"output = {@output, \", toliteral(line), \", \", tag_count, \"};\")};";
"      tag_count = 0;";
"      line = \"\";";
"      continue;";
"    endif";
"";
"    /* make j relative to the beginning of the line */";
"    j = j + i + length(s) - 1;";
"";
"    /* parse the tag */";
"    tag = original_tag = line[i + length(s)..j - 1]:trim();";
"    tag_list = original_tag_list = tag != \".\" ? tag:split(\".\") | {\".\"};";
"";
"    code = {@code, tostr(\"output = {@output, \", toliteral(content), \"};\")};";
"";
"    line = line[j + length(e)..$];";
"";
"    if (comment)";
"      tag_count = tag_count + 1;";
"";
"    elseif (include_partial)";
"      had_partial = 1;";
"      code = {@code, tostr(\"verb = `this:(\\\"\", original_tag, \"\\\")(@stack) ! E_VERBNF => {}';\")};";
"      code = {@code, \"output = {@output, verb};\"};";
"      tag_count = tag_count + 1;";
"";
"    elseif (set_delimiters)";
"      {start_delim, end_delim} = original_tag:split();";
"      tag_count = tag_count + 1;";
"";
"    elseif (start_new_context)";
"      /* if all parts succeed, consider the tag truthy */";
"      /* always increase the stack depth so that the end-tag pops the correct number of frames off */";
"      tag_stack = {tag, @tag_stack};";
"      if ((l = length(original_tag_list)) > 1)";
"        code = {@code, \"failed = 0;\"};";
"        tag = original_tag_list[1];";
"        code = {@code, tostr(\"if (top = `stack[1][\\\"\", tag, \"\\\"] ! E_RANGE')\")};";
"        code = {@code, \"stack = {stack[1]:merge(typeof(top) == MAP ? top | []), @stack};\"};";
"        code = {@code, \"else\"};";
"        code = {@code, \"stack = {[], @stack}; failed = 1;\"};";
"        code = {@code, \"endif\"};";
"        for tag in (original_tag_list[2..$ - 1])";
"          code = {@code, tostr(\"if (top = `stack[1][\\\"\", tag, \"\\\"] ! E_RANGE')\")};";
"          code = {@code, \"stack = {typeof(top) == MAP ? top | [], @stack};\"};";
"          code = {@code, \"else\"};";
"          code = {@code, \"stack = {[], @stack}; failed = 1;\"};";
"          code = {@code, \"endif\"};";
"        endfor";
"        tag = original_tag_list[$];";
"        code = {@code, tostr(\"if (!failed && (top = `stack[1][\\\"\", tag, \"\\\"] ! E_RANGE'))\")};";
"        code = {@code, \"for item in (typeof(top) == LIST ? top | {top})\"};";
"        code = {@code, \"ticks_left() < 10000 || seconds_left() < 2 && suspend(0);\"};";
"        code = {@code, \"stack = {typeof(item) == MAP ? item | [\\\".\\\" -> item], @stack};\"};";
"      else";
"        tag = original_tag_list[1];";
"        code = {@code, tostr(\"if (top = `stack[1][\\\"\", tag, \"\\\"] ! E_RANGE')\")};";
"        code = {@code, \"for item in (typeof(top) == LIST ? top | {top})\"};";
"        code = {@code, \"ticks_left() < 10000 || seconds_left() < 2 && suspend(0);\"};";
"        code = {@code, \"stack = {stack[1]:merge(typeof(item) == MAP ? item | [\\\".\\\" -> item]), @stack};\"};";
"      endif";
"      tag_count = tag_count + 1;";
"";
"    elseif (start_new_inverted_context)";
"      /* if any part fails, consider the tag falsey */";
"      /* always increase the stack depth so that the end-tag pops the correct number of frames off */";
"      tag_stack = {tag, @tag_stack};";
"      if ((l = length(original_tag_list)) > 1)";
"        code = {@code, \"failed = 0;\"};";
"        tag = original_tag_list[1];";
"        code = {@code, tostr(\"if (top = `stack[1][\\\"\", tag, \"\\\"] ! E_RANGE')\")};";
"        code = {@code, \"stack = {stack[1]:merge(typeof(top) == MAP ? top | []), @stack};\"};";
"        code = {@code, \"else\"};";
"        code = {@code, \"stack = {[], @stack}; failed = 1;\"};";
"        code = {@code, \"endif\"};";
"        for tag in (original_tag_list[2..$ - 1])";
"          code = {@code, tostr(\"if (top = `stack[1][\\\"\", tag, \"\\\"] ! E_RANGE')\")};";
"          code = {@code, \"stack = {typeof(top) == MAP ? top | [], @stack};\"};";
"          code = {@code, \"else\"};";
"          code = {@code, \"stack = {[], @stack}; failed = 1;\"};";
"          code = {@code, \"endif\"};";
"        endfor";
"        tag = original_tag_list[$];";
"        code = {@code, tostr(\"if (failed || !(top = `stack[1][\\\"\", tag, \"\\\"] ! E_RANGE'))\")};";
"        code = {@code, \"for item in ({\\\"\\\"})\"};";
"        code = {@code, \"ticks_left() < 10000 || seconds_left() < 2 && suspend(0);\"};";
"        code = {@code, \"stack = {typeof(item) == MAP ? item | [\\\".\\\" -> item], @stack};\"};";
"      else";
"        tag = original_tag_list[1];";
"        code = {@code, tostr(\"if (!(top = `stack[1][\\\"\", tag, \"\\\"] ! E_RANGE'))\")};";
"        code = {@code, \"for item in ({\\\"\\\"})\"};";
"        code = {@code, \"ticks_left() < 10000 || seconds_left() < 2 && suspend(0);\"};";
"        code = {@code, \"stack = {stack[1]:merge(typeof(item) == MAP ? item | [\\\".\\\" -> item]), @stack};\"};";
"      endif";
"      tag_count = tag_count + 1;";
"";
"    elseif (end_context)";
"      if (!tag_stack)";
"        return {0, {tostr(\"Line \", linec, \":  dangling end tag:  \", tag)}};";
"      endif";
"      {top, @tag_stack} = tag_stack;";
"      if (top != tag)";
"        return {0, {tostr(\"Line \", linec, \":  mismatched end tag:  \", tag)}};";
"      endif";
"      code = {@code, \"stack = stack[2..$];\", \"endfor\", \"endif\"};";
"      if ((l = length(original_tag_list)) > 1)";
"        code = {@code, tostr(\"stack = stack[\", l, \"..$];\")};";
"      endif";
"      tag_count = tag_count + 1;";
"";
"    else";
"      if ((l = length(original_tag_list)) > 1)";
"        for tag in (original_tag_list[1..$ - 1])";
"          code = {@code, tostr(\"top = `stack[1][\\\"\", tag, \"\\\"] ! E_RANGE';\")};";
"          code = {@code, \"stack = {typeof(top) == MAP ? top | [], @stack};\"};";
"        endfor";
"      endif";
"      if (!original_tag_list)";
"        return {0, {tostr(\"Line \", linec, \":  empty tag\")}};";
"      endif";
"      tag = original_tag_list[$];";
"      if (escaped)";
"        code = {@code, tostr(\"output = {@output, strsub(strsub(strsub(strsub(\", \"`tostr(stack[1][\\\"\", tag, \"\\\"]) ! E_RANGE => \\\"\\\"'\", \", \\\"&\\\", \\\"&amp;\\\"), \\\"<\\\", \\\"&lt;\\\"), \\\">\\\", \\\"&gt;\\\"), \\\"\\\\\\\"\\\", \\\"&quot;\\\")};\")};";
"      else";
"        code = {@code, tostr(\"output = {@output, `tostr(stack[1][\\\"\", tag, \"\\\"]) ! E_RANGE => \\\"\\\"'};\")};";
"      endif";
"      if (l > 1)";
"        code = {@code, tostr(\"stack = stack[\", l, \"..$];\")};";
"      endif";
"      tag_count = tag_count + 1;";
"";
"    endif";
"";
"  endwhile";
"";
"  /* add line terminator */";
"  if (!in_comment && tag_count)";
"    code = {@code, tostr(\"output = {@output, \", tag_count, \"};\")};";
"  endif";
"";
"endfor";
"";
"if (tag_stack)";
"  return {0, {tostr(\"Line \", linec, \":  missing end tag:  \", tag_stack[1])}};";
"endif";
"";
"/* Clean up and render.";
" * `0' terminates lines of original content _without_ tags, otherwise";
" * the number indicates the number of tags in the line of original";
" * content.  Lists hold partial content, and must be indented.";
" */";
"code = {@code, \"out = {}; acc = {}; indent = \\\"\\\";\"};";
"code = {@code, \"while (output)\"};";
"code = {@code, \"{line, @output} = output;\"};";
"code = {@code, \"ticks_left() < 10000 || seconds_left() < 2 && suspend(0);\"};";
"code = {@code, \"if (typeof(line) == LIST)\"};";
"if (had_partial)";
"  code = {@code, \"if (lines = line)\"};";
"  code = {@code, \"if (length(lines) > 1)\"};";
"  code = {@code, \"temp = {lines[1], 0};\"};";
"  code = {@code, \"for line in (lines[2..$ - 1])\"};";
"  code = {@code, \"temp = {@temp, indent + line, 0};\"};";
"  code = {@code, \"endfor\"};";
"  code = {@code, \"temp = {@temp, indent + lines[$]};\"};";
"  code = {@code, \"output = {@temp, @output};\"};";
"  code = {@code, \"else\"};";
"  code = {@code, \"output = {lines[1], @output};\"};";
"  code = {@code, \"endif\"};";
"  code = {@code, \"endif\"};";
"endif";
"code = {@code, \"elseif (typeof(line) == INT)\"};";
"code = {@code, \"if (line > 0)\"};";
"code = {@code, \"if (match(acc = tostr(@acc), \\\"[^ ]\\\"))\"};";
"code = {@code, \"out = {@out, acc};\"};";
"code = {@code, \"endif\"};";
"code = {@code, \"else\"};";
"code = {@code, \"out = {@out, tostr(@acc)};\"};";
"code = {@code, \"endif\"};";
"code = {@code, \"acc = {};\"};";
"if (had_partial)";
"  code = {@code, \"indent = \\\"\\\";\"};";
"endif";
"code = {@code, \"else\"};";
"if (had_partial)";
"  code = {@code, \"if (!match(line, \\\"[^ ]\\\"))\"};";
"  code = {@code, \"indent = line;\"};";
"  code = {@code, \"endif\"};";
"endif";
"code = {@code, \"acc = {@acc, line};\"};";
"code = {@code, \"endif\"};";
"code = {@code, \"endwhile\"};";
"code = {@code, \"return out;\"};";
"";
"return {1, code};";
"";
"chunk_length:331";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:D953F0592C90A9BFFA80F4BA168484FAD6A98E5E";
"-=-=-mxyzptlk-=-=-";
.
#139:0
$restrict_to_caller($composed);
chparents(#5, {$alt.wizard_proto});
chparents(#6, {$alt.programmer_proto});
return;
"$restrict_to_caller($composed);";
"/* improvise-specific application tweaks */";
"chparents(#5, {$alt.wizard_proto});";
"chparents(#6, {$alt.programmer_proto});";
"";
"chunk_length:4";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:47625885FC0B925292089EDE0ACD5F175697BDC2";
"-=-=-mxyzptlk-=-=-";
.
#141:0
$restrict_to_caller($system, "server_started");
server = $lookup("server");
if ((port = toint(getenv("PORT"))) >= 1024)
server_log(tostr("APPLICATION: Environment specifies port ", port));
for listener in (listeners())
if (listener[1..2] == {$system, port})
unlisten(port);
break;
endif
endfor
else
port = server.port;
endif
server:start(port);
return;
"$restrict_to_caller($system, \"server_started\");";
"";
"server = $lookup(\"server\");";
"";
"if ((port = toint(getenv(\"PORT\"))) >= 1024)";
"  server_log(tostr(\"APPLICATION: Environment specifies port \", port));";
"  /* there can be only one... */";
"  for listener in (listeners())";
"    if (listener[1..2] == {$system, port})";
"      /* ...only one...! */";
"      unlisten(port);";
"      break;";
"    endif";
"  endfor";
"else";
"  port = server.port;";
"endif";
"";
"server:start(port);";
"";
"chunk_length:19";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:99DB63473B121BBB86A8E9BC8F7B722050386460";
"-=-=-mxyzptlk-=-=-";
.
#145:0
$private();
{?parameters = []} = args;
if (valid(player))
return parameters:merge(["links" -> {["id" -> tonum($system), "name" -> "$system"], ["id" -> tonum(player.location), "name" -> "home"], ["id" -> tonum(player), "name" -> "me"]}, "player" -> ["id" -> tonum(player), "name" -> player.name], "page" -> ["title" -> "Stunt | Improvise"]]);
else
return parameters:merge(["links" -> {["id" -> tonum($system), "name" -> "$system"]}, "page" -> ["title" -> "Stunt | Improvise"]]);
endif
return;
"$private()";
"";
"{parameters = []} = args";
"";
"if (valid(player))";
"  return parameters:merge([";
"    \"links\" -> {";
"      [\"id\" -> tonum($system), \"name\" -> \"$system\"],";
"      [\"id\" -> tonum(player.location), \"name\" -> \"home\"],";
"      [\"id\" -> tonum(player), \"name\" -> \"me\"]";
"    },";
"    \"player\" -> [\"id\" -> tonum(player), \"name\" -> player.name],";
"    \"page\" -> [\"title\" -> \"Stunt | Improvise\"]";
"  ])";
"else";
"  return parameters:merge([";
"    \"links\" -> {";
"      [\"id\" -> tonum($system), \"name\" -> \"$system\"]";
"    },";
"    \"page\" -> [\"title\" -> \"Stunt | Improvise\"]";
"  ])";
"end";
"";
"chunk_length:22";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:EB6289E288639999C9F2ED4360038E8CCEC8FE5B";
"-=-=-mxyzptlk-=-=-";
.
#145:1
$restrict_to_caller($dialog.server);
{parameters} = args;
_1538169645 = this;
_1877675954 = $lookup("home_views");
request = this.request;
response = this.response;
parameters = _1538169645:_common_parameters(parameters);
if (valid(player))
swf = (this.socket_or_long_poll == "socket") ? request:headers()["Cookie"] | 0;
parameters = parameters:merge(["page" -> ["title" -> "Stunt | Improvise", "swf" -> swf]]);
_1538169645:ok(_1877675954:home(parameters));
else
_1538169645:ok(_1877675954:public(parameters));
endif
return;
"$restrict_to_caller($dialog.server)";
"";
"{parameters} = args";
"";
"from this use _common_parameters, ok";
"from \"home_views\" use home, public";
"";
"request = this.request";
"response = this.response";
"parameters = _common_parameters(parameters)";
"";
"if (valid(player))";
"  swf = (this.socket_or_long_poll == \"socket\") ? request:headers()[\"Cookie\"] | 0";
"  parameters = parameters:merge([\"page\" -> [\"title\" -> \"Stunt | Improvise\", \"swf\" -> swf]])";
"  ok(home(parameters))";
"else";
"  ok(public(parameters))";
"end";
"";
"chunk_length:18";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:78101A7D58D21E321E3179D64D662EC3A5B2533B";
"-=-=-mxyzptlk-=-=-";
.
#145:2
$restrict_to_caller($dialog.server);
{parameters} = args;
_1897393334 = this;
_1191048313 = $lookup("home_views");
parameters = _1897393334:_common_parameters(parameters);
_1897393334:ok(_1191048313:browse(parameters));
return;
"$restrict_to_caller($dialog.server)";
"";
"{parameters} = args";
"";
"from this use _common_parameters, ok";
"from \"home_views\" use browse";
"";
"parameters = _common_parameters(parameters)";
"";
"ok(browse(parameters))";
"";
"chunk_length:10";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:F872B7A86B41CB011802DBFC54B95A19148C8014";
"-=-=-mxyzptlk-=-=-";
.
#146:0
stack = args;
output = {};
output = {@output, "<head>", 0};
output = {@output, "  <title>"};
top = `stack[1]["page"] ! E_RANGE';
stack = {(typeof(top) == MAP) ? top | ([]), @stack};
output = {@output, strsub(strsub(strsub(strsub(`tostr(stack[1]["title"]) ! E_RANGE => ""', "&", "&amp;"), "<", "&lt;"), ">", "&gt;"), "\"", "&quot;")};
stack = stack[2..$];
output = {@output, "</title>", 1};
output = {@output, "  "};
verb = `this:authenticity_token_meta_tag(@stack) ! E_VERBNF => {}';
output = {@output, verb};
output = {@output, 1};
output = {@output, "  "};
verb = `this:service_url_meta_tag(@stack) ! E_VERBNF => {}';
output = {@output, verb};
output = {@output, 1};
output = {@output, "  "};
failed = 0;
if (top = `stack[1]["page"] ! E_RANGE')
stack = {stack[1]:merge((typeof(top) == MAP) ? top | ([])), @stack};
else
stack = {[], @stack};
failed = 1;
endif
if ((!failed) && (top = `stack[1]["swf"] ! E_RANGE'))
for item in ((typeof(top) == LIST) ? top | {top})
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
stack = {(typeof(item) == MAP) ? item | (["." -> item]), @stack};
output = {@output, 1};
output = {@output, "    <meta name=\"session_state\" content=\""};
output = {@output, strsub(strsub(strsub(strsub(`tostr(stack[1]["."]) ! E_RANGE => ""', "&", "&amp;"), "<", "&lt;"), ">", "&gt;"), "\"", "&quot;")};
output = {@output, "\"/>", 1};
output = {@output, "    <script type=\"text/javascript\" src=\"/js/Socket.js\"></script>", 0};
output = {@output, "    <script type=\"text/javascript\" src=\"/js/swfobject-2.1.min.js\"></script>", 0};
output = {@output, "    <script type=\"text/javascript\">", 0};
output = {@output, "      var flashvars = {};", 0};
output = {@output, "      var params = {menu: 'false', scale: 'noScale', allowScriptAccess: 'always', bgcolor: '#FFFFFF'};", 0};
output = {@output, "      var attributes = {id: 'JavascriptSocket', name: 'JavascriptSocket'};", 0};
output = {@output, "      swfobject.embedSWF('/flash/javascriptsocket.swf', 'flash-content', '100%', '100%', '9.0.0', null, flashvars, params, attributes);", 0};
output = {@output, "    </script>", 0};
output = {@output, "  "};
stack = stack[2..$];
endfor
endif
stack = stack[2..$];
output = {@output, 1};
output = {@output, "  <link type=\"text/css\" rel=\"stylesheet\" href=\"/css/bootstrap-2.0.2.min.css\">", 0};
output = {@output, "  <link type=\"text/css\" rel=\"stylesheet\" href=\"/css/bootstrap-responsive-2.0.2.min.css\">", 0};
output = {@output, "  <link type=\"text/css\" rel=\"stylesheet\" href=\"/css/font-awesome-1.0.0-7.min.css\">", 0};
output = {@output, "  <link type=\"text/css\" rel=\"stylesheet\" href=\"/css/moo-0.0.4.min.css\">", 0};
output = {@output, "  <link type=\"text/css\" rel=\"stylesheet\" href=\"/css/console.min.css\">", 0};
output = {@output, "  <script type=\"text/javascript\" src=\"/js/jquery-1.7.1.min.js\"></script>", 0};
output = {@output, "  <script type=\"text/javascript\" src=\"/js/jquery.ui.core-1.8.18.min.js\"></script>", 0};
output = {@output, "  <script type=\"text/javascript\" src=\"/js/jquery.ui.widget-1.8.18.min.js\"></script>", 0};
output = {@output, "  <script type=\"text/javascript\" src=\"/js/jquery.console-1.1.0.min.js\"></script>", 0};
output = {@output, "  <script type=\"text/javascript\" src=\"/js/underscore-1.3.1.min.js\"></script>", 0};
output = {@output, "  <script type=\"text/javascript\" src=\"/js/backbone-0.9.2.min.js\"></script>", 0};
output = {@output, "  <script type=\"text/javascript\" src=\"/js/bootstrap-dropdown-2.0.2.js\"></script>", 0};
output = {@output, "  <script type=\"text/javascript\" src=\"/js/bootstrap-modal-2.0.2.js\"></script>", 0};
output = {@output, "  <script type=\"text/javascript\" src=\"/js/bootstrap-transition-2.0.2.js\"></script>", 0};
output = {@output, "  <script type=\"text/javascript\" src=\"/js/moo-0.0.4.min.js\"></script>", 0};
output = {@output, "  <script type=\"text/javascript\" src=\"/js/moo-interactive-0.0.4.min.js\"></script>", 0};
output = {@output, "</head>", 0};
out = {};
acc = {};
indent = "";
while (output)
{line, @output} = output;
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
if (typeof(line) == LIST)
if (lines = line)
if (length(lines) > 1)
temp = {lines[1], 0};
for line in (lines[2..$ - 1])
temp = {@temp, indent + line, 0};
endfor
temp = {@temp, indent + lines[$]};
output = {@temp, @output};
else
output = {lines[1], @output};
endif
endif
elseif (typeof(line) == INT)
if (line > 0)
if (match(acc = tostr(@acc), "[^ ]"))
out = {@out, acc};
endif
else
out = {@out, tostr(@acc)};
endif
acc = {};
indent = "";
else
if (!match(line, "[^ ]"))
indent = line;
endif
acc = {@acc, line};
endif
endwhile
return out;
return;
"<head>";
"  <title>{{page.title}}</title>";
"  {{>authenticity_token_meta_tag}}";
"  {{>service_url_meta_tag}}";
"  {{#page.swf}}";
"    <meta name=\"session_state\" content=\"{{.}}\"/>";
"    <script type=\"text/javascript\" src=\"/js/Socket.js\"></script>";
"    <script type=\"text/javascript\" src=\"/js/swfobject-2.1.min.js\"></script>";
"    <script type=\"text/javascript\">";
"      var flashvars = {};";
"      var params = {menu: 'false', scale: 'noScale', allowScriptAccess: 'always', bgcolor: '#FFFFFF'};";
"      var attributes = {id: 'JavascriptSocket', name: 'JavascriptSocket'};";
"      swfobject.embedSWF('/flash/javascriptsocket.swf', 'flash-content', '100%', '100%', '9.0.0', null, flashvars, params, attributes);";
"    </script>";
"  {{/page.swf}}";
"  <link type=\"text/css\" rel=\"stylesheet\" href=\"/css/bootstrap-2.0.2.min.css\">";
"  <link type=\"text/css\" rel=\"stylesheet\" href=\"/css/bootstrap-responsive-2.0.2.min.css\">";
"  <link type=\"text/css\" rel=\"stylesheet\" href=\"/css/font-awesome-1.0.0-7.min.css\">";
"  <link type=\"text/css\" rel=\"stylesheet\" href=\"/css/moo-0.0.4.min.css\">";
"  <link type=\"text/css\" rel=\"stylesheet\" href=\"/css/console.min.css\">";
"  <script type=\"text/javascript\" src=\"/js/jquery-1.7.1.min.js\"></script>";
"  <script type=\"text/javascript\" src=\"/js/jquery.ui.core-1.8.18.min.js\"></script>";
"  <script type=\"text/javascript\" src=\"/js/jquery.ui.widget-1.8.18.min.js\"></script>";
"  <script type=\"text/javascript\" src=\"/js/jquery.console-1.1.0.min.js\"></script>";
"  <script type=\"text/javascript\" src=\"/js/underscore-1.3.1.min.js\"></script>";
"  <script type=\"text/javascript\" src=\"/js/backbone-0.9.2.min.js\"></script>";
"  <script type=\"text/javascript\" src=\"/js/bootstrap-dropdown-2.0.2.js\"></script>";
"  <script type=\"text/javascript\" src=\"/js/bootstrap-modal-2.0.2.js\"></script>";
"  <script type=\"text/javascript\" src=\"/js/bootstrap-transition-2.0.2.js\"></script>";
"  <script type=\"text/javascript\" src=\"/js/moo-0.0.4.min.js\"></script>";
"  <script type=\"text/javascript\" src=\"/js/moo-interactive-0.0.4.min.js\"></script>";
"</head>";
"";
"chunk_length:32";
"chunk_type:source";
"content_type:application/x-mustache";
"sha1:DA6EB3024B12C0E657413052CFF03E5437A12D8A";
"-=-=-mxyzptlk-=-=-";
.
#146:1
stack = args;
output = {};
output = {@output, ""};
failed = 0;
if (top = `stack[1]["page"] ! E_RANGE')
stack = {stack[1]:merge((typeof(top) == MAP) ? top | ([])), @stack};
else
stack = {[], @stack};
failed = 1;
endif
if ((!failed) && (top = `stack[1]["swf"] ! E_RANGE'))
for item in ((typeof(top) == LIST) ? top | {top})
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
stack = {(typeof(item) == MAP) ? item | (["." -> item]), @stack};
output = {@output, 1};
output = {@output, "  <div id=\"flash-content\"></div>", 0};
output = {@output, ""};
stack = stack[2..$];
endfor
endif
stack = stack[2..$];
output = {@output, 1};
output = {@output, "<script type=\"text/javascript\">", 0};
output = {@output, "", 0};
output = {@output, "  var authenticity_token = $(\"meta[name=authenticity_token]\").attr(\"content\");", 0};
output = {@output, "", 0};
output = {@output, "  $(document).ajaxSend(function(event, xhr, settings) {", 0};
output = {@output, "    xhr.setRequestHeader(\"X-Authenticity-Token\", authenticity_token);", 0};
output = {@output, "  });", 0};
output = {@output, "", 0};
output = {@output, "  $(\"#disconnect\").click(function(e) {", 0};
output = {@output, "    e.preventDefault();", 0};
output = {@output, "    $.post($(this).attr(\"href\"), function() {", 0};
output = {@output, "      window.location.href = \"/\";", 0};
output = {@output, "    });", 0};
output = {@output, "  });", 0};
output = {@output, "</script>", 0};
out = {};
acc = {};
indent = "";
while (output)
{line, @output} = output;
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
if (typeof(line) == LIST)
elseif (typeof(line) == INT)
if (line > 0)
if (match(acc = tostr(@acc), "[^ ]"))
out = {@out, acc};
endif
else
out = {@out, tostr(@acc)};
endif
acc = {};
else
acc = {@acc, line};
endif
endwhile
return out;
return;
"{{#page.swf}}";
"  <div id=\"flash-content\"></div>";
"{{/page.swf}}";
"<script type=\"text/javascript\">";
"";
"  var authenticity_token = $(\"meta[name=authenticity_token]\").attr(\"content\");";
"";
"  $(document).ajaxSend(function(event, xhr, settings) {";
"    xhr.setRequestHeader(\"X-Authenticity-Token\", authenticity_token);";
"  });";
"";
"  $(\"#disconnect\").click(function(e) {";
"    e.preventDefault();";
"    $.post($(this).attr(\"href\"), function() {";
"      window.location.href = \"/\";";
"    });";
"  });";
"</script>";
"";
"chunk_length:18";
"chunk_type:source";
"content_type:application/x-mustache";
"sha1:9F3D0B2DEE4CB78C3D159EFEFFEA556046D6BAC2";
"-=-=-mxyzptlk-=-=-";
.
#146:2
stack = args;
output = {};
output = {@output, "<div class=\"navbar navbar-fixed-top\">", 0};
output = {@output, "  <div class=\"navbar-inner\">", 0};
output = {@output, "    <div class=\"container\">", 0};
output = {@output, "      <a class=\"brand\" href=\"/\">", 0};
output = {@output, "        "};
top = `stack[1]["page"] ! E_RANGE';
stack = {(typeof(top) == MAP) ? top | ([]), @stack};
output = {@output, strsub(strsub(strsub(strsub(`tostr(stack[1]["title"]) ! E_RANGE => ""', "&", "&amp;"), "<", "&lt;"), ">", "&gt;"), "\"", "&quot;")};
stack = stack[2..$];
output = {@output, 1};
output = {@output, "      </a>", 0};
output = {@output, "      <ul class=\"nav\">", 0};
output = {@output, "        "};
if (top = `stack[1]["player"] ! E_RANGE')
for item in ((typeof(top) == LIST) ? top | {top})
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
stack = {stack[1]:merge((typeof(item) == MAP) ? item | (["." -> item])), @stack};
output = {@output, 1};
output = {@output, "          <li>", 0};
output = {@output, "            <a href=\"/\">Console</a>", 0};
output = {@output, "          </li>", 0};
output = {@output, "        "};
stack = stack[2..$];
endfor
endif
output = {@output, 1};
output = {@output, "        <li class=\"dropdown\">", 0};
output = {@output, "          <a href=\"#\" class=\"dropdown-toggle\" data-toggle=\"dropdown\">Browse To<b class=\"caret\"></b></a>", 0};
output = {@output, "          <ul class=\"dropdown-menu\">", 0};
output = {@output, "            "};
if (top = `stack[1]["links"] ! E_RANGE')
for item in ((typeof(top) == LIST) ? top | {top})
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
stack = {stack[1]:merge((typeof(item) == MAP) ? item | (["." -> item])), @stack};
output = {@output, 1};
output = {@output, "              <li><a rel=\"object\" data-object-number=\""};
output = {@output, strsub(strsub(strsub(strsub(`tostr(stack[1]["id"]) ! E_RANGE => ""', "&", "&amp;"), "<", "&lt;"), ">", "&gt;"), "\"", "&quot;")};
output = {@output, "\" href=\"/objects/"};
output = {@output, strsub(strsub(strsub(strsub(`tostr(stack[1]["id"]) ! E_RANGE => ""', "&", "&amp;"), "<", "&lt;"), ">", "&gt;"), "\"", "&quot;")};
output = {@output, "\">"};
output = {@output, strsub(strsub(strsub(strsub(`tostr(stack[1]["name"]) ! E_RANGE => ""', "&", "&amp;"), "<", "&lt;"), ">", "&gt;"), "\"", "&quot;")};
output = {@output, "</a></li>", 3};
output = {@output, "            "};
stack = stack[2..$];
endfor
endif
output = {@output, 1};
output = {@output, "          </ul>", 0};
output = {@output, "        </li>", 0};
output = {@output, "      </ul>", 0};
output = {@output, "      <ul class=\"nav pull-right\">", 0};
output = {@output, "        "};
if (top = `stack[1]["player"] ! E_RANGE')
for item in ((typeof(top) == LIST) ? top | {top})
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
stack = {stack[1]:merge((typeof(item) == MAP) ? item | (["." -> item])), @stack};
output = {@output, 1};
output = {@output, "          <li><a id=\"disconnect\" href=\"/session/destroy\">Disconnect</a></li>", 0};
output = {@output, "        "};
stack = stack[2..$];
endfor
endif
output = {@output, 1};
output = {@output, "        "};
if (!(top = `stack[1]["player"] ! E_RANGE'))
for item in ({""})
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
stack = {stack[1]:merge((typeof(item) == MAP) ? item | (["." -> item])), @stack};
output = {@output, 1};
output = {@output, "          <li><a href=\"/\">Connect</a></li>", 0};
output = {@output, "        "};
stack = stack[2..$];
endfor
endif
output = {@output, 1};
output = {@output, "      </ul>", 0};
output = {@output, "    </div>", 0};
output = {@output, "  </div>", 0};
output = {@output, "</div>", 0};
out = {};
acc = {};
indent = "";
while (output)
{line, @output} = output;
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
if (typeof(line) == LIST)
elseif (typeof(line) == INT)
if (line > 0)
if (match(acc = tostr(@acc), "[^ ]"))
out = {@out, acc};
endif
else
out = {@out, tostr(@acc)};
endif
acc = {};
else
acc = {@acc, line};
endif
endwhile
return out;
return;
"<div class=\"navbar navbar-fixed-top\">";
"  <div class=\"navbar-inner\">";
"    <div class=\"container\">";
"      <a class=\"brand\" href=\"/\">";
"        {{page.title}}";
"      </a>";
"      <ul class=\"nav\">";
"        {{#player}}";
"          <li>";
"            <a href=\"/\">Console</a>";
"          </li>";
"        {{/player}}";
"        <li class=\"dropdown\">";
"          <a href=\"#\" class=\"dropdown-toggle\" data-toggle=\"dropdown\">Browse To<b class=\"caret\"></b></a>";
"          <ul class=\"dropdown-menu\">";
"            {{#links}}";
"              <li><a rel=\"object\" data-object-number=\"{{id}}\" href=\"/objects/{{id}}\">{{name}}</a></li>";
"            {{/links}}";
"          </ul>";
"        </li>";
"      </ul>";
"      <ul class=\"nav pull-right\">";
"        {{#player}}";
"          <li><a id=\"disconnect\" href=\"/session/destroy\">Disconnect</a></li>";
"        {{/player}}";
"        {{^player}}";
"          <li><a href=\"/\">Connect</a></li>";
"        {{/player}}";
"      </ul>";
"    </div>";
"  </div>";
"</div>";
"";
"chunk_length:32";
"chunk_type:source";
"content_type:application/x-mustache";
"sha1:BB81418E9CDC9537A706F603B5475A95D2ACB503";
"-=-=-mxyzptlk-=-=-";
.
#146:3
stack = args;
output = {};
output = {@output, "<!DOCTYPE html>", 0};
output = {@output, "<html lang=\"en\">", 0};
output = {@output, ""};
verb = `this:_head(@stack) ! E_VERBNF => {}';
output = {@output, verb};
output = {@output, 1};
output = {@output, "<body>", 0};
output = {@output, "  <style type=\"text/css\">", 0};
output = {@output, "    body .container .mark {", 0};
output = {@output, "      font-weight: bold;", 0};
output = {@output, "    }", 0};
output = {@output, "    #logo {", 0};
output = {@output, "      width: 450px;", 0};
output = {@output, "      margin: 40px 10px;", 0};
output = {@output, "    }", 0};
output = {@output, "  </style>", 0};
output = {@output, "  <div class=\"container\">", 0};
output = {@output, "    &nbsp;", 0};
output = {@output, "    <div class=\"row\">", 0};
output = {@output, "      <div class=\"span12\">", 0};
output = {@output, "        <h1>Welcome to Stunt | Improvise</h1>", 0};
output = {@output, "      </div>", 0};
output = {@output, "    </div>", 0};
output = {@output, "    &nbsp;", 0};
output = {@output, "    <div class=\"row\">", 0};
output = {@output, "      <div class=\"span5\">", 0};
output = {@output, "        <form class=\"well form-inline\" action=\"/session/create\" method=\"post\">", 0};
output = {@output, "          "};
verb = `this:authenticity_token_form_input(@stack) ! E_VERBNF => {}';
output = {@output, verb};
output = {@output, 1};
output = {@output, "          <button type=\"submit\" name=\"submit\">Connect</button>", 0};
output = {@output, "          <input class=\"span3\" type=\"text\" name=\"credentials\" placeholder=\"credentials, ex: &lt;player&gt; &lt;password&gt;\">", 0};
output = {@output, "        </form>", 0};
output = {@output, "        <img id=\"logo\" src=\"/img/stunt.png\">", 0};
output = {@output, "      </div>", 0};
output = {@output, "      <div class=\"span7\">", 0};
output = {@output, "        <h2>Get Started</h2>", 0};
output = {@output, "        <p>", 0};
output = {@output, "          &larr; Use the form on the left to connect to a specific player.", 0};
output = {@output, "        </p>", 0};
output = {@output, "        <h2>About Stunt | Improvise</h2>", 0};
output = {@output, "        <p>", 0};
output = {@output, "          <a href=\"https://github.com/toddsundsted/stunt\">Stunt</a>", 0};
output = {@output, "          is a set of extensions to the <a href=\"http://sourceforge.net/projects/lambdamoo/\">LambdaMOO server</a>", 0};
output = {@output, "          and <a href=\"https://github.com/toddsundsted/improvise\">Improvise</a>", 0};
output = {@output, "          is an associated framework that uses those extensions.", 0};
output = {@output, "        </p>", 0};
output = {@output, "        <p>", 0};
output = {@output, "          <span class=\"mark\">Stunt | Improvise</span> is well suited", 0};
output = {@output, "          for building immersive, collaborative, Web-based", 0};
output = {@output, "          applications &mdash; specifically, applications where", 0};
output = {@output, "          every <em>user</em> is a <em>programmer</em>.", 0};
output = {@output, "        </p>", 0};
output = {@output, "        <p>", 0};
output = {@output, "          Together, <span class=\"mark\">Stunt | Improvise</span>", 0};
output = {@output, "          comprise:", 0};
output = {@output, "        </p>", 0};
output = {@output, "        <ul>", 0};
output = {@output, "          <li>a persistent, NoSQL object database with a simple JSON API</li>", 0};
output = {@output, "          <li>an server-side HTTP-based MVC framework with support for HTML5 features like pushState</li>", 0};
output = {@output, "          <li>a client-side RAI framework based on Backbone.js</li>", 0};
output = {@output, "          <li>a framework for securely executing untrusted code</li>", 0};
output = {@output, "          <li>a simple, embedded programming language</li>", 0};
output = {@output, "          <li>integrated package management</li>", 0};
output = {@output, "        </ul>", 0};
output = {@output, "        <h2>Learn More</h2>", 0};
output = {@output, "        <p>", 0};
output = {@output, "          To learn more, check out:", 0};
output = {@output, "        </p>", 0};
output = {@output, "        <ul>", 0};
output = {@output, "          <li><a href=\"http://stunt.io/\">the Stunt.io website</a></li>", 0};
output = {@output, "          <li><a href=\"http://stunt.io/ProgrammersManual.html\">the LambdaMOO Programmers Manual</a></li>", 0};
output = {@output, "          <li><a href=\"https://github.com/toddsundsted/stunt\">the Stunt GitHub project</a></li>", 0};
output = {@output, "          <li><a href=\"https://github.com/toddsundsted/improvise\">the Improvise GitHub project</a></li>", 0};
output = {@output, "        </ul>", 0};
output = {@output, "      </div>", 0};
output = {@output, "    </div>", 0};
output = {@output, "  </div>", 0};
output = {@output, ""};
verb = `this:_foot(@stack) ! E_VERBNF => {}';
output = {@output, verb};
output = {@output, 1};
output = {@output, "</body>", 0};
output = {@output, "</html>", 0};
out = {};
acc = {};
indent = "";
while (output)
{line, @output} = output;
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
if (typeof(line) == LIST)
if (lines = line)
if (length(lines) > 1)
temp = {lines[1], 0};
for line in (lines[2..$ - 1])
temp = {@temp, indent + line, 0};
endfor
temp = {@temp, indent + lines[$]};
output = {@temp, @output};
else
output = {lines[1], @output};
endif
endif
elseif (typeof(line) == INT)
if (line > 0)
if (match(acc = tostr(@acc), "[^ ]"))
out = {@out, acc};
endif
else
out = {@out, tostr(@acc)};
endif
acc = {};
indent = "";
else
if (!match(line, "[^ ]"))
indent = line;
endif
acc = {@acc, line};
endif
endwhile
return out;
return;
"<!DOCTYPE html>";
"<html lang=\"en\">";
"{{> _head}}";
"<body>";
"  <style type=\"text/css\">";
"    body .container .mark {";
"      font-weight: bold;";
"    }";
"    #logo {";
"      width: 450px;";
"      margin: 40px 10px;";
"    }";
"  </style>";
"  <div class=\"container\">";
"    &nbsp;";
"    <div class=\"row\">";
"      <div class=\"span12\">";
"        <h1>Welcome to Stunt | Improvise</h1>";
"      </div>";
"    </div>";
"    &nbsp;";
"    <div class=\"row\">";
"      <div class=\"span5\">";
"        <form class=\"well form-inline\" action=\"/session/create\" method=\"post\">";
"          {{>authenticity_token_form_input}}";
"          <button type=\"submit\" name=\"submit\">Connect</button>";
"          <input class=\"span3\" type=\"text\" name=\"credentials\" placeholder=\"credentials, ex: &lt;player&gt; &lt;password&gt;\">";
"        </form>";
"        <img id=\"logo\" src=\"/img/stunt.png\">";
"      </div>";
"      <div class=\"span7\">";
"        <h2>Get Started</h2>";
"        <p>";
"          &larr; Use the form on the left to connect to a specific player.";
"        </p>";
"        <h2>About Stunt | Improvise</h2>";
"        <p>";
"          <a href=\"https://github.com/toddsundsted/stunt\">Stunt</a>";
"          is a set of extensions to the <a href=\"http://sourceforge.net/projects/lambdamoo/\">LambdaMOO server</a>";
"          and <a href=\"https://github.com/toddsundsted/improvise\">Improvise</a>";
"          is an associated framework that uses those extensions.";
"        </p>";
"        <p>";
"          <span class=\"mark\">Stunt | Improvise</span> is well suited";
"          for building immersive, collaborative, Web-based";
"          applications &mdash; specifically, applications where";
"          every <em>user</em> is a <em>programmer</em>.";
"        </p>";
"        <p>";
"          Together, <span class=\"mark\">Stunt | Improvise</span>";
"          comprise:";
"        </p>";
"        <ul>";
"          <li>a persistent, NoSQL object database with a simple JSON API</li>";
"          <li>an server-side HTTP-based MVC framework with support for HTML5 features like pushState</li>";
"          <li>a client-side RAI framework based on Backbone.js</li>";
"          <li>a framework for securely executing untrusted code</li>";
"          <li>a simple, embedded programming language</li>";
"          <li>integrated package management</li>";
"        </ul>";
"        <h2>Learn More</h2>";
"        <p>";
"          To learn more, check out:";
"        </p>";
"        <ul>";
"          <li><a href=\"http://stunt.io/\">the Stunt.io website</a></li>";
"          <li><a href=\"http://stunt.io/ProgrammersManual.html\">the LambdaMOO Programmers Manual</a></li>";
"          <li><a href=\"https://github.com/toddsundsted/stunt\">the Stunt GitHub project</a></li>";
"          <li><a href=\"https://github.com/toddsundsted/improvise\">the Improvise GitHub project</a></li>";
"        </ul>";
"      </div>";
"    </div>";
"  </div>";
"{{> _foot}}";
"</body>";
"</html>";
"";
"chunk_length:76";
"chunk_type:source";
"content_type:application/x-mustache";
"sha1:4EC70131E3D3149EC0D031768D6559CEE3BDAD2A";
"-=-=-mxyzptlk-=-=-";
.
#146:4
stack = args;
output = {};
output = {@output, "<!DOCTYPE html>", 0};
output = {@output, "<html lang=\"en\">", 0};
output = {@output, "  "};
verb = `this:_head(@stack) ! E_VERBNF => {}';
output = {@output, verb};
output = {@output, 1};
output = {@output, "  <body>", 0};
output = {@output, "    "};
verb = `this:_nav(@stack) ! E_VERBNF => {}';
output = {@output, verb};
output = {@output, 1};
output = {@output, "    <div id=\"top\" class=\"container\" style=\"padding-top: 60px;\">", 0};
output = {@output, "      <div class=\"row\">", 0};
output = {@output, "        <div id=\"console\" class=\"console span12\"></div>", 0};
output = {@output, "      </div>", 0};
output = {@output, "    </div>", 0};
output = {@output, "    <script type=\"text/javascript\">", 0};
output = {@output, "      $(function() {", 0};
output = {@output, "        var console1 = $('#console').console({", 0};
output = {@output, "           autofocus:true,", 0};
output = {@output, "           animateScroll:true,", 0};
output = {@output, "           promptHistory:true,", 0};
output = {@output, "           promptLabel: '> ',", 0};
output = {@output, "           commandHandle:function(command){", 0};
output = {@output, "             interactive.send(command + '\\n');", 0};
output = {@output, "             return true;", 0};
output = {@output, "           }", 0};
output = {@output, "        });", 0};
output = {@output, "        $('#console .jquery-console-inner').height($(window).height() - 140);", 0};
output = {@output, "        var interactive = new Moo.Interactive(window.location.hostname, window.location.port, {", 0};
output = {@output, "          session_state: $('meta[name=session_state]').attr('content'),", 0};
output = {@output, "          authenticity_token: $('meta[name=authenticity_token]').attr('content'),", 0};
output = {@output, "          callback: function(message) {", 0};
output = {@output, "            message = message.split('\\n');", 0};
output = {@output, "            message = _.select(message, function(v) { return v; });", 0};
output = {@output, "            message = _.map(message, function(v) { return {msg: v} });", 0};
output = {@output, "            console1.append(message);", 0};
output = {@output, "          }", 0};
output = {@output, "        });", 0};
output = {@output, "      });", 0};
output = {@output, "    </script>", 0};
output = {@output, "    "};
verb = `this:_foot(@stack) ! E_VERBNF => {}';
output = {@output, verb};
output = {@output, 1};
output = {@output, "  </body>", 0};
output = {@output, "</html>", 0};
out = {};
acc = {};
indent = "";
while (output)
{line, @output} = output;
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
if (typeof(line) == LIST)
if (lines = line)
if (length(lines) > 1)
temp = {lines[1], 0};
for line in (lines[2..$ - 1])
temp = {@temp, indent + line, 0};
endfor
temp = {@temp, indent + lines[$]};
output = {@temp, @output};
else
output = {lines[1], @output};
endif
endif
elseif (typeof(line) == INT)
if (line > 0)
if (match(acc = tostr(@acc), "[^ ]"))
out = {@out, acc};
endif
else
out = {@out, tostr(@acc)};
endif
acc = {};
indent = "";
else
if (!match(line, "[^ ]"))
indent = line;
endif
acc = {@acc, line};
endif
endwhile
return out;
return;
"<!DOCTYPE html>";
"<html lang=\"en\">";
"  {{> _head}}";
"  <body>";
"    {{> _nav}}";
"    <div id=\"top\" class=\"container\" style=\"padding-top: 60px;\">";
"      <div class=\"row\">";
"        <div id=\"console\" class=\"console span12\"></div>";
"      </div>";
"    </div>";
"    <script type=\"text/javascript\">";
"      $(function() {";
"        var console1 = $('#console').console({";
"           autofocus:true,";
"           animateScroll:true,";
"           promptHistory:true,";
"           promptLabel: '> ',";
"           commandHandle:function(command){";
"             interactive.send(command + '\\n');";
"             return true;";
"           }";
"        });";
"        $('#console .jquery-console-inner').height($(window).height() - 140);";
"        var interactive = new Moo.Interactive(window.location.hostname, window.location.port, {";
"          session_state: $('meta[name=session_state]').attr('content'),";
"          authenticity_token: $('meta[name=authenticity_token]').attr('content'),";
"          callback: function(message) {";
"            message = message.split('\\n');";
"            message = _.select(message, function(v) { return v; });";
"            message = _.map(message, function(v) { return {msg: v} });";
"            console1.append(message);";
"          }";
"        });";
"      });";
"    </script>";
"    {{> _foot}}";
"  </body>";
"</html>";
"";
"chunk_length:38";
"chunk_type:source";
"content_type:application/x-mustache";
"sha1:3256046A1B5E54E4F0D2229BABF4BEB583F1EEAD";
"-=-=-mxyzptlk-=-=-";
.
#146:5
stack = args;
output = {};
output = {@output, "<!DOCTYPE html>", 0};
output = {@output, "<html lang=\"en\">", 0};
output = {@output, "  "};
verb = `this:_head(@stack) ! E_VERBNF => {}';
output = {@output, verb};
output = {@output, 1};
output = {@output, "  <body>", 0};
output = {@output, "    "};
verb = `this:_nav(@stack) ! E_VERBNF => {}';
output = {@output, verb};
output = {@output, 1};
output = {@output, "    <div id=\"top\" class=\"container\" style=\"padding-top: 60px;\">", 0};
output = {@output, "      <p id=\"browser\" class=\"browser\"></p>", 0};
output = {@output, "    </div>", 0};
output = {@output, "    <script type=\"text/javascript\">", 0};
output = {@output, "      $(function() {", 0};
output = {@output, "        var service_url = $(\"meta[name=service_url]\").attr(\"content\")", 0};
output = {@output, "", 0};
output = {@output, "        Moo.Object.prototype.urlRoot = 'http://' + window.location.host + service_url + 'objects';", 0};
output = {@output, "", 0};
output = {@output, "        var $browser = $('#browser');", 0};
output = {@output, "        $browser.simpleObjectPanel();", 0};
output = {@output, "", 0};
output = {@output, "        Moo.Space = Backbone.Router.extend({", 0};
output = {@output, "          routes: {", 0};
output = {@output, "            'objects/:number': 'browse'", 0};
output = {@output, "          },", 0};
output = {@output, "          browse: function(number) {", 0};
output = {@output, "            var o = new Moo.Object({id: number});", 0};
output = {@output, "            o.fetch({", 0};
output = {@output, "              success: function(model, response) {", 0};
output = {@output, "                $browser.simpleObjectPanel({object: o});", 0};
output = {@output, "                $('#top').get(0).scrollIntoView(true);", 0};
output = {@output, "              },", 0};
output = {@output, "              error: function(model, response) {", 0};
output = {@output, "                $browser.simpleObjectPanel({object: o});", 0};
output = {@output, "                $('#top').get(0).scrollIntoView(true);", 0};
output = {@output, "              }", 0};
output = {@output, "            });", 0};
output = {@output, "          }", 0};
output = {@output, "        });", 0};
output = {@output, "        var moo = new Moo.Space;", 0};
output = {@output, "", 0};
output = {@output, "        $('body').on('click', 'a[rel*=object]', function(e) {", 0};
output = {@output, "          e.preventDefault();", 0};
output = {@output, "          var o = $(e.target).data('object-number');", 0};
output = {@output, "          moo.navigate('/objects/' + o, {trigger: true});", 0};
output = {@output, "        });", 0};
output = {@output, "", 0};
output = {@output, "        Backbone.history.start({pushState: true});", 0};
output = {@output, "", 0};
output = {@output, "        "};
if (top = `stack[1]["id"] ! E_RANGE')
for item in ((typeof(top) == LIST) ? top | {top})
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
stack = {stack[1]:merge((typeof(item) == MAP) ? item | (["." -> item])), @stack};
output = {@output, 1};
output = {@output, "          moo.navigate('/objects/"};
output = {@output, strsub(strsub(strsub(strsub(`tostr(stack[1]["id"]) ! E_RANGE => ""', "&", "&amp;"), "<", "&lt;"), ">", "&gt;"), "\"", "&quot;")};
output = {@output, "');", 1};
output = {@output, "        "};
stack = stack[2..$];
endfor
endif
output = {@output, 1};
output = {@output, "      });", 0};
output = {@output, "    </script>", 0};
output = {@output, "    "};
verb = `this:_foot(@stack) ! E_VERBNF => {}';
output = {@output, verb};
output = {@output, 1};
output = {@output, "  </body>", 0};
output = {@output, "</html>", 0};
out = {};
acc = {};
indent = "";
while (output)
{line, @output} = output;
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
if (typeof(line) == LIST)
if (lines = line)
if (length(lines) > 1)
temp = {lines[1], 0};
for line in (lines[2..$ - 1])
temp = {@temp, indent + line, 0};
endfor
temp = {@temp, indent + lines[$]};
output = {@temp, @output};
else
output = {lines[1], @output};
endif
endif
elseif (typeof(line) == INT)
if (line > 0)
if (match(acc = tostr(@acc), "[^ ]"))
out = {@out, acc};
endif
else
out = {@out, tostr(@acc)};
endif
acc = {};
indent = "";
else
if (!match(line, "[^ ]"))
indent = line;
endif
acc = {@acc, line};
endif
endwhile
return out;
return;
"<!DOCTYPE html>";
"<html lang=\"en\">";
"  {{> _head}}";
"  <body>";
"    {{> _nav}}";
"    <div id=\"top\" class=\"container\" style=\"padding-top: 60px;\">";
"      <p id=\"browser\" class=\"browser\"></p>";
"    </div>";
"    <script type=\"text/javascript\">";
"      $(function() {";
"        var service_url = $(\"meta[name=service_url]\").attr(\"content\")";
"";
"        Moo.Object.prototype.urlRoot = 'http://' + window.location.host + service_url + 'objects';";
"";
"        var $browser = $('#browser');";
"        $browser.simpleObjectPanel();";
"";
"        Moo.Space = Backbone.Router.extend({";
"          routes: {";
"            'objects/:number': 'browse'";
"          },";
"          browse: function(number) {";
"            var o = new Moo.Object({id: number});";
"            o.fetch({";
"              success: function(model, response) {";
"                $browser.simpleObjectPanel({object: o});";
"                $('#top').get(0).scrollIntoView(true);";
"              },";
"              error: function(model, response) {";
"                $browser.simpleObjectPanel({object: o});";
"                $('#top').get(0).scrollIntoView(true);";
"              }";
"            });";
"          }";
"        });";
"        var moo = new Moo.Space;";
"";
"        $('body').on('click', 'a[rel*=object]', function(e) {";
"          e.preventDefault();";
"          var o = $(e.target).data('object-number');";
"          moo.navigate('/objects/' + o, {trigger: true});";
"        });";
"";
"        Backbone.history.start({pushState: true});";
"";
"        {{#id}}";
"          moo.navigate('/objects/{{id}}');";
"        {{/id}}";
"      });";
"    </script>";
"    {{> _foot}}";
"  </body>";
"</html>";
"";
"chunk_length:53";
"chunk_type:source";
"content_type:application/x-mustache";
"sha1:0F67D3CD34E6018A9536F0B87F5C61DDFA04E0BA";
"-=-=-mxyzptlk-=-=-";
.
#147:0
$restrict_to_caller($dialog.server);
{parameters} = args;
credentials = `parameters["credentials"] ! E_RANGE => ""';
if (valid(player = $authenticate(@credentials:split())))
this.session = ["player" -> player];
endif
this:moved(parameters["__url_base__"] + "/");
return;
"$restrict_to_caller($dialog.server)";
"";
"{parameters} = args";
"";
"credentials = (parameters[\"credentials\"] !! E_RANGE => \"\")";
"";
"if (valid(player = $authenticate(@credentials:split())))";
"  this.session = [\"player\" -> player] // blow away the session; set the player";
"endif";
"";
"this:moved(parameters[\"__url_base__\"] + \"/\")";
"";
"chunk_length:11";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:C0CEBBB081BB6112DE4A4C65C489AA68DCEEB7C6";
"-=-=-mxyzptlk-=-=-";
.
#147:1
$restrict_to_caller($dialog.server);
{parameters} = args;
this.session = ["player" -> $nothing];
this:moved(parameters["__url_base__"] + "/");
return;
"$restrict_to_caller($dialog.server)";
"";
"{parameters} = args";
"";
"this.session = [\"player\" -> $nothing] // blow away the session; reset the player";
"";
"this:moved(parameters[\"__url_base__\"] + \"/\")";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:AA365D0C0DE126B66D46948A899EA785142A1F1F";
"-=-=-mxyzptlk-=-=-";
.
#148:0
$restrict_to_caller($dialog.server);
{request} = args;
path = request:path():split("/");
method = request:method();
{host, ?port = 80} = `request:headers()["host"]:split(":") ! E_RANGE => {""}';
parameters = ["__base_uri__" -> host ? tostr("http://", host, ":", port) | "", "__connection__" -> player];
if ((!path) && (method == "get"))
return {this.home_controller, "home", parameters};
elseif (((length(path) == 2) && (path[1] == "objects")) && (method == "get"))
return {this.home_controller, "browse", parameters:merge(["id" -> path[2]])};
elseif ((path == {"session", "create"}) && (method == "post"))
return {this.session_controller, path[2], parameters};
elseif ((path == {"session", "destroy"}) && (method == "post"))
return {this.session_controller, path[2], parameters};
endif
return {};
return;
"$restrict_to_caller($dialog.server)";
"";
"{request} = args";
"";
"path = request:path():split(\"/\")";
"method = request:method()";
"";
"{host, port = 80} = (request:headers()[\"host\"]:split(\":\") !! E_RANGE => {\"\"})";
"";
"parameters = [";
"  \"__base_uri__\" -> host ? tostr(\"http://\", host, \":\", port) | \"\",";
"  \"__connection__\" -> player";
"]";
"";
"if (!path && method == \"get\")";
"  return {this.home_controller, \"home\", parameters}";
"elseif (length(path) == 2 && path[1] == \"objects\" && method == \"get\")";
"  return {this.home_controller, \"browse\", parameters:merge([\"id\" -> path[2]])}";
"elseif (path == {\"session\", \"create\"} && method == \"post\")";
"  return {this.session_controller, path[2], parameters}";
"elseif (path == {\"session\", \"destroy\"} && method == \"post\")";
"  return {this.session_controller, path[2], parameters}";
"end";
"";
"return {}";
"";
"chunk_length:25";
"chunk_type:source";
"content_type:application/x-moocode;version=1.0.0";
"sha1:D1CBE0B51F1D1E9F69E87E10F5F38CD6288BDF46";
"-=-=-mxyzptlk-=-=-";
.
#149:0
$restrict_to_caller(this.ask_proto);
{query, limit} = args;
((from = query.from) == 0) && raise(E_INVARG, "Missing from");
select = where = {};
if (operations = query.operations)
for operation in (operations)
`select = operation["select"] ! E_RANGE';
`where = {@where, operation["where"]} ! E_RANGE';
endfor
endif
set_task_perms(callers()[2][3]);
if (((type = typeof(from)) == OBJ) && valid(from))
from = descendants(from);
elseif ((type == LIST) && (length(from) < 1))
type = -1;
elseif ((type == LIST) && ((type = typeof(from[1])) in {OBJ, MAP, LIST}))
else
raise(E_INVARG, tostr("Invalid from:  ", toliteral(from)));
endif
res = {};
for o in (from)
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
for w in (where)
{o1, op, o2} = w;
if (o1[1] < 0)
try
o1 = this:lookup(type, o, o1[2]);
except ex ("type mismatch", "not found", "permission denied")
o = [$ask.ERRORS -> [o1[2] -> ex[1]]];
break w;
endtry
else
o1 = o1[2];
endif
if (o2[1] < 0)
try
o2 = this:lookup(type, o, o2[2]);
except ex ("type mismatch", "not found", "permission denied")
o = [$ask.ERRORS -> [o2[2] -> ex[1]]];
break w;
endtry
else
o2 = o2[2];
endif
try
if ((op == "=") || (op == "=="))
if (o1 != o2)
continue o;
endif
elseif (op == "!=")
if (o1 == o2)
continue o;
endif
elseif (op == ">")
if (o1 <= o2)
continue o;
endif
elseif (op == ">=")
if (o1 < o2)
continue o;
endif
elseif (op == "<")
if (o1 >= o2)
continue o;
endif
elseif (op == "<=")
if (o1 > o2)
continue o;
endif
elseif (op == "includes")
if (!(o2 in o1))
continue o;
endif
elseif (op == "in")
if (!(o1 in o2))
continue o;
endif
elseif (op == "is")
if ((o1 && (!o2)) || ((!o1) && o2))
continue o;
endif
elseif (op == "=~")
if (!match(o1, o2))
continue o;
endif
else
raise(E_INVARG, tostr("Invalid operation:  ", op));
endif
except (E_TYPE)
o = [$ask.ERRORS -> tostr("type mismatch:  ", toliteral(o1), " ", op, " ", toliteral(o2))];
break w;
endtry
endfor
if (`o[$ask.ERRORS] ! E_TYPE, E_RANGE')
res = {@res, o};
elseif (select)
r = [];
for s in (select)
try
r[s] = this:lookup(type, o, s);
except ex ("type mismatch", "not found", "permission denied")
r = r:set_value_by_path({$ask.ERRORS, s}, ex[1]);
endtry
endfor
res = {@res, r};
else
res = {@res, o};
endif
if ((limit > 0) && res)
break;
endif
endfor
return (limit > 0) ? res ? res[1] | $failed_match | res;
return;
"$restrict_to_caller(this.ask_proto);";
"";
"{query, limit} = args;";
"";
"(from = query.from) == 0 && raise(E_INVARG, \"Missing from\");";
"";
"select = where = {};";
"if (operations = query.operations)";
"  for operation in (operations)";
"    `select = operation[\"select\"] ! E_RANGE';";
"    `where = {@where, operation[\"where\"]} ! E_RANGE';";
"  endfor";
"endif";
"";
"/* perms of the verb that called `all()', `one()'... */";
"set_task_perms(callers()[2][3]);";
"";
"/* `type' indicates the type of field to query over */";
"";
"if ((type = typeof(from)) == OBJ && valid(from))";
"  from = descendants(from);";
"elseif (type == LIST && length(from) < 1)";
"  type = -1;";
"elseif (type == LIST && (type = typeof(from[1])) in {OBJ, MAP, LIST})";
"  /* do nothing, but don't fail */";
"else";
"  raise(E_INVARG, tostr(\"Invalid from:  \", toliteral(from)));";
"endif";
"";
"res = {};";
"";
"for o in (from)";
"  ticks_left() < 10000 || seconds_left() < 2 && suspend(0);";
"  /* WHERE */";
"  for w in (where)";
"    {o1, op, o2} = w;";
"    /* get value from operand */";
"    if (o1[1] < 0)";
"      try";
"        o1 = this:lookup(type, o, o1[2]);";
"      except ex (\"type mismatch\", \"not found\", \"permission denied\")";
"        o = [$ask.ERRORS -> [o1[2] -> ex[1]]];";
"        break w;";
"      endtry";
"    else";
"      o1 = o1[2];";
"    endif";
"    if (o2[1] < 0)";
"      try";
"        o2 = this:lookup(type, o, o2[2]);";
"      except ex (\"type mismatch\", \"not found\", \"permission denied\")";
"        o = [$ask.ERRORS -> [o2[2] -> ex[1]]];";
"        break w;";
"      endtry";
"    else";
"      o2 = o2[2];";
"    endif";
"    /* operate! */";
"    try";
"      if (op == \"=\" || op == \"==\")";
"        if (o1 != o2)";
"          continue o; /* back to the top of the big loop */";
"        endif";
"      elseif (op == \"!=\")";
"        if (o1 == o2)";
"          continue o;";
"        endif";
"      elseif (op == \">\")";
"        if (o1 <= o2)";
"          continue o;";
"        endif";
"      elseif (op == \">=\")";
"        if (o1 < o2)";
"          continue o;";
"        endif";
"      elseif (op == \"<\")";
"        if (o1 >= o2)";
"          continue o;";
"        endif";
"      elseif (op == \"<=\")";
"        if (o1 > o2)";
"          continue o;";
"        endif";
"      elseif (op == \"includes\")";
"        if (!(o2 in o1))";
"          continue o;";
"        endif";
"      elseif (op == \"in\")";
"        if (!(o1 in o2))";
"          continue o;";
"        endif";
"      elseif (op == \"is\")";
"        if ((o1 && !o2) || (!o1 && o2))";
"          continue o;";
"        endif";
"      elseif (op == \"=~\")";
"        if (!match(o1, o2))";
"          continue o;";
"        endif";
"      else";
"        raise(E_INVARG, tostr(\"Invalid operation:  \", op));";
"      endif";
"    except (E_TYPE)";
"      o = [$ask.ERRORS -> tostr(\"type mismatch:  \", toliteral(o1), \" \", op, \" \", toliteral(o2))];";
"      break w;";
"    endtry";
"  endfor";
"  /* SELECT */";
"  if (`o[$ask.ERRORS] ! E_TYPE, E_RANGE')";
"    /* test for errors from the WHERE stage */";
"    res = {@res, o};";
"  elseif (select)";
"    r = [];";
"    for s in (select)";
"      try";
"        r[s] = this:lookup(type, o, s);";
"      except ex (\"type mismatch\", \"not found\", \"permission denied\")";
"        r = r:set_value_by_path({$ask.ERRORS, s}, ex[1]);";
"      endtry";
"    endfor";
"    res = {@res, r};";
"  else";
"    res = {@res, o};";
"  endif";
"";
"  if (limit > 0 && res)";
"    break;";
"  endif";
"endfor";
"";
"return limit > 0 ? (res ? res[1] | $failed_match) | res;";
"";
"chunk_length:131";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:E181326A5B6DCB6DAFB810C95DE78A3536E4F5BD";
"-=-=-mxyzptlk-=-=-";
.
#149:1
$private();
set_task_perms(caller_perms());
{type, target, attr} = args;
try
if (attr == $ask.ID)
return target;
elseif ((type == MAP) || (type == LIST))
return target[attr];
else
return respond_to(target, attr) ? target:(attr)() | target.(attr);
endif
except (E_TYPE)
raise("type mismatch");
except (E_RANGE, E_PROPNF)
raise("not found");
except (E_PERM)
raise("permission denied");
endtry
return;
"$private();";
"";
"set_task_perms(caller_perms());";
"";
"{type, target, attr} = args;";
"";
"try";
"  if (attr == $ask.ID)";
"    return target;";
"  elseif (type == MAP || type == LIST)";
"    return target[attr];";
"  else";
"    return respond_to(target, attr) ? target:(attr)() | target.(attr);";
"  endif";
"except (E_TYPE)";
"  raise(\"type mismatch\");";
"except (E_RANGE, E_PROPNF)";
"  raise(\"not found\");";
"except (E_PERM)";
"  raise(\"permission denied\");";
"endtry";
"";
"chunk_length:21";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:FBDFFE1F31913432DA0D40246E1FCE695664493B";
"-=-=-mxyzptlk-=-=-";
.
